{"/home/travis/build/npmtest/node-npmtest-js-dom/test.js":"/* istanbul instrument in package npmtest_js_dom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-js-dom/lib.npmtest_js_dom.js":"/* istanbul instrument in package npmtest_js_dom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_js_dom = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_js_dom = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-js-dom/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-js-dom && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_js_dom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_js_dom\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_js_dom.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_js_dom.rollup.js'] =\n            local.assetsDict['/assets.npmtest_js_dom.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_js_dom.__dirname + '/lib.npmtest_js_dom.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom.js":"var fs = require('fs');\nvar path = require('path');\nvar URL = require('url');\nvar request = require('request');\nvar pkg = require('../package.json');\nvar iconv = require('iconv-lite');\n\nvar toFileUrl = require('./jsdom/utils').toFileUrl;\nvar defineGetter = require('./jsdom/utils').defineGetter;\nvar defineSetter = require('./jsdom/utils').defineSetter;\nvar style = require('./jsdom/level2/style');\nvar features = require('./jsdom/browser/documentfeatures');\nvar dom = exports.dom = require('./jsdom/level3/index').dom;\nvar createWindow = exports.createWindow = require('./jsdom/browser/index').createWindow;\n\nexports.defaultLevel = dom.level3.html;\nexports.browserAugmentation = require('./jsdom/browser/index').browserAugmentation;\nexports.windowAugmentation = require('./jsdom/browser/index').windowAugmentation;\n\n// Proxy feature functions to features module.\n['availableDocumentFeatures',\n  'defaultDocumentFeatures',\n  'applyDocumentFeatures'\n].forEach(function(propName) {\n  defineGetter(exports, propName, function() {\n    return features[propName];\n  });\n  defineSetter(exports, propName, function(val) {\n    return features[propName] = val;\n  });\n});\n\nexports.debugMode = false;\n\ndefineGetter(exports, 'version', function() {\n  return pkg.version;\n});\n\nexports.level = function(level, feature) {\n  if (!feature) {\n    feature = 'core';\n  }\n\n  return require('./jsdom/level' + level + '/' + feature).dom['level' + level][feature];\n};\n\nexports.jsdom = function(html, level, options) {\n\n  options = options || {};\n  if (typeof level == 'string') {\n    level = exports.level(level, 'html');\n  } else {\n    level = level || exports.defaultLevel;\n  }\n\n  if (!options.url) {\n    options.url = (module.parent.id === 'jsdom') ?\n      module.parent.parent.filename :\n      module.parent.filename;\n    options.url = options.url.replace(/\\\\/g, '/');\n    if (options.url[0] !== '/') {\n      options.url = '/' + options.url;\n    }\n    options.url = 'file://' + options.url;\n  }\n\n  var browser = exports.browserAugmentation(level, options),\n    doc = (browser.HTMLDocument) ?\n    new browser.HTMLDocument(options) :\n    new browser.Document(options);\n\n  require('./jsdom/selectors/index').applyQuerySelectorPrototype(level);\n\n  features.applyDocumentFeatures(doc, options.features);\n\n  if (typeof html === 'undefined' || html === null) {\n    doc.write('<html><head></head><body></body></html>');\n  } else {\n    doc.write(html + '');\n  }\n\n  if (doc.close && !options.deferClose) {\n    doc.close();\n  }\n\n  // Kept for backwards-compatibility. The window is lazily created when\n  // document.parentWindow or document.defaultView is accessed.\n  doc.createWindow = function() {\n    // Remove ourself\n    if (doc.createWindow) {\n      delete doc.createWindow;\n    }\n    return doc.parentWindow;\n  };\n\n  return doc;\n};\n\nexports.html = function(html, level, options) {\n  html += '';\n\n  // TODO: cache a regex and use it here instead\n  //       or make the parser handle it\n  var htmlLowered = html.toLowerCase();\n\n  // body\n  if (!~htmlLowered.indexOf('<body')) {\n    html = '<body>' + html + '</body>';\n  }\n\n  // html\n  if (!~htmlLowered.indexOf('<html')) {\n    html = '<html>' + html + '</html>';\n  }\n  return exports.jsdom(html, level, options);\n};\n\nexports.jQueryify = exports.jsdom.jQueryify = function(window /* path [optional], callback */ ) {\n\n  if (!window || !window.document) {\n    return;\n  }\n\n  var args = Array.prototype.slice.call(arguments),\n    callback = (typeof(args[args.length - 1]) === 'function') && args.pop(),\n    path,\n    jQueryTag = window.document.createElement('script');\n  jQueryTag.className = 'jsdom';\n\n  if (args.length > 1 && typeof(args[1] === 'string')) {\n    path = args[1];\n  }\n\n  var features = window.document.implementation._features;\n\n  window.document.implementation.addFeature('FetchExternalResources', ['script']);\n  window.document.implementation.addFeature('ProcessExternalResources', ['script']);\n  window.document.implementation.addFeature('MutationEvents', ['2.0']);\n  jQueryTag.src = path || 'http://code.jquery.com/jquery-latest.js';\n  window.document.body.appendChild(jQueryTag);\n\n  jQueryTag.onload = function() {\n    if (callback) {\n      callback(window, window.jQuery);\n    }\n\n    window.document.implementation._features = features;\n  };\n\n  return window;\n};\n\n\nexports.env = exports.jsdom.env = function() {\n  var config = getConfigFromArguments(arguments);\n  var callback = config.done;\n\n  if (config.file) {\n    fs.readFile(config.file, 'utf-8', function(err, text) {\n      if (err) {\n        return callback(err);\n      }\n\n      config.html = text;\n      processHTML(config);\n    });\n  } else if (config.html) {\n    processHTML(config);\n  } else if (config.url) {\n    handleUrl(config);\n  } else if (config.somethingToAutodetect) {\n    var url = URL.parse(config.somethingToAutodetect);\n    if (url.protocol && url.hostname) {\n      config.url = config.somethingToAutodetect;\n      handleUrl(config.somethingToAutodetect);\n    } else {\n      fs.readFile(config.somethingToAutodetect, 'utf-8', function(err, text) {\n        if (err) {\n          if (err.code === 'ENOENT' || err.code === 'ENAMETOOLONG') {\n            config.html = config.somethingToAutodetect;\n            processHTML(config);\n          } else {\n            callback(err);\n          }\n        } else {\n          config.html = text;\n          config.url = toFileUrl(config.somethingToAutodetect);\n          processHTML(config);\n        }\n      });\n    }\n  }\n\n  function handleUrl() {\n    var options = {\n      uri: config.url,\n      encoding: null,\n      headers: config.headers || {},\n      proxy: config.proxy || null,\n      jar: config.jar !== undefined ? config.jar : true\n    };\n\n    request(options, function(err, res, responseText) {\n      if (err) {\n        return callback(err);\n      }\n      var charset;\n      var matched = res.headers['content-type'].match(/charset=(.+)/);\n      if (matched && matched[1]) {\n        charset = matched[1].replace(/\\-/g, '');\n      }\n      if (!charset) {\n        var matched = (responseText + '').match(/<meta [^>]+charset=([a-z0-9\\-]+).*>/);\n        if (matched && matched[1]) {\n          charset = matched[1].replace(/\\-/g, '');\n        }\n      }\n      charset = charset || 'utf8';\n      responseText = iconv.decode(responseText, charset);\n      // The use of `res.request.uri.href` ensures that `window.location.href`\n      // is updated when `request` follows redirects.\n      config.html = responseText;\n      config.url = res.request.uri.href;\n      processHTML(config);\n    });\n  }\n};\n\nfunction processHTML(config) {\n  var callback = config.done;\n  var options = {\n    features: config.features,\n    url: config.url,\n    parser: config.parser\n  };\n\n  if (config.document) {\n    options.referrer = config.document.referrer;\n    options.cookie = config.document.cookie;\n    options.cookieDomain = config.document.cookieDomain;\n  }\n\n  var window = exports.html(config.html, null, options).createWindow();\n  var features = JSON.parse(JSON.stringify(window.document.implementation._features));\n\n  var docsLoaded = 0;\n  var totalDocs = config.scripts.length + config.src.length;\n  var readyState = null;\n  var errors = [];\n\n  if (!window || !window.document) {\n    return callback(new Error('JSDOM: a window object could not be created.'));\n  }\n\n  window.document.implementation.addFeature('FetchExternalResources', ['script']);\n  window.document.implementation.addFeature('ProcessExternalResources', ['script']);\n  window.document.implementation.addFeature('MutationEvents', ['2.0']);\n\n  function scriptComplete() {\n    docsLoaded++;\n\n    if (docsLoaded >= totalDocs) {\n      window.document.implementation._features = features;\n\n      errors = errors.concat(window.document.errors || []);\n      if (errors.length === 0) {\n        errors = null;\n      }\n\n      process.nextTick(function() {\n        callback(errors, window);\n      });\n    }\n  }\n\n  function handleScriptError(e) {\n    if (!errors) {\n      errors = [];\n    }\n    errors.push(e.error || e.message);\n\n    // nextTick so that an exception within scriptComplete won't cause\n    // another script onerror (which would be an infinite loop)\n    process.nextTick(scriptComplete);\n  }\n\n  if (config.scripts.length > 0 || config.src.length > 0) {\n    config.scripts.forEach(function(scriptSrc) {\n      var script = window.document.createElement('script');\n      script.className = 'jsdom';\n      script.onload = scriptComplete;\n      script.onerror = handleScriptError;\n      script.src = scriptSrc;\n\n      try {\n        // protect against invalid dom\n        // ex: http://www.google.com/foo#bar\n        window.document.documentElement.appendChild(script);\n      } catch (e) {\n        handleScriptError(e);\n      }\n    });\n\n    config.src.forEach(function(scriptText) {\n      var script = window.document.createElement('script');\n      script.onload = scriptComplete;\n      script.onerror = handleScriptError;\n      script.text = scriptText;\n\n      window.document.documentElement.appendChild(script);\n      window.document.documentElement.removeChild(script);\n    });\n  } else {\n    scriptComplete();\n  }\n}\n\nfunction getConfigFromArguments(args, callback) {\n  var config = {};\n  if (typeof args[0] === 'object') {\n    var configToClone = args[0];\n    Object.keys(configToClone).forEach(function(key) {\n      config[key] = configToClone[key];\n    });\n  } else {\n    var stringToAutodetect = null;\n\n    Array.prototype.forEach.call(args, function(arg) {\n      switch (typeof arg) {\n        case 'string':\n          config.somethingToAutodetect = arg;\n          break;\n        case 'function':\n          config.done = arg;\n          break;\n        case 'object':\n          if (Array.isArray(arg)) {\n            config.scripts = arg;\n          } else {\n            extend(config, arg);\n          }\n          break;\n      }\n    });\n  }\n\n  if (!config.done) {\n    throw new Error('Must pass a \"done\" option or a callback to jsdom.env.');\n  }\n\n  if (!config.somethingToAutodetect && !config.html && !config.file && !config.url) {\n    throw new Error('Must pass a \"html\", \"file\", or \"url\" option, or a string, to jsdom.env');\n  }\n\n  config.scripts = ensureArray(config.scripts);\n  config.src = ensureArray(config.src);\n\n  config.features = config.features || {\n    FetchExternalResources: false,\n    ProcessExternalResources: false,\n    SkipExternalResources: false\n  };\n\n  if (!config.url && config.file) {\n    config.url = toFileUrl(config.file);\n  }\n\n  return config;\n}\n\nfunction ensureArray(value) {\n  var array = value || [];\n  if (typeof array === 'string') {\n    array = [array];\n  }\n  return array;\n}\n\nfunction extend(config, overrides) {\n  Object.keys(overrides).forEach(function(key) {\n    config[key] = overrides[key];\n  });\n}","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/utils.js":"var path = require('path');\n\n/**\n * Intercepts a method by replacing the prototype's implementation\n * with a wrapper that invokes the given interceptor instead.\n *\n *     utils.intercept(core.Element, 'inserBefore',\n *       function(_super, args, newChild, refChild) {\n *         console.log('insertBefore', newChild, refChild);\n *         return _super.apply(this, args);\n *       }\n *     );\n */\nexports.intercept = function(clazz, method, interceptor) {\n  var proto = clazz.prototype,\n      _super = proto[method],\n      unwrapArgs = interceptor.length > 2;\n\n  proto[method] = function() {\n    if (unwrapArgs) {\n      var args = Array.prototype.slice.call(arguments);\n      args.unshift(_super, arguments);\n      return interceptor.apply(this, args);\n    }\n    else {\n      return interceptor.call(this, _super, arguments);\n    }\n  };\n};\n\nexports.toFileUrl = function (fileName) {\n  // Beyond just the `path.resolve`, this is mostly for the benefit of Windows,\n  // where we need to convert '\\' to '/' and add an extra '/' prefix before the\n  // drive letter.\n  var pathname = path.resolve(process.cwd(), fileName).replace(/\\\\/g, '/');\n  if (pathname[0] !== '/') {\n    pathname = '/' + pathname;\n  }\n\n  return 'file://' + pathname;\n};\n\n/**\n * Define a setter on an object\n *\n * This method replaces any existing setter but leaves getters in place.\n *\n * - `object` {Object} the object to define the setter on\n * - `property` {String} the name of the setter\n * - `setterFn` {Function} the setter\n */\nexports.defineSetter = function defineSetter(object, property, setterFn) {\n  var descriptor = Object.getOwnPropertyDescriptor(object, property) || {\n    configurable: true,\n    enumerable: true\n  };\n\n  descriptor.set = setterFn;\n\n  Object.defineProperty(object, property, descriptor);\n};\n\n/**\n * Define a getter on an object\n *\n * This method replaces any existing getter but leaves setters in place.\n *\n * - `object` {Object} the object to define the getter on\n * - `property` {String} the name of the getter\n * - `getterFn` {Function} the getter\n */\nexports.defineGetter = function defineGetter(object, property, getterFn) {\n  var descriptor = Object.getOwnPropertyDescriptor(object, property) || {\n    configurable: true,\n    enumerable: true\n  };\n\n  descriptor.get = getterFn;\n\n  Object.defineProperty(object, property, descriptor);\n};\n\n/**\n * Create an object with the given prototype\n *\n * Optionally augment the created object.\n *\n * - `prototyp` {Object} the created object's prototype\n * - `[properties]` {Object} properties to attach to the created object\n */\nexports.createFrom = function createFrom(prototype, properties) {\n  properties = properties || {};\n\n  var descriptors = {};\n  Object.getOwnPropertyNames(properties).forEach(function (name) {\n    descriptors[name] = Object.getOwnPropertyDescriptor(properties, name);\n  });\n\n  return Object.create(prototype, descriptors);\n};\n\n/**\n * Create an inheritance relationship between two classes\n *\n * Optionally augment the inherited prototype.\n *\n * - `Superclass` {Function} the inherited class\n * - `Subclass` {Function} the inheriting class\n * - `[properties]` {Object} properties to attach to the inherited prototype\n */\nexports.inheritFrom = function inheritFrom(Superclass, Subclass, properties) {\n  properties = properties || {};\n\n  Object.defineProperty(properties, 'constructor', {\n    value: Subclass,\n    writable: true,\n    configurable: true\n  });\n\n  Subclass.prototype = exports.createFrom(Superclass.prototype, properties);\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level2/style.js":"var core = require(\"./core\").dom.level2.core,\n    html = require(\"./html\").dom.level2.html,\n    utils = require(\"../utils\"),\n    defineGetter = utils.defineGetter,\n    defineSetter = utils.defineSetter,\n    inheritFrom = utils.inheritFrom,\n    cssom = require(\"cssom\"),\n    cssstyle = require(\"cssstyle\"),\n    assert = require('assert');\n\n// What works now:\n// - Accessing the rules defined in individual stylesheets\n// - Modifications to style content attribute are reflected in style property\n// - Modifications to style property are reflected in style content attribute\n// TODO\n// - Modifications to style element's textContent are reflected in sheet property.\n// - Modifications to style element's sheet property are reflected in textContent.\n// - Modifications to link.href property are reflected in sheet property.\n// - Less-used features of link: disabled\n// - Less-used features of style: disabled, scoped, title\n// - CSSOM-View\n//   - getComputedStyle(): requires default stylesheet, cascading, inheritance,\n//     filtering by @media (screen? print?), layout for widths/heights\n// - Load events are not in the specs, but apparently some browsers\n//   implement something. Should onload only fire after all @imports have been\n//   loaded, or only the primary sheet?\n\ncore.StyleSheet = cssom.StyleSheet;\ncore.MediaList = cssom.MediaList;\ncore.CSSStyleSheet = cssom.CSSStyleSheet;\ncore.CSSRule = cssom.CSSRule;\ncore.CSSStyleRule = cssom.CSSStyleRule;\ncore.CSSMediaRule = cssom.CSSMediaRule;\ncore.CSSImportRule = cssom.CSSImportRule;\ncore.CSSStyleDeclaration = cssstyle.CSSStyleDeclaration;\n\n// Relavant specs\n// http://www.w3.org/TR/DOM-Level-2-Style (2000)\n// http://www.w3.org/TR/cssom-view/ (2008)\n// http://dev.w3.org/csswg/cssom/ (2010) Meant to replace DOM Level 2 Style\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/ HTML5, of course\n// http://dev.w3.org/csswg/css-style-attr/  not sure what's new here\n\n// Objects that aren't in cssom library but should be:\n//   CSSRuleList  (cssom just uses array)\n//   CSSFontFaceRule\n//   CSSPageRule\n\n// These rules don't really make sense to implement, so CSSOM draft makes them\n// obsolete.\n//   CSSCharsetRule\n//   CSSUnknownRule\n\n// These objects are considered obsolete by CSSOM draft, although modern\n// browsers implement them.\n//   CSSValue\n//   CSSPrimitiveValue\n//   CSSValueList\n//   RGBColor\n//   Rect\n//   Counter\n\n// StyleSheetList -\n// http://www.w3.org/TR/DOM-Level-2-Style/stylesheets.html#StyleSheets-StyleSheetList\n// added a push method to help manage the length\ncore.StyleSheetList = function() {\n  this._length = 0;\n};\ncore.StyleSheetList.prototype = {\n  item: function (i) {\n    return this[i];\n  },\n  push: function (sheet) {\n    this[this._length] = sheet;\n    this._length++;\n  },\n  get length() {\n    return this._length;\n  }\n};\n\ndefineGetter(core.Document.prototype, 'styleSheets', function() {\n  if (!this._styleSheets) {\n    this._styleSheets = new core.StyleSheetList();\n  }\n  // TODO: each style and link element should register its sheet on creation\n  // and remove it on removal.\n  return this._styleSheets;\n});\n\n\n/**\n * @this {html.HTMLLinkElement|html.HTMLStyleElement}\n * @param {string} url\n * @param {cssom.CSSStyleSheet} sheet\n * @see http://dev.w3.org/csswg/cssom/#requirements-on-user-agents-implementing0\n */\nfunction fetchStylesheet(url, sheet) {\n  html.resourceLoader.load(this, url, function(data, filename) {\n    // TODO: abort if the content-type is not text/css, and the document is\n    // in strict mode\n    sheet.href = html.resourceLoader.resolve(this.ownerDocument, url);\n    evaluateStylesheet.call(this, data, sheet, url);\n  });\n}\n/**\n * @this {html.HTMLLinkElement|html.HTMLStyleElement}\n * @param {string} data\n * @param {cssom.CSSStyleSheet} sheet\n * @param {string} baseUrl\n */\nfunction evaluateStylesheet(data, sheet, baseUrl) {\n  // this is the element\n  var newStyleSheet = cssom.parse(data);\n  var spliceArgs = newStyleSheet.cssRules;\n  spliceArgs.unshift(0, sheet.cssRules.length);\n  Array.prototype.splice.apply(sheet.cssRules, spliceArgs);\n  scanForImportRules.call(this, sheet.cssRules, baseUrl);\n  this.ownerDocument.styleSheets.push(sheet);\n}\n/**\n * @this {html.HTMLLinkElement|html.HTMLStyleElement}\n * @param {cssom.CSSStyleSheet} sheet\n * @param {string} baseUrl\n */\nfunction scanForImportRules(cssRules, baseUrl) {\n  if (!cssRules) return;\n  for (var i = 0; i < cssRules.length; ++i) {\n    if (cssRules[i].cssRules) {\n      // @media rule: keep searching inside it.\n      scanForImportRules.call(this, cssRules[i].cssRules, baseUrl);\n    } else if (cssRules[i].href) {\n      // @import rule: fetch the resource and evaluate it.\n      // See http://dev.w3.org/csswg/cssom/#css-import-rule\n      //     If loading of the style sheet fails its cssRules list is simply\n      //     empty. I.e. an @import rule always has an associated style sheet.\n      fetchStylesheet.call(this, cssRules[i].href, this.sheet);\n    }\n  }\n}\n\n/**\n * @param {string} data\n * @param {cssstyle.CSSStyleDeclaration} style\n */\nfunction evaluateStyleAttribute(data) {\n  // this is the element.\n\n}\n\n/**\n * Subclass of core.Attr that reflects the current cssText.\n */\nfunction StyleAttr(node, value) {\n  this._node = node;\n  core.Attr.call(this, node.ownerDocument, 'style');\n  if (!this._node._ignoreValueOfStyleAttr) {\n    this.nodeValue = value;\n  }\n}\ninheritFrom(core.Attr, StyleAttr, {\n  get nodeValue() {\n    if (typeof this._node._style === 'string') {\n      return this._node._style;\n    } else {\n      return this._node.style.cssText;\n    }\n  },\n  set nodeValue(value) {\n    this._node._style = value;\n  }\n});\n\n/**\n * Overwrite core.AttrNodeMap#setNamedItem to create a StyleAttr instance\n * instead of a core.Attr if the name equals 'style'.\n */\nutils.intercept(core.AttributeList, '$setNode', function(_super, args, attr) {\n  if (attr.name == 'style') {\n    attr = new StyleAttr(this._parentNode, attr.nodeValue);\n  }\n  return _super.call(this, attr);\n});\n\n/**\n * Lazily create a CSSStyleDeclaration.\n */\ndefineGetter(html.HTMLElement.prototype, 'style', function() {\n  if (typeof this._style === 'string') {\n    // currently, cssom's parse doesn't really work if you pass in\n    // {state: 'name'}, so instead we just build a dummy sheet.\n    var styleSheet = cssom.parse('dummy{' + this._style + '}');\n    this._style = new cssstyle.CSSStyleDeclaration();\n    if (styleSheet.cssRules.length > 0 && styleSheet.cssRules[0].style) {\n      var newStyle = styleSheet.cssRules[0].style;\n      for (var i = 0; i < newStyle.length; ++i) {\n        var prop = newStyle[i];\n        this._style.setProperty(\n            prop,\n            newStyle.getPropertyValue(prop),\n            newStyle.getPropertyPriority(prop));\n      }\n    }\n  }\n  if (!this._style) {\n    this._style = new cssstyle.CSSStyleDeclaration();\n\n  }\n  if (!this.getAttributeNode('style')) {\n    // Tell the StyleAttr constructor to not overwrite this._style\n    this._ignoreValueOfStyleAttr = true;\n    this.setAttribute('style');\n    this._ignoreValueOfStyleAttr = false;\n  }\n  return this._style;\n});\n\nassert.equal(undefined, html.HTMLLinkElement._init);\nhtml.HTMLLinkElement._init = function() {\n  this.addEventListener('DOMNodeInsertedIntoDocument', function() {\n    if (!/(?:[ \\t\\n\\r\\f]|^)stylesheet(?:[ \\t\\n\\r\\f]|$)/i.test(this.rel)) {\n      // rel is a space-separated list of tokens, and the original rel types\n      // are case-insensitive.\n      return;\n    }\n    if (this.href) {\n      fetchStylesheet.call(this, this.href, this.sheet);\n    }\n  });\n  this.addEventListener('DOMNodeRemovedFromDocument', function() {\n  });\n};\n/**\n * @this {HTMLStyleElement|HTMLLinkElement}\n */\nvar getOrCreateSheet = function() {\n  if (!this._cssStyleSheet) {\n    this._cssStyleSheet = new cssom.CSSStyleSheet();\n  }\n  return this._cssStyleSheet;\n};\ndefineGetter(html.HTMLLinkElement.prototype, 'sheet', getOrCreateSheet);\n\nassert.equal(undefined, html.HTMLStyleElement._init);\nhtml.HTMLStyleElement._init = function() {\n  //console.log('init style')\n  this.addEventListener('DOMNodeInsertedIntoDocument', function() {\n    //console.log('style inserted')\n    //console.log('sheet: ', this.sheet);\n    if (this.type && this.type !== 'text/css') {\n      //console.log('bad type: ' + this.type)\n      return;\n    }\n    var content = '';\n    Array.prototype.forEach.call(this.childNodes, function (child) {\n      if (child.nodeType === child.TEXT_NODE) { // text node\n        content += child.nodeValue;\n      }\n    });\n    evaluateStylesheet.call(this, content, this.sheet, this._ownerDocument.URL);\n  });\n};\ndefineGetter(html.HTMLStyleElement.prototype, 'sheet', getOrCreateSheet);\n\nexports.dom = {\n  level2 : {\n    html : html,\n    core : core\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level2/core.js":"var core                     = require(\"../level1/core\").dom.level1.core;\nvar defineGetter = require('../utils').defineGetter;\nvar defineSetter = require('../utils').defineSetter;\n\n// modify cloned instance for more info check: https://github.com/tmpvar/jsdom/issues/325\ncore = Object.create(core);\n\nvar INVALID_STATE_ERR        = core.INVALID_STATE_ERR        = 11,\n    SYNTAX_ERR               = core.SYNTAX_ERR               = 12,\n    INVALID_MODIFICATION_ERR = core.INVALID_MODIFICATION_ERR = 13,\n    NAMESPACE_ERR            = core.NAMESPACE_ERR            = 14,\n    INVALID_ACCESS_ERR       = core.INVALID_ACCESS_ERR       = 15,\n    ns = {\n      validate : function(ns, URI) {\n        if (!ns) {\n          throw new core.DOMException(core.INVALID_CHARACTER_ERR, \"namespace is undefined\");\n        }\n\n        if(ns.match(/[^0-9a-z\\.:\\-_]/i) !== null) {\n          throw new core.DOMException(core.INVALID_CHARACTER_ERR, ns);\n        }\n\n        var msg = false, parts = ns.split(':');\n        if (ns === 'xmlns'                          &&\n            URI !== \"http://www.w3.org/2000/xmlns/\")\n        {\n          msg = \"localName is 'xmlns' but the namespaceURI is invalid\";\n\n        } else if (ns === \"xml\"                                   &&\n                   URI !== \"http://www.w3.org/XML/1998/namespace\")\n        {\n          msg = \"localName is 'xml' but the namespaceURI is invalid\";\n\n        } else if (ns[ns.length-1] === ':') {\n          msg = \"Namespace seperator found with no localName\";\n\n        } else if (ns[0] === ':') {\n          msg = \"Namespace seperator found, without a prefix\";\n\n        } else if (parts.length > 2) {\n          msg = \"Too many namespace seperators\";\n\n        }\n\n        if (msg) {\n          throw new core.DOMException(NAMESPACE_ERR, msg + \" (\" + ns + \"@\" + URI + \")\");\n        }\n      }\n    };\n\ncore.exceptionMessages['NAMESPACE_ERR'] = \"Invalid namespace\";\n\ncore.DOMImplementation.prototype.createDocumentType = function(/* String */ qualifiedName,\n                                                               /* String */ publicId,\n                                                               /* String */ systemId)\n{\n  ns.validate(qualifiedName);\n  var doctype = new core.DocumentType(null, qualifiedName);\n  doctype._publicId = publicId ? publicId : '';\n  doctype._systemId = systemId ? systemId : '';\n  return doctype;\n};\n\n/**\n  Creates an XML Document object of the specified type with its document element.\n  HTML-only DOM implementations do not need to implement this method.\n*/\ncore.DOMImplementation.prototype.createDocument = function(/* String */       namespaceURI,\n                                                           /* String */       qualifiedName,\n                                                           /* DocumentType */ doctype)\n{\n  if (qualifiedName || namespaceURI) {\n    ns.validate(qualifiedName, namespaceURI);\n  }\n\n  if (doctype && doctype._ownerDocument !== null) {\n    throw new core.DOMException(core.WRONG_DOCUMENT_ERR);\n  }\n\n  if (qualifiedName && qualifiedName.indexOf(':') > -1 && !namespaceURI) {\n    throw new core.DOMException(NAMESPACE_ERR);\n  }\n\n  var document = new core.Document();\n\n  if (doctype) {\n    document.doctype = doctype;\n    doctype._ownerDocument = document;\n    document.appendChild(doctype);\n  } else {\n    document.doctype = null;\n  }\n\n  if (doctype && !doctype.entities) {\n    doctype.entities = new core.EntityNodeMap();\n  }\n\n  document._ownerDocument = document;\n\n  if (qualifiedName) {\n    var docElement = document.createElementNS(namespaceURI, qualifiedName);\n    document.appendChild(docElement);\n  }\n\n  return document;\n};\n\ndefineGetter(core.Node.prototype, \"ownerDocument\", function() {\n  return this._ownerDocument || null;\n});\n\ncore.Node.prototype.isSupported = function(/* string */ feature,\n                                           /* string */ version)\n{\n  return this._ownerDocument.implementation.hasFeature(feature, version);\n};\n\ncore.Node.prototype._namespaceURI = null;\ndefineGetter(core.Node.prototype, \"namespaceURI\", function() {\n  return this._namespaceURI || null;\n});\n\ndefineSetter(core.Node.prototype, \"namespaceURI\", function(value) {\n  this._namespaceURI = value;\n});\n\ndefineGetter(core.Node.prototype, \"prefix\", function() {\n  return this._prefix || null;\n});\n\ndefineSetter(core.Node.prototype, \"prefix\", function(value) {\n\n  if (this.readonly) {\n    throw new core.DOMException(core.NO_MODIFICATION_ALLOWED_ERR);\n  }\n\n  ns.validate(value, this._namespaceURI);\n\n  if ((this._created && !this._namespaceURI)  ||\n      this._prefix === \"xmlns\"                ||\n      (!this._prefix && this._created))\n  {\n    throw new core.DOMException(core.NAMESPACE_ERR);\n  }\n\n  if (this._localName) {\n    this._nodeName = value + ':' + this._localName;\n  }\n\n  this._prefix = value;\n});\n\ndefineGetter(core.Node.prototype, \"localName\", function() {\n  return this._localName || null;\n});\n\n/* return boolean */\ncore.Node.prototype.hasAttributes = function() {\n  return (this.nodeType === this.ELEMENT_NODE &&\n          this._attributes                    &&\n          this._attributes.length > 0);\n};\n\ncore.NamedNodeMap.prototype.getNamedItemNS = function(/* string */ namespaceURI,\n                                                      /* string */ localName)\n{\n  if (this._nsStore[namespaceURI] && this._nsStore[namespaceURI][localName]) {\n    return this._nsStore[namespaceURI][localName];\n  }\n  return null;\n};\n\ncore.NamedNodeMap.prototype.setNamedItemNS = function(/* Node */ arg)\n{\n  if (this._readonly) {\n    throw new core.DOMException(core.NO_MODIFICATION_ALLOWED_ERR);\n  }\n\n  var owner = this._ownerDocument;\n  if (this._parentNode &&\n      this._parentNode._parentNode &&\n      this._parentNode._parentNode.nodeType === owner.ENTITY_NODE)\n  {\n    throw new core.DOMException(core.NO_MODIFICATION_ALLOWED_ERR);\n  }\n\n  if (this._ownerDocument !== arg.ownerDocument) {\n    throw new core.DOMException(core.WRONG_DOCUMENT_ERR);\n  }\n\n  if (arg._ownerElement) {\n    throw new core.DOMException(core.INUSE_ATTRIBUTE_ERR);\n  }\n\n  // readonly\n  if (this._readonly === true) {\n    throw new core.DOMException(core.NO_MODIFICATION_ALLOWED_ERR);\n  }\n\n\n  if (!this._nsStore[arg.namespaceURI]) {\n    this._nsStore[arg.namespaceURI] = {};\n  }\n  var existing = null;\n  if (this._nsStore[arg.namespaceURI][arg.localName]) {\n    var existing = this._nsStore[arg.namespaceURI][arg.localName];\n  }\n\n  this._nsStore[arg.namespaceURI][arg.localName] = arg;\n\n  arg._specified = true;\n  arg._ownerDocument = this._ownerDocument;\n\n  return this.setNamedItem(arg);\n};\n\ncore.NamedNodeMap.prototype.removeNamedItemNS = function(/*string */ namespaceURI,\n                                                         /* string */ localName)\n{\n\n  if (this.readonly) {\n    throw new core.DOMException(core.NO_MODIFICATION_ALLOWED_ERR);\n  }\n\n\n  var parent = this._parentNode,\n      found = null,\n      defaults,\n      clone,\n      defaultEl,\n      defaultAttr;\n\n  if (this._parentNode &&\n      this._parentNode._parentNode &&\n      this._parentNode._parentNode.nodeType === this._ownerDocument.ENTITY_NODE)\n  {\n    throw new core.DOMException(core.NO_MODIFICATION_ALLOWED_ERR);\n  }\n\n  if (this._nsStore[namespaceURI] &&\n      this._nsStore[namespaceURI][localName])\n  {\n    found = this._nsStore[namespaceURI][localName];\n    this.removeNamedItem(found.qualifiedName);\n    delete this._nsStore[namespaceURI][localName];\n  }\n\n  if (!found) {\n    throw new core.DOMException(core.NOT_FOUND_ERR);\n  }\n\n  if (parent.ownerDocument.doctype && parent.ownerDocument.doctype._attributes) {\n    defaults = parent.ownerDocument.doctype._attributes;\n    defaultEl = defaults.getNamedItemNS(parent._namespaceURI, parent._localName);\n  }\n\n  if (defaultEl) {\n    defaultAttr = defaultEl._attributes.getNamedItemNS(namespaceURI, localName);\n\n    if (defaultAttr) {\n      clone = defaultAttr.cloneNode(true);\n      clone._created               = false;\n      clone._namespaceURI          = found._namespaceURI;\n      clone._nodeName              = found.name;\n      clone._localName             = found._localName;\n      clone._prefix                = found._prefix\n      this.setNamedItemNS(clone);\n      clone._created               = true;\n      clone._specified             = false;\n    }\n  }\n\n  return found;\n};\n\ndefineGetter(core.Attr.prototype, \"ownerElement\", function() {\n  return this._ownerElement || null;\n});\n\n\ncore.Node.prototype._prefix = false;\n\ndefineSetter(core.Node.prototype, \"qualifiedName\", function(qualifiedName) {\n  ns.validate(qualifiedName, this._namespaceURI);\n  qualifiedName       = qualifiedName || \"\";\n  this._localName     = qualifiedName.split(\":\")[1] || null;\n  this.prefix         = qualifiedName.split(\":\")[0] || null;\n  this._nodeName = qualifiedName;\n});\n\ndefineGetter(core.Node.prototype, \"qualifiedName\", function() {\n  return this._nodeName;\n});\n\ncore.NamedNodeMap.prototype._map = function(fn) {\n  var ret = [], l = this.length, i = 0, node;\n  for(i; i<l; i++) {\n    node = this.item(i);\n    if (fn && fn(node)) {\n      ret.push(node);\n    }\n  }\n  return ret;\n};\n\ncore.Element.prototype.getAttribute = function(/* string */ name)\n{\n  var attr =  this.getAttributeNode(name);\n  return attr && attr.value;\n};\n\ncore.Element.prototype.getAttributeNode = function(/* string */ name)\n{\n  return this._attributes.$getNoNS(name);\n};\n\ncore.Element.prototype.removeAttribute = function(/* string */ name)\n{\n  return this._attributes.$removeNoNS(name);\n};\n\ncore.Element.prototype.getAttributeNS = function(/* string */ namespaceURI,\n                                                 /* string */ localName)\n{\n  if (namespaceURI === \"\") {\n    namespaceURI = null;\n  }\n\n  var attr =  this._attributes.$getNode(namespaceURI, localName);\n  return attr && attr.value;\n};\n\ncore.Element.prototype.setAttribute = function(/* string */ name,\n                                               /* string */ value)\n{\n  this._attributes.$setNoNS(name, value);\n};\n\ncore.Element.prototype.setAttributeNS = function(/* string */ namespaceURI,\n                                                 /* string */ qualifiedName,\n                                                 /* string */ value)\n{\n  if (namespaceURI === \"\") {\n    namespaceURI = null;\n  }\n\n  var s       = qualifiedName.split(':'),\n      local   = s.pop(),\n      prefix  = s.pop() || null,\n      attr;\n\n  ns.validate(qualifiedName, namespaceURI);\n\n  if (prefix !== null && !namespaceURI) {\n    throw new core.DOMException(core.NAMESPACE_ERR);\n  }\n\n  if (prefix === \"xml\" &&\n      namespaceURI !== \"http://www.w3.org/XML/1998/namespace\") {\n    throw new core.DOMException(core.NAMESPACE_ERR);\n  }\n\n  if (prefix === \"xmlns\" && namespaceURI !== \"http://www.w3.org/2000/xmlns/\") {\n    throw new core.DOMException(core.NAMESPACE_ERR);\n  }\n\n  this._attributes.$set(local, value, qualifiedName, prefix, namespaceURI);\n};\n\ncore.Element.prototype.removeAttributeNS = function(/* string */ namespaceURI,\n                                                    /* string */ localName)\n{\n  if (namespaceURI === \"\") {\n    namespaceURI = null;\n  }\n\n  this._attributes.$remove(namespaceURI, localName);\n};\n\ncore.Element.prototype.getAttributeNodeNS = function(/* string */ namespaceURI,\n                                                     /* string */ localName)\n{\n  if (namespaceURI === \"\") {\n    namespaceURI = null;\n  }\n\n  return this._attributes.$getNode(namespaceURI, localName);\n};\ncore.Element.prototype._created = false;\n\ncore.Element.prototype.setAttributeNodeNS = function(/* Attr */ newAttr)\n{\n  if (newAttr.ownerElement) {\n    throw new core.DOMException(core.INUSE_ATTRIBUTE_ERR);\n  }\n\n  return this._attributes.$setNode(newAttr);\n};\n\ncore.Element.prototype.getElementsByTagNameNS = function(/* String */ namespaceURI,\n                                                         /* String */ localName)\n{\n  var nsPrefixCache = {};\n\n  function filterByTagName(child) {\n    if (child.nodeType && child.nodeType === this.ENTITY_REFERENCE_NODE) {\n      child = child._entity;\n    }\n\n    var localMatch = child.localName === localName,\n        nsMatch    = child.namespaceURI === namespaceURI;\n\n    if ((localMatch || localName === \"*\") &&\n        (nsMatch || namespaceURI === \"*\"))\n    {\n      if (child.nodeType === child.ELEMENT_NODE) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  return new core.NodeList(this.ownerDocument || this,\n                           core.mapper(this, filterByTagName));\n};\n\ncore.Element.prototype.hasAttribute = function(/* string */name)\n{\n  if (!this._attributes) {\n    return false;\n  }\n\n  return !!this._attributes.$getNoNS(name);\n};\n\ncore.Element.prototype.hasAttributeNS = function(/* string */namespaceURI,\n                                                 /* string */localName)\n{\n  if (namespaceURI === \"\") {\n    namespaceURI = null;\n  }\n\n  return (this._attributes.getNamedItemNS(namespaceURI, localName) ||\n          this.hasAttribute(localName));\n};\n\ndefineGetter(core.DocumentType.prototype, \"publicId\", function() {\n  return this._publicId || \"\";\n});\n\ndefineGetter(core.DocumentType.prototype, \"systemId\", function() {\n  return this._systemId || \"\";\n});\n\ndefineGetter(core.DocumentType.prototype, \"internalSubset\", function() {\n  return this._internalSubset || null;\n});\n\ncore.Document.prototype.importNode = function(/* Node */ importedNode,\n                                              /* bool */ deep)\n{\n  if (importedNode && importedNode.nodeType) {\n    if (importedNode.nodeType === this.DOCUMENT_NODE ||\n        importedNode.nodeType === this.DOCUMENT_TYPE_NODE) {\n      throw new core.DOMException(core.NOT_SUPPORTED_ERR);\n    }\n  }\n\n  var self = this,\n      newNode = importedNode.cloneNode(deep, function(a, b) {\n        b._namespaceURI  = a._namespaceURI;\n        b._nodeName      = a._nodeName;\n        b._localName     = a._localName;\n      }),\n      defaults = false,\n      defaultEl;\n\n  if (this.doctype && this.doctype._attributes) {\n    defaults = this.doctype._attributes;\n  }\n\n  function lastChance(el) {\n    var attr, defaultEl, i, len;\n\n    el._ownerDocument = self;\n    if (el.id) {\n      if (!self._ids) {self._ids = {};}\n      if (!self._ids[el.id]) {self._ids[el.id] = [];}\n      self._ids[el.id].push(el);\n    }\n    if (el._attributes) {\n      var drop = [];\n      el._attributes._ownerDocument = self;\n      for (i=0,len=el._attributes.length; i < len; i++) {\n        attr = el._attributes[i];\n        // Attributes nodes that were expressing default values in the\n        // original document must not be copied over. Record them.\n        if (!attr._specified) {\n          drop.push(attr);\n          continue;\n        }\n\n        attr._ownerDocument = self;\n      }\n\n      // Remove obsolete default nodes.\n      for(i = 0; i < drop.length; ++i) {\n        el._attributes.$removeNode(drop[i]);\n      }\n\n    }\n    if (defaults) {\n\n      defaultEl = defaults.getNamedItemNS(el._namespaceURI,\n                                          el._localName);\n\n      // TODO: This could use some love\n      if (defaultEl) {\n        for(i = 0; i < defaultEl._attributes.length; ++i) {\n          var defaultAttr = defaultEl._attributes[i];\n          if (!el.hasAttributeNS(defaultAttr.namespaceURL,\n                                 defaultAttr.localName))\n          {\n            var clone = defaultAttr.cloneNode(true);\n            clone._namespaceURI = defaultAttr._namespaceURI;\n            clone._prefix       = defaultAttr._prefix;\n            clone._localName    = defaultAttr._localName;\n            el.setAttributeNodeNS(clone);\n            clone._specified = false;\n          }\n        }\n      }\n    }\n\n  }\n\n  if (deep) {\n    core.visitTree(newNode, lastChance);\n  }\n  else {\n    lastChance(newNode);\n  }\n\n  if (newNode.nodeType == newNode.ATTRIBUTE_NODE) {\n    newNode._specified = true;\n  }\n\n  return newNode;\n};\n\ncore.Document.prototype.createElementNS = function(/* string */ namespaceURI,\n                                                   /* string */ qualifiedName)\n{\n  var parts   = qualifiedName.split(':'),\n      element, prefix;\n\n  if (parts.length > 1 && !namespaceURI) {\n    throw new core.DOMException(core.NAMESPACE_ERR);\n  }\n\n  ns.validate(qualifiedName, namespaceURI);\n  element = this.createElement(qualifiedName),\n\n  element._created = false;\n\n  element._namespaceURI = namespaceURI;\n  element._nodeName = qualifiedName;\n  element._localName = parts.pop();\n\n  if (parts.length > 0) {\n    prefix = parts.pop();\n    element.prefix = prefix;\n  }\n\n  element._created = true;\n  return element;\n};\n\ncore.Document.prototype.createAttributeNS = function(/* string */ namespaceURI,\n                                                     /* string */ qualifiedName)\n{\n  var attribute, parts = qualifiedName.split(':');\n\n  if (parts.length > 1 && !namespaceURI) {\n    throw new core.DOMException(core.NAMESPACE_ERR,\n                                \"Prefix specified without namespaceURI (\" + qualifiedName + \")\");\n  }\n\n\n  ns.validate(qualifiedName, namespaceURI);\n\n  attribute = this.createAttribute(qualifiedName);\n  attribute.namespaceURI = namespaceURI;\n  attribute.qualifiedName = qualifiedName;\n\n  attribute._localName = parts.pop();\n  attribute._prefix = (parts.length > 0) ? parts.pop() : null;\n  return attribute;\n};\n\ncore.Document.prototype.getElementsByTagNameNS = function(/* String */ namespaceURI,\n                                                          /* String */ localName)\n{\n  return core.Element.prototype.getElementsByTagNameNS.call(this,\n                                                            namespaceURI,\n                                                            localName);\n};\n\ndefineSetter(core.Element.prototype, \"id\", function(id) {\n  this.setAttribute(\"id\", id);\n});\n\ndefineGetter(core.Element.prototype, \"id\", function() {\n  return this.getAttribute(\"id\");\n});\n\ncore.Document.prototype.getElementById = function(id) {\n  // return the first element\n  return (this._ids && this._ids[id] && this._ids[id].length > 0 ? this._ids[id][0] : null);\n};\n\n\nexports.dom =\n{\n  level2 : {\n    core : core\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level1/core.js":"/*\n  ServerJS Javascript DOM Level 1\n*/\nvar inheritFrom = require(\"../utils\").inheritFrom;\n\n// utility functions\nvar attachId = function(id,elm,doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n    doc._ids[id].push(elm);\n  }\n};\nvar detachId = function(id,elm,doc) {\n  var elms, i;\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      elms = doc._ids[id];\n      for (i=0;i<elms.length;i++) {\n        if (elms[i] === elm) {\n          elms.splice(i,1);\n          i--;\n        }\n      }\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n};\n\nvar core = {\n\n  mapper: function(parent, filter, recursive) {\n    return function() {\n      return core.mapDOMNodes(parent, recursive !== false, filter);\n    };\n  },\n\n  // Returns Array\n  mapDOMNodes : function(parent, recursive, callback) {\n    function visit(parent, result) {\n      return Array.prototype.reduce.call(parent.childNodes, reducer, result);\n    }\n\n    function reducer(array, child) {\n      if (callback(child)) {\n        array.push(child);\n      }\n      if (recursive && child._childNodes) {\n        visit(child, array);\n      }\n      return array;\n    }\n\n    return visit(parent, []);\n  },\n\n  visitTree: function(root, callback) {\n    var cur = root; // TODO: Unroll this.\n\n    function visit(el) {\n      if (el) {\n        callback(el);\n        if (el._childNodes) {\n          var i        = 0,\n              children = el._childNodes,\n              l        = children.length;\n\n          for (i; i<l; i++) {\n            visit(children[i]);\n          }\n        }\n      }\n    }\n    visit(root);\n  },\n\n  markTreeReadonly: function(node) {\n    function markLevel(el) {\n      el._readonly = true;\n      // also mark attributes and their children read-only\n      if (el.attributes) {\n        var attributes = el.attributes, l = attributes.length, i=0;\n        attributes._readonly = true;\n\n        for (i; i<l; i++) {\n          core.visitTree(attributes[i], markLevel);\n        }\n      }\n    }\n\n    core.visitTree(node, markLevel);\n  }\n};\n\n// ExceptionCode\nvar INDEX_SIZE_ERR              = core.INDEX_SIZE_ERR              = 1,\n    DOMSTRING_SIZE_ERR          = core.DOMSTRING_SIZE_ERR          = 2,\n    HIERARCHY_REQUEST_ERR       = core.HIERARCHY_REQUEST_ERR       = 3,\n    WRONG_DOCUMENT_ERR          = core.WRONG_DOCUMENT_ERR          = 4,\n    INVALID_CHARACTER_ERR       = core.INVALID_CHARACTER_ERR       = 5,\n    NO_DATA_ALLOWED_ERR         = core.NO_DATA_ALLOWED_ERR         = 6,\n    NO_MODIFICATION_ALLOWED_ERR = core.NO_MODIFICATION_ALLOWED_ERR = 7,\n    NOT_FOUND_ERR               = core.NOT_FOUND_ERR               = 8,\n    NOT_SUPPORTED_ERR           = core.NOT_SUPPORTED_ERR           = 9,\n    INUSE_ATTRIBUTE_ERR         = core.INUSE_ATTRIBUTE_ERR         = 10,\n\n// Node Types\n    ELEMENT_NODE                = 1,\n    ATTRIBUTE_NODE              = 2,\n    TEXT_NODE                   = 3,\n    CDATA_SECTION_NODE          = 4,\n    ENTITY_REFERENCE_NODE       = 5,\n    ENTITY_NODE                 = 6,\n    PROCESSING_INSTRUCTION_NODE = 7,\n    COMMENT_NODE                = 8,\n    DOCUMENT_NODE               = 9,\n    DOCUMENT_TYPE_NODE          = 10,\n    DOCUMENT_FRAGMENT_NODE      = 11,\n    NOTATION_NODE               = 12;\n\nvar messages = core.exceptionMessages = { };\nmessages[INDEX_SIZE_ERR]              = \"Index size error\";\nmessages[DOMSTRING_SIZE_ERR]          = \"DOMString size error\";\nmessages[HIERARCHY_REQUEST_ERR]       = \"Hierarchy request error\";\nmessages[WRONG_DOCUMENT_ERR]          = \"Wrong document\";\nmessages[INVALID_CHARACTER_ERR]       = \"Invalid character\";\nmessages[NO_DATA_ALLOWED_ERR]         = \"No data allowed\";\nmessages[NO_MODIFICATION_ALLOWED_ERR] = \"No modification allowed\";\nmessages[NOT_FOUND_ERR]               = \"Not found\";\nmessages[NOT_SUPPORTED_ERR]           = \"Not supported\";\nmessages[INUSE_ATTRIBUTE_ERR]         = \"Attribute in use\";\n\ncore.DOMException = function(code, message) {\n  this.code = code;\n  Error.call(this, core.exceptionMessages[code]);\n  this.message = core.exceptionMessages[code];\n  if(message) this.message = this.message + \": \" + message;\n  if(Error.captureStackTrace) Error.captureStackTrace(this, core.DOMException);\n};\n\ncore.DOMException.INDEX_SIZE_ERR              = INDEX_SIZE_ERR;\ncore.DOMException.DOMSTRING_SIZE_ERR          = DOMSTRING_SIZE_ERR;\ncore.DOMException.HIERARCHY_REQUEST_ERR       = HIERARCHY_REQUEST_ERR;\ncore.DOMException.WRONG_DOCUMENT_ERR          = WRONG_DOCUMENT_ERR;\ncore.DOMException.INVALID_CHARACTER_ERR       = INVALID_CHARACTER_ERR;\ncore.DOMException.NO_DATA_ALLOWED_ERR         = NO_DATA_ALLOWED_ERR;\ncore.DOMException.NO_MODIFICATION_ALLOWED_ERR = NO_MODIFICATION_ALLOWED_ERR;\ncore.DOMException.NOT_FOUND_ERR               = NOT_FOUND_ERR;\ncore.DOMException.NOT_SUPPORTED_ERR           = NOT_SUPPORTED_ERR;\ncore.DOMException.INUSE_ATTRIBUTE_ERR         = INUSE_ATTRIBUTE_ERR;\n\ninheritFrom(Error, core.DOMException, {\n  INDEX_SIZE_ERR              : INDEX_SIZE_ERR,\n  DOMSTRING_SIZE_ERR          : DOMSTRING_SIZE_ERR,\n  HIERARCHY_REQUEST_ERR       : HIERARCHY_REQUEST_ERR,\n  WRONG_DOCUMENT_ERR          : WRONG_DOCUMENT_ERR,\n  INVALID_CHARACTER_ERR       : INVALID_CHARACTER_ERR,\n  NO_DATA_ALLOWED_ERR         : NO_DATA_ALLOWED_ERR,\n  NO_MODIFICATION_ALLOWED_ERR : NO_MODIFICATION_ALLOWED_ERR,\n  NOT_FOUND_ERR               : NOT_FOUND_ERR,\n  NOT_SUPPORTED_ERR           : NOT_SUPPORTED_ERR,\n  INUSE_ATTRIBUTE_ERR         : INUSE_ATTRIBUTE_ERR\n});\n\ncore.NodeList = function NodeList(element, query) {\n  if (!query) {\n    // Non-live NodeList\n    if (Array.isArray(element)) {\n      Array.prototype.push.apply(this, element);\n    }\n    Object.defineProperties(this, {\n      _length: {value: element ? element.length : 0, writable:true}\n    });\n  } else {\n    Object.defineProperties(this, {\n      _element: {value: element},\n      _query: {value: query},\n      _snapshot: {writable: true},\n      _length: {value: 0, writable: true},\n      _version: {value: -1, writable: true}\n    });\n    this._update();\n  }\n};\n\nfunction lengthFromProperties(arrayLike) {\n  var max = -1;\n  for (var i in arrayLike) {\n    var asNumber = +i;\n    if (!isNaN(asNumber) && asNumber > max) {\n      max = asNumber;\n    }\n  }\n  return max + 1;\n}\ncore.NodeList.prototype = {\n  _update: function() {\n    var i;\n\n    if (!this._element) {\n      this._length = lengthFromProperties(this);\n    } else {\n      if (this._version < this._element._version) {\n        var nodes = this._snapshot = this._query();\n        this._resetTo(nodes);\n        this._version = this._element._version;\n      }\n    }\n  },\n  _resetTo: function(array) {\n    var startingLength = lengthFromProperties(this);\n    for (var i = 0; i < startingLength; ++i) {\n      delete this[i];\n    }\n\n    for (var j = 0; j < array.length; ++j) {\n      this[j] = array[j];\n    }\n    this._length = array.length;\n  },\n  _toArray: function() {\n    if (this._element) {\n      this._update();\n      return this._snapshot;\n    }\n\n    return Array.prototype.slice.call(this);\n  },\n  get length() {\n    this._update();\n    return this._length || 0;\n  },\n  item: function(index) {\n    this._update();\n    return this[index] || null;\n  },\n  toString: function() {\n    return '[ jsdom NodeList ]: contains ' + this.length + ' items';\n  }\n};\nObject.defineProperty(core.NodeList.prototype, 'constructor', {\n  value: core.NodeList,\n  writable: true,\n  configurable: true\n});\n\ncore.DOMImplementation = function DOMImplementation(document, /* Object */ features) {\n  this._ownerDocument = document;\n  this._features = {};\n\n  if (features) {\n    for (var feature in features) {\n      if (features.hasOwnProperty(feature)) {\n        this.addFeature(feature.toLowerCase(), features[feature]);\n      }\n    }\n  }\n};\n\ncore.DOMImplementation.prototype = {\n  get ownerDocument() { return this._ownerDocument },\n  removeFeature : function(feature, version) {\n    feature = feature.toLowerCase();\n    if (this._features[feature]) {\n      if (version) {\n        var j        = 0,\n            versions = this._features[feature],\n            l        = versions.length;\n\n        for (j; j<l; j++) {\n          if (versions[j] === version) {\n            versions.splice(j,1);\n            return;\n          }\n        }\n      } else {\n        delete this._features[feature];\n      }\n    }\n  },\n\n  addFeature: function(feature, version) {\n    feature = feature.toLowerCase();\n\n    if (version) {\n\n      if (!this._features[feature]) {\n        this._features[feature] = [];\n      }\n\n      if (version instanceof Array) {\n        Array.prototype.push.apply(this._features[feature], version);\n      } else {\n        this._features[feature].push(version);\n      }\n    }\n  },\n\n  hasFeature: function(/* string */ feature, /* string */ version) {\n    feature = (feature) ? feature.toLowerCase() : '';\n    var versions = (this._features[feature]) ?\n                    this._features[feature]  :\n                    false;\n\n    if (!version && versions.length && versions.length > 0) {\n      return true;\n    } else if (typeof versions === 'string') {\n      return versions === version;\n    } else if (versions.indexOf && versions.length > 0) {\n      for (var i = 0; i < versions.length; i++) {\n        var found = versions[i] instanceof RegExp ?\n          versions[i].test(version) :\n          versions[i] === version;\n        if (found) { return true; }\n      }\n      return false;\n    } else {\n      return false;\n    }\n  }\n};\n\n\nvar attrCopy = function(src, dest, fn) {\n  if (src.attributes) {\n    var attrs = src.attributes, i, l = attrs.length, attr, copied;\n    for (i=0;i<l;i++) {\n      attr = attrs[i];\n      // skip over default attributes\n      if (!attr.specified) {\n        continue;\n      }\n      // TODO: consider duplicating this code and moving it into level2/core\n      if (attr.namespaceURI) {\n        dest.setAttributeNS(attr.namespaceURI,\n                                     attr.nodeName,\n                                     attr.nodeValue);\n        var localName = attr.nodeName.split(':').pop();\n        copied = dest.getAttributeNodeNS(attr.namespaceURI, localName);\n      } else {\n        dest.setAttribute(attr.nodeName, attr.nodeValue);\n        copied = dest.getAttributeNode(attr.nodeName);\n      }\n      if (typeof fn == \"function\") {\n        fn(attr, copied);\n      }\n\n    }\n  }\n  return dest;\n};\n\ncore.Node = function Node(ownerDocument) {\n  this._childNodes = new core.NodeList();\n  this._ownerDocument = ownerDocument;\n  this._attributes = new AttributeList(ownerDocument, this);\n  this._nodeName = null;\n  this._childrenList = null;\n  this._version = 0;\n  this._nodeValue = null;\n  this._parentNode = null;\n  this._nodeName = null;\n  this._readonly = false;\n};\n\ncore.Node.ELEMENT_NODE                = ELEMENT_NODE;\ncore.Node.ATTRIBUTE_NODE              = ATTRIBUTE_NODE;\ncore.Node.TEXT_NODE                   = TEXT_NODE;\ncore.Node.CDATA_SECTION_NODE          = CDATA_SECTION_NODE;\ncore.Node.ENTITY_REFERENCE_NODE       = ENTITY_REFERENCE_NODE;\ncore.Node.ENTITY_NODE                 = ENTITY_NODE;\ncore.Node.PROCESSING_INSTRUCTION_NODE = PROCESSING_INSTRUCTION_NODE;\ncore.Node.COMMENT_NODE                = COMMENT_NODE;\ncore.Node.DOCUMENT_NODE               = DOCUMENT_NODE;\ncore.Node.DOCUMENT_TYPE_NODE          = DOCUMENT_TYPE_NODE;\ncore.Node.DOCUMENT_FRAGMENT_NODE      = DOCUMENT_FRAGMENT_NODE;\ncore.Node.NOTATION_NODE               = NOTATION_NODE;\n\ncore.Node.prototype = {\n  ELEMENT_NODE                : ELEMENT_NODE,\n  ATTRIBUTE_NODE              : ATTRIBUTE_NODE,\n  TEXT_NODE                   : TEXT_NODE,\n  CDATA_SECTION_NODE          : CDATA_SECTION_NODE,\n  ENTITY_REFERENCE_NODE       : ENTITY_REFERENCE_NODE,\n  ENTITY_NODE                 : ENTITY_NODE,\n  PROCESSING_INSTRUCTION_NODE : PROCESSING_INSTRUCTION_NODE,\n  COMMENT_NODE                : COMMENT_NODE,\n  DOCUMENT_NODE               : DOCUMENT_NODE,\n  DOCUMENT_TYPE_NODE          : DOCUMENT_TYPE_NODE,\n  DOCUMENT_FRAGMENT_NODE      : DOCUMENT_FRAGMENT_NODE,\n  NOTATION_NODE               : NOTATION_NODE,\n\n  get children() {\n    if (!this._childrenList) {\n      var self = this;\n      this._childrenList = new core.NodeList(this, function() {\n        return Array.prototype.filter.call(self._childNodes, function(node) {\n          return node.tagName;\n        });\n      });\n    }\n    return this._childrenList;\n  },\n  get nodeValue() {\n    return this._nodeValue;\n  },\n  set nodeValue(value) {\n    // readonly\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR, 'Attempting to modify a read-only node');\n    }\n\n    this._nodeValue = value;\n  },\n  get parentNode() { return this._parentNode;},\n\n  get nodeName() {\n    var name = this._nodeName || this._tagName;\n    if (this.nodeType === ELEMENT_NODE &&\n        this._ownerDocument                  &&\n        this._ownerDocument._doctype          &&\n        this._ownerDocument._doctype.name.toLowerCase().indexOf(\"html\") !== -1)\n    {\n      return name.toUpperCase();\n    }\n    return name;\n  },\n  set nodeName(unused) { throw new core.DOMException();},\n  get attributes() { return this._attributes;},\n  get firstChild() {\n    return this._childNodes.length > 0 ? this._childNodes[0] : null;\n  },\n  set firstChild(unused) { throw new core.DOMException();},\n  get ownerDocument() { return this._ownerDocument;},\n  get readonly() { return this._readonly;},\n\n  get lastChild() {\n    var len = this._childNodes.length;\n    return len > 0 ? this._childNodes[len -1] : null;\n  },\n  set lastChild(unused) { throw new core.DOMException();},\n\n  get childNodes() {\n    return this._childNodes;\n  },\n  set childNodes(unused) { throw new core.DOMException();},\n\n  _indexOf: function(/*Node*/ child) {\n    if (!this._childNodes ||\n\t!this._childNodes.length) {\n      return -1;\n    }\n\n    var currentNode, index = 0, children = this._childNodes;\n\n    while ((currentNode = children[index])) {\n      if (currentNode == child) {\n        break;\n      }\n      index++;\n    }\n\n    if (currentNode == child) {\n      return index;\n    }\n    return -1;\n  },\n\n  get nextSibling() {\n    // find this node's index in the parentNode, add one and call it a day\n    if (!this._parentNode || !this._parentNode._indexOf) {\n      return null;\n    }\n\n    var index = this._parentNode._indexOf(this);\n\n    if (index == -1 || index+1 >= this._parentNode._childNodes.length) {\n      return null;\n    }\n\n    return this._parentNode._childNodes[index+1] || null;\n  },\n  set nextSibling(unused) { throw new core.DOMException();},\n\n  get previousSibling() {\n    if (!this._parentNode || !this._parentNode._indexOf) {\n      return null;\n    }\n\n    var index = this._parentNode._indexOf(this);\n\n    if (index == -1 || index-1 < 0) {\n      return null;\n    }\n\n    return this._parentNode._childNodes[index-1] || null;\n  },\n  set previousSibling(unused) { throw new core.DOMException();},\n\n  /* returns Node */\n  insertBefore :  function(/* Node */ newChild, /* Node*/ refChild) {\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR, 'Attempting to modify a read-only node');\n    }\n\n    // Adopt unowned children, for weird nodes like DocumentType\n    if (!newChild._ownerDocument) newChild._ownerDocument = this._ownerDocument;\n\n    // TODO - if (!newChild) then?\n    if (newChild._ownerDocument !== this._ownerDocument) {\n      throw new core.DOMException(WRONG_DOCUMENT_ERR);\n    }\n\n    if (newChild.nodeType && newChild.nodeType === ATTRIBUTE_NODE) {\n      throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n    }\n\n    // search for parents matching the newChild\n    var current = this;\n    do {\n      if (current === newChild) {\n        throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n      }\n    } while((current = current._parentNode));\n\n    // fragments are merged into the element\n    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      var tmpNode, i = newChild._childNodes.length;\n      while (i-- > 0) {\n        tmpNode = newChild.removeChild(newChild.firstChild);\n        this.insertBefore(tmpNode, refChild);\n      }\n    } else if (newChild === refChild) {\n      return newChild;\n    } else {\n      // if the newChild is already in the tree elsewhere, remove it first\n      if (newChild._parentNode) {\n        newChild._parentNode.removeChild(newChild);\n      }\n\n      if (refChild == null) {\n        var refChildIndex = this._childNodes.length;\n      } else {\n        var refChildIndex = this._indexOf(refChild);\n        if (refChildIndex == -1) {\n          throw new core.DOMException(NOT_FOUND_ERR);\n        }\n      }\n\n      Array.prototype.splice.call(this._childNodes, refChildIndex, 0, newChild);\n\n      newChild._parentNode = this;\n      if (this._attached && newChild._attach) {\n        newChild._attach();\n      }\n\n      this._modified();\n    }\n\n    return newChild;\n  }, // raises(DOMException);\n\n  _modified: function() {\n    this._version++;\n    if (this._ownerDocument) {\n      this._ownerDocument._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n  },\n\n  _attrModified: function(name, value, oldValue) {\n    if (name == 'id' && this._attached) {\n      var doc = this._ownerDocument;\n      detachId(oldValue,this,doc);\n      attachId(value,this,doc);\n    }\n\n    // Check for inline event handlers.\n    // We can't set these like other attributes then look it up in\n    // dispatchEvent() because that would create 2 'traditional' event handlers\n    // in the case where there's an inline event handler attribute, plus one\n    // set using element.on* in a script.\n    //\n    // @see http://www.w3.org/TR/2011/WD-html5-20110405/webappapis.html#event-handler-content-attributes\n    if ((name.length > 2) && (name[0] == 'o') && (name[1] == 'n')) {\n        if (value) {\n          var self = this;\n          // Check whether we're the window. This can happen because inline\n          // handlers on the body are proxied to the window.\n          var w = (typeof self.run !== 'undefined') ? self : self._ownerDocument.parentWindow;\n          self[name] = function (event) {\n              // The handler code probably refers to functions declared in the\n              // window context, so we need to call run().\n\n              // Use awesome hacks to get the correct `this` context for the\n              // inline event handler. This would only be necessary if we're an\n              // element, but for the sake of simplicity we also do it on window.\n\n              // Also set event variable and support `return false`.\n              w.__tempContextForInlineEventHandler = self;\n              w.__tempEvent = event;\n              w.run(\"if ((function (event) {\" + value + \"}).call(\" +\n                \"window.__tempContextForInlineEventHandler, window.__tempEvent) === false) {\" +\n                \"window.__tempEvent.preventDefault()}\");\n              delete w.__tempContextForInlineEventHandler;\n              delete w.__tempEvent;\n          };\n        } else {\n          this[name] = null;\n        }\n    }\n  },\n\n  /* returns Node */\n  replaceChild : function(/* Node */ newChild, /* Node */ oldChild){\n    this.insertBefore(newChild, oldChild);\n    return this.removeChild(oldChild);\n  }, //raises(DOMException);\n\n  /* returns void */\n  _attach : function() {\n    this._attached = true;\n    if (this.id) {\n      attachId(this.id,this,this._ownerDocument);\n    }\n    for (var i=0,len=this._childNodes.length;i<len;i++) {\n      if (this._childNodes[i]._attach) {\n        this._childNodes[i]._attach();\n      }\n    }\n  },\n  /* returns void */\n  _detach : function() {\n    var i, elms;\n    this._attached = false;\n    if (this.id) {\n      detachId(this.id,this,this._ownerDocument);\n    }\n    for (var i=0,len=this._childNodes.length;i<len;i++) {\n      this._childNodes[i]._detach();\n    }\n  },\n\n  /* returns Node */\n  removeChild : function(/* Node */ oldChild){\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    // TODO - if (!oldChild) then?\n    var oldChildIndex = this._indexOf(oldChild);\n    if (oldChildIndex == -1) {\n      throw new core.DOMException(NOT_FOUND_ERR);\n    }\n\n    Array.prototype.splice.call(this._childNodes, oldChildIndex, 1);\n    oldChild._parentNode = null;\n    this._modified();\n    oldChild._detach();\n    return oldChild;\n  }, // raises(DOMException);\n\n  /* returns Node */\n  appendChild : function(/* Node */ newChild) {\n    return this.insertBefore(newChild, null);\n  }, // raises(DOMException);\n\n  /* returns boolean */\n  hasChildNodes : function() {\n    return this._childNodes.length > 0;\n  },\n\n  /* returns Node */\n  cloneNode : function(/* bool */ deep, fn) {\n\n    var object = null;\n    switch (this.nodeType) {\n\n      case this.ELEMENT_NODE:\n        object = attrCopy(this,this._ownerDocument.createElement(this.tagName), fn);\n      break;\n\n      case this.TEXT_NODE:\n        object = attrCopy(this,this._ownerDocument.createTextNode(this.tagName));\n        object.nodeValue = this.nodeValue;\n      break;\n      case this.CDATA_SECTION_NODE:\n        object = this._ownerDocument.createCDATASection(this.tagName);\n        object.nodeValue = this.nodeValue;\n      break;\n      case this.ENTITY_REFERENCE_NODE:\n        var name = (this._entity) ? this._entity.name : this._entityName,\n            ref  = this._ownerDocument.createEntityReference(name);\n\n        object = attrCopy(this, ref);\n        object.nodeValue = this.nodeValue;\n      break;\n      case this.ATTRIBUTE_NODE:\n        object = this._ownerDocument.createAttribute(this.name);\n      break;\n      case this.ENTITY_NODE:\n        var entity = this._ownerDocument.createEntityNode(this.name);\n        object = attrCopy(this, entity);\n        object.nodeValue = this.nodeValue;\n        object._publicId = this._publicId;\n        object._systemId = this._systemId;\n        object._notationName = this.notationName;\n      break;\n      case this.PROCESSING_INSTRUCTION_NODE:\n        var pi = this._ownerDocument.createProcessingInstruction(this._target,\n                                                                this._data);\n        object = attrCopy(this, pi);\n        object.nodeValue = this.nodeValue;\n      break;\n      case this.COMMENT_NODE:\n        object = this._ownerDocument.createComment(this.tagName);\n        object.nodeValue = this.nodeValue;\n      break;\n      case this.DOCUMENT_NODE:\n        object = attrCopy(this, new core.Document());\n        // TODO: clone the doctype/entities/notations/etc?\n      break;\n      case this.DOCUMENT_TYPE_NODE:\n        object = attrCopy(this, new core.DocumentType());\n        object.nodeValue = this.nodeValue;\n      break;\n      case this.DOCUMENT_FRAGMENT_NODE:\n        object = this._ownerDocument.createDocumentFragment();\n      break;\n      case this.NOTATION_NODE:\n        object = this._ownerDocument.createNotationNode(this._name,\n                                                       this._publicId,\n                                                       this._systemId);\n        object = attrCopy(this,object);\n        object.nodeValue = this.nodeValue;\n      break;\n      default:\n        throw new core.DOMException(NOT_FOUND_ERR);\n      break;\n    }\n\n    if (typeof fn === \"function\") {\n      fn(this, object);\n    }\n\n    if (deep || this.nodeType === ATTRIBUTE_NODE) {\n      var clone = null;\n      for (var i=0,len=this._childNodes.length;i<len;i++)\n      {\n        clone = this._childNodes[i].cloneNode(true);\n        if (clone.nodeType === ATTRIBUTE_NODE) {\n          object.setAttributeNode(clone);\n        } else {\n          var readonly = object._readonly;\n          object._readonly = false;\n          object.appendChild(clone);\n          object._readonly = readonly;\n        }\n      }\n    }\n\n    return object;\n  },\n\n  /* returns void */\n  normalize: function() {\n    var prevChild, child, attr,i;\n\n    if (this._attributes && this._attributes.length) {\n      for (i=0;i<this._attributes.length;i++)\n      {\n        if (this._attributes[i]) {\n          attr = this._attributes[i].normalize();\n        }\n      }\n    }\n\n    for (i=0;i<this._childNodes.length;i++)\n    {\n      child = this._childNodes[i];\n\n      if (child.normalize) {\n        child.normalize();\n      }\n\n      // Level2/core clean off empty nodes\n      if (child.nodeValue === \"\") {\n        this.removeChild(child);\n        i--;\n        continue;\n      }\n\n      if (i>0) {\n        prevChild = this._childNodes[i-1];\n\n        if (child.nodeType === TEXT_NODE &&\n            prevChild.nodeType === TEXT_NODE)\n        {\n\n          // remove the child and decrement i\n          prevChild.appendData(child.nodeValue);\n\n          this.removeChild(child);\n          i--;\n        }\n      }\n    }\n  },\n  toString: function() {\n    var id = '';\n    if (this.id) {\n        id = '#' + this.id;\n    }\n    if (this.className) {\n        var classes = this.className.split(/\\s+/);\n\tfor (var i = 0, len = classes.length; i < len; i++) {\n\t    id += '.' + classes[i];\n\t}\n    }\n    return '[ ' + this.tagName + id + ' ]';\n  },\n  raise: function(type, message, data) {\n    var text = type + \": \" + message;\n\n    if (data) {\n      if (data.exception) {\n        text = data.exception.stack;\n      } else {\n        text += ' - More:\\n' + data;\n      }\n    }\n\n    if (type === \"error\") {\n      if (!this.errors) {\n        this.errors = [];\n      }\n      // TODO: consider using actual `Error` objects or `DOMException`s even..\n      var err = {\n        type    : type,\n        message : message || \"No message\",\n        data    : data || null\n      };\n\n      this.errors.push(err);\n\n      if (this._ownerDocument        &&\n          this._ownerDocument.raise &&\n          this !== this._ownerDocument)\n      {\n        this._ownerDocument.raise(type, message, data);\n      }\n    }\n  }\n};\n\n\ncore.NamedNodeMap = function NamedNodeMap(document) {\n  this._nodes = Object.create(null);\n  this._nsStore = {};\n  this.length = 0;\n  this._ownerDocument = document;\n  this._readonly = false;\n};\ncore.NamedNodeMap.prototype = {\n  get readonly() { return this._readonly;},\n  get ownerDocument() { this._ownerDocument;},\n\n  exists : function(name) {\n    return (this._nodes[name] || this._nodes[name] === null) ? true : false;\n  },\n\n  /* returns Node */\n  getNamedItem: function(/* string */ name) {\n    return this._nodes[name] || null;\n  },\n\n  /* returns Node */\n  setNamedItem: function(/* Node */ arg) {\n\n    // readonly\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    // arg is from a different document\n    if (arg && arg._ownerDocument !== this._ownerDocument) {\n      throw new core.DOMException(WRONG_DOCUMENT_ERR);\n    }\n\n    // if this argument is already in use..\n    if (arg && arg._ownerElement) {\n      throw new core.DOMException(INUSE_ATTRIBUTE_ERR);\n    }\n\n    var name = arg.name || arg.tagName;\n    var ret = this._nodes[name];\n    if (!ret) {\n      this.length++;\n      ret = null;\n    }\n    arg._specified = true;\n    this._nodes[name] = arg;\n\n    // Avoid overwriting prototype methods etc.:\n    if (this.hasOwnProperty(name) || !(name in this)) {\n      this[name] = arg;\n    }\n    return ret;\n  }, // raises: function(DOMException) {},\n\n  /* returns Node */\n  removeNamedItem: function(/* string */ name) {\n\n    // readonly\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    if (!this._nodes[name]) {\n      throw new core.DOMException(NOT_FOUND_ERR);\n    }\n\n    var prev = this._nodes[name] || null;\n    delete this._nodes[name];\n    delete this[name];\n\n    this.length--;\n    return prev;\n  }, // raises: function(DOMException) {},\n\n  /* returns Node */\n  item: function(/* int */ index) {\n    var current = 0;\n    for (var member in this._nodes) {\n      if (current === index && this._nodes[member]) {\n        return this._nodes[member];\n      }\n      current++;\n    }\n    return null;\n  }\n};\n\n//\n// For historical reasons, AttributeList objects must allow accessing\n// attributes as if the object were an associative array. For\n// instance, if `attributes` is an AttributeList object then\n// `attributes.x` should evaluate to the attribute named `x` (which is\n// not in any namespace). The AttributeList class uses the dollar\n// symbol ($) to reduce the possibility of a clash between its field\n// names and possible attribute names. For instance, if the method\n// currently named `$set` were instead named `set` then it would not\n// be possible to access an attribute named `set` through\n// `attributes.set`. The dollar symbol is not valid in attribute names\n// so `$set` cannot clash.\n//\n// Some fields do not get the $ because:\n//\n// * They are part of the API (e.g. `setNamedItem`, `length`), so they\n//   must be visible under a specific name.\n//\n// * Jsdom's code which traverses the DOM tree expects regularly named\n//   fields (e.g. `_parentNode`).\n//\nfunction AttributeList(document, parentNode) {\n  this._ownerDocument = document;\n  this._parentNode = parentNode;\n  this._readonly = false;\n  this._$ns_to_attrs = Object.create(null);\n  this._$name_to_attrs = Object.create(null);\n  this.length = 0;\n}\n\nAttributeList.prototype = {\n  _$reserved: [], // Initialized later\n\n\n  //\n  // Code internal to jsdom and which manipulates an AttributeList\n  // object should use the following methods rather than the methods\n  // that provide the NamedNodeMap interface.\n  //\n\n  // This method *ignores* namespaces. This is *not* the same thing as\n  // requesting an attribute with a null namespace.\n  $getNoNS: function (name) {\n    var attrs = this._$name_to_attrs[name];\n    if (!attrs) {\n      return null;\n    }\n\n    return attrs[0] || null;\n  },\n\n  $getNode: function (namespace, localName) {\n    var attrs = this._$ns_to_attrs[namespace];\n    if (!attrs) {\n      return null;\n    }\n\n    var ret = attrs[localName];\n    if (!ret) {\n      return null;\n    }\n\n    return ret;\n  },\n\n  // This method *ignores* namespaces. This is *not* the same thing as\n  // requesting an attribute with a null namespace.\n  $setNoNS: function (name, value) {\n    var attr = this.$getNoNS(name);\n    if (!attr) {\n      this.$set(name, value);\n      return;\n    }\n\n    var prev_val = attr.value;\n    attr.value = value;\n    attr._specified = true;\n\n    this._parentNode._attrModified(attr.name, attr.value, prev_val);\n    this._parentNode._modified();\n  },\n\n  $set: function (localName, value, name, prefix, namespace) {\n    if (this._readonly) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    if (name === undefined) {\n      name = localName;\n    }\n\n    if (prefix === undefined) {\n      prefix = null;\n    }\n\n    if (namespace === undefined) {\n      namespace = null;\n    }\n\n    var prev_attr = this.$getNode(namespace, localName);\n    var attr;\n\n    var prev_val = null;\n    if (prev_attr) {\n      prev_val = prev_attr.value;\n      prev_attr._prefix = prefix;\n      prev_attr.value = value;\n      attr = prev_attr;\n      attr._specified = true;\n\n      this._parentNode._attrModified(attr.name, attr.value, prev_val);\n      this._parentNode._modified();\n    }\n    else {\n      attr = this._ownerDocument.createAttribute(name);\n      attr._ownerElement = this._parentNode;\n      attr.value = value;\n      attr._namespaceURI = namespace;\n      attr._prefix = prefix;\n      attr._localName = localName;\n      attr._parentNode = this._parentNode;\n      attr._created = true;\n      this.$setNode(attr);\n      // $setNode calls the parent node methods.\n    }\n  },\n\n  $setNode: function (attr) {\n    if (this._readonly) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    if (attr.nodeType !== ATTRIBUTE_NODE) {\n      throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n    }\n\n    if (attr._ownerDocument !== this._ownerDocument) {\n      throw new core.DOMException(WRONG_DOCUMENT_ERR);\n    }\n\n    if (attr._parentNode && attr._parentNode !== this._parentNode) {\n      throw new core.DOMException(INUSE_ATTRIBUTE_ERR);\n    }\n\n    var localName = attr._localName;\n    var name = attr.name;\n    var prefix = attr._prefix;\n    var namespace = attr._namespaceURI;\n\n    if (name === undefined) {\n      name = localName;\n    }\n\n    if (prefix === undefined) {\n      prefix = null;\n    }\n\n    if (namespace === undefined) {\n      namespace = null;\n    }\n\n    var prev_attr = this.$getNode(namespace, localName);\n\n    var prev_val = null;\n    if (prev_attr) {\n      prev_val = prev_attr.value;\n      // Remove the old attribute\n      this._$onlyRemoveNode(prev_attr);\n    }\n\n    attr._parentNode = this._parentNode;\n    attr._ownerElement = this._parentNode;\n    attr._specified = true;\n\n    var attrs = this._$ns_to_attrs[namespace];\n    if (!attrs) {\n      attrs = this._$ns_to_attrs[namespace] = Object.create(null);\n    }\n    attrs[localName] = attr;\n\n    attrs = this._$name_to_attrs[name];\n    if (!attrs) {\n      attrs = this._$name_to_attrs[name] = [attr];\n    }\n    else {\n      attrs.push(attr);\n    }\n\n    // Only attributes in the null namespace can be set this way.\n    if (namespace === null) {\n      // Make the node a field on this object but ONLY if it does not\n      // clash with the reserved names.\n      if (this._$reserved.indexOf(name) === -1) {\n        this[name] = attr;\n      }\n    }\n\n    this[this.length] = attr;\n    this.length++;\n\n    this._parentNode._attrModified(attr.name, attr.value, prev_val);\n    this._parentNode._modified();\n\n    return prev_attr;\n  },\n\n  // This method *ignores* namespaces. This is *not* the same thing as\n  // requesting an attribute with a null namespace.\n  $removeNoNS: function (name) {\n    var attr = this.$getNoNS(name);\n    return attr ? this.$removeNode(attr) : null;\n  },\n\n  $remove: function (namespace, localName) {\n    var attr = this.$getNode(namespace, localName);\n    return attr ? this.$removeNode(attr) : null;\n  },\n\n  /* Only removes the node, and does not add a default value. */\n  _$onlyRemoveNode: function (attr) {\n    var namespace = attr._namespaceURI;\n    var localName = attr._localName;\n\n    var attrs = this._$ns_to_attrs[namespace];\n    if (!attrs) {\n      return null;\n    }\n\n    var found_attr = attrs[localName];\n    if (found_attr !== attr) {\n      return null;\n    }\n\n    if (this._readonly) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    attr._ownerElement = null;\n    attr._parentNode = null;\n    delete attrs[localName];\n\n    attrs = this._$name_to_attrs[attr.name];\n    attrs.splice(attrs.indexOf(attr), 1);\n\n    var ix = Array.prototype.indexOf.call(this, attr);\n    // Splice also modifies length.\n    Array.prototype.splice.call(this, ix, 1);\n\n    if (this[attr.name] === attr) {\n      delete this[attr.name];\n    }\n\n    this._parentNode._attrModified(attr.name);\n    this._parentNode._modified();\n\n    return attr;\n  },\n\n  $removeNode: function (attr) {\n    if (!this._$onlyRemoveNode(attr)) {\n      return null;\n    }\n\n    // set default value if available\n    var doc = this._ownerDocument;\n    if (doc && doc._doctype && doc._doctype.name.toLowerCase() !== \"html\") {\n      var elem =\n            doc._doctype._attributes.getNamedItem(this._parentNode.nodeName);\n\n      if (elem) {\n        var defaultValue = elem.attributes.getNamedItemNS(attr._namespaceURI,\n                                                          attr._localName);\n\n        if (defaultValue) {\n          this.$set(attr._localName, defaultValue.value, attr.name, attr._prefix,\n                   attr._namespaceURI);\n          var new_attr = this.$getNode(attr._namespaceURI, attr._localName);\n          new_attr._specified = false;\n        }\n      }\n    }\n    return attr;\n  },\n\n  // Although http://dom.spec.whatwg.org/#concept-element-attribute\n  // does not specify that the attributes field on an Element should\n  // support NamedNodeMap, in practice browsers still support this\n  // interface so we should support it for compatibility.\n\n  getNamedItem: function (name) {\n    return this.getNamedItemNS(null, name);\n  },\n  removeNamedItem: function (name) {\n    return this.removeNamedItemNS(null, name);\n  },\n  item: function (i) {\n      return this[i];\n  },\n  getNamedItemNS: function (namespaceURI, localName) {\n    if (namespaceURI === \"\") {\n      namespaceURI = null;\n    }\n\n    return this.$getNode(namespaceURI, localName);\n  },\n  removeNamedItemNS: function (namespaceURI, localName) {\n    var ret = this.$remove(namespaceURI, localName);\n\n    if (ret === null) {\n      throw new core.DOMException(NOT_FOUND_ERR);\n    }\n\n    return ret;\n  }\n};\n\n// Alias these methods.\nAttributeList.prototype.setNamedItem = AttributeList.prototype.$setNode;\nAttributeList.prototype.setNamedItemNS = AttributeList.prototype.$setNode;\n\n(function () {\n  // Construct the list of reserved attribute names from a temporarily\n  // created AttributeList and from the chain of prototypes. We need\n  // this because JavaScript code running an a browser expects to be\n  // able to do el.attributes.x to get the value of the attribute \"x\"\n  // on an element. Unfortunately, JavaScript *currently* does not\n  // allow us to elegantly provide such functionality without risking\n  // a clash with the fields and methods set on the AttributeList\n  // object. Hence we need a list of reserved field names.\n\n  var reserved = Object.keys(new AttributeList());\n  var prototype = AttributeList.prototype;\n  while (prototype) {\n    reserved = reserved.concat(Object.getOwnPropertyNames(prototype));\n    prototype = Object.getPrototypeOf(prototype);\n  }\n  AttributeList.prototype._$reserved = reserved;\n})();\n\ncore.AttributeList = AttributeList;\n\ncore.NotationNodeMap = function NotationNodeMap(document) {\n  core.NamedNodeMap.call(this, document);\n  this._readonly = false;\n  for (var i=1;i<arguments.length;i++) {\n    this.setNamedItem(arguments[i]);\n  }\n  this._readonly = true;\n};\ninheritFrom(core.NamedNodeMap, core.NotationNodeMap);\n\ncore.EntityNodeMap = function EntityNodeMap(document) {\n  core.NamedNodeMap.call(this,document);\n  this._readonly = false;\n  var i = 1, l = arguments.length;\n\n  for (i=1; i<l; i++) {\n    this.setNamedItem(arguments[i]);\n  }\n  core.markTreeReadonly(this);\n};\ninheritFrom(core.NamedNodeMap, core.EntityNodeMap);\n\ncore.Element = function Element(document, tagName) {\n  this._ownerDocument = document;\n  core.Node.call(this, document);\n  this._nodeName = tagName;\n  this._tagName = tagName;\n};\n\ninheritFrom(core.Node, core.Element, {\n\n  get nodeValue() { return null;},\n  set nodeValue(value) { /* do nothing */ },\n  get tagName() {\n    if (this.nodeType === ELEMENT_NODE &&\n        this._ownerDocument                  &&\n        this._ownerDocument._doctype          &&\n        this._ownerDocument._doctype.name.toLowerCase().indexOf(\"html\") !== -1)\n    {\n      return this.nodeName.toUpperCase();\n    }\n    return this.nodeName;\n  },\n  nodeType : ELEMENT_NODE,\n  get attributes() {\n    return this._attributes;\n  },\n\n  /* returns string */\n  getAttribute: function(/* string */ name) {\n    var attribute = this._attributes.$getNode(null, name);\n    if (attribute) {\n      return attribute.value;\n    }\n    return null;\n  },\n\n  setAttribute: function(/* string */ name, /* string */ value) {\n    if (this._ownerDocument) {\n      var attr = this._ownerDocument.createAttribute(name);\n      attr.value = value;\n      attr._ownerElement = this;\n      attr._created = true;\n      this._attributes.$setNode(attr);\n    }\n\n  }, //raises: function(DOMException) {},\n\n  removeAttribute: function(/* string */ name) {\n    this._attributes.$remove(null, name);\n  }, // raises: function(DOMException) {},\n\n  /* returns Attr */\n  getAttributeNode: function(/* string */ name) {\n    return this._attributes.$getNode(null, name);\n  },\n\n  /* returns Attr */\n  setAttributeNode: function(/* Attr */ newAttr) {\n    var prevNode = this._attributes.$getNode(null, newAttr.name);\n    if (prevNode) {\n      prevNode._ownerElement = null;\n    }\n\n    newAttr._ownerElement = this;\n    this._attributes.$setNode(newAttr);\n\n    return (prevNode && prevNode.specified) ? prevNode : null;\n  }, //  raises: function(DOMException) {},\n\n  /* returns Attr */\n  removeAttributeNode: function(/* Attr */ oldAttr) {\n    var ret = this._attributes.$removeNode(oldAttr);\n\n    if (ret !== null) {\n      return ret;\n    }\n\n    throw new core.DOMException(NOT_FOUND_ERR);\n  }, //raises: function(DOMException) {},\n\n  /* returns NodeList */\n  getElementsByTagName: function(/* string */ name) {\n    name = name.toLowerCase();\n\n    function filterByTagName(child) {\n      child = (child.nodeType === ENTITY_REFERENCE_NODE) ?\n               child._entity                             :\n               child;\n\n      if (child.nodeName && child.nodeType === ELEMENT_NODE) {\n        return name === \"*\" || (child.nodeName.toLowerCase() === name);\n      }\n\n      return false;\n    }\n    return new core.NodeList(this._ownerDocument || this, core.mapper(this, filterByTagName, true));\n  },\n});\n\ncore.DocumentFragment = function DocumentFragment(document) {\n  core.Node.call(this, document);\n  this._nodeName = this._tagName = \"#document-fragment\";\n};\ninheritFrom(core.Node, core.DocumentFragment, {\n  nodeType : DOCUMENT_FRAGMENT_NODE,\n  get nodeValue() { return null;},\n  set nodeValue(unused) { /* do nothing */ },\n  get attributes() { return null;}\n});\n\ncore.ProcessingInstruction = function ProcessingInstruction(document, target, data) {\n  this._ownerDocument = document;\n  core.Node.call(this, document);\n  this._nodeName = target;\n  this._tagName = target;\n  this._target = target;\n  this._nodeValue = data;\n}\ninheritFrom(core.Node, core.ProcessingInstruction, {\n  nodeType : PROCESSING_INSTRUCTION_NODE,\n  get target() { return this._target;},\n  set target(value) { throw new core.DOMException(1);},\n  get nodeValue() { return this._nodeValue;},\n  set nodeValue(value) { this._nodeValue = value},\n  get data()   { return this._nodeValue;},\n  set data(unused)   { throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);},\n  get attributes() { return null;}\n\n});\n\ncore.Document = function Document(options) {\n  if (!options) {\n    options = {};\n  }\n  else if (typeof options == 'string') {\n    options = {\n      name: options\n    };\n  }\n  core.Node.call(this, \"#document\");\n  this._nodeName = this._tagName = \"#document\";\n  this._contentType = options.contentType || \"text/xml\";\n  this._doctype = options._doctype;\n  this._implementation = options.implementation || new (core.DOMImplementation)();\n  this._documentElement = null;\n  this._ids = Object.create(null);\n  this._attached = true;\n  this._ownerDocument = this;\n  this._readonly = false;\n};\n\n\nvar tagRegEx = /[^\\w:\\d_\\.-]+/i;\nvar entRegEx = /[^\\w\\d_\\-&;]+/;\nvar invalidAttrRegEx = /[\\s\"'>/=\\u0000-\\u001A]/;\n\ninheritFrom(core.Node, core.Document, {\n  nodeType : DOCUMENT_NODE,\n  _elementBuilders : { },\n  _defaultElementBuilder: function(document, tagName) {\n    return new core.Element(document, tagName);\n  },\n  get contentType() { return this._contentType;},\n  get doctype() { return this._doctype || null;},\n  set doctype(doctype) { this._doctype = doctype;},\n  get documentElement() {\n    if (this._documentElement) {\n      return this._documentElement;\n    } else {\n      var children = this._childNodes, len = this._childNodes.length, i=0;\n      for (i;i<len;i++) {\n        if (children[i].nodeType === ELEMENT_NODE) {\n          this._documentElement = children[i];\n          return children[i];\n        }\n      }\n      return null;\n    }\n  },\n\n  get implementation() { return this._implementation;},\n  set implementation(implementation) { this._implementation = implementation;},\n  get nodeName() { return '#document'; },\n  get tagName() {\n    return null;\n  },\n  get nodeValue() { return null; },\n  set nodeValue(unused) { /* noop */ },\n  get attributes() { return null;},\n  get ownerDocument() { return null;},\n  get readonly() { return this._readonly;},\n\n  /* returns Element */\n  _createElementNoTagNameValidation: function(/*string*/ tagName) {\n    var lower = tagName.toLowerCase();\n    var element = (this._elementBuilders[lower] || this._defaultElementBuilder)(this, tagName);\n\n    // Check for and introduce default elements\n    if (this._doctype && this._doctype._attributes && this._doctype.name.toLowerCase() !== \"html\") {\n      var attrElement = this._doctype._attributes.getNamedItem(tagName);\n      if (attrElement && attrElement._childNodes) {\n\n        var attrs = attrElement.attributes;\n        var attr, len = attrs.length, defaultAttr;\n        for (var i = 0; i < len; i++) {\n          defaultAttr = attrs[i];\n          if (defaultAttr) {\n            attr = this.createAttribute(defaultAttr.name);\n            attr.value = defaultAttr.value;\n            element.setAttributeNode(attr);\n            attr._specified = false;\n            attr._created = true;\n          }\n        }\n      }\n    }\n\n    element._created = true;\n    return element;\n  },\n\n  /* returns Element */\n  createElement: function(/* string */ tagName) {\n    tagName = String(tagName);\n\n    var c = [];\n\n    if (tagName.length === 0 || (c = tagName.match(tagRegEx))) {\n      throw new core.DOMException(INVALID_CHARACTER_ERR, 'Invalid character in tag name: ' + c.pop());\n    }\n\n    return this._createElementNoTagNameValidation(tagName);\n  }, //raises: function(DOMException) {},\n\n  /* returns DocumentFragment */\n  createDocumentFragment: function() {\n    return new core.DocumentFragment(this);\n  },\n\n  /* returns Text */\n  createTextNode: function(/* string */ data) {\n    return new core.Text(this,data);\n  },\n\n  /* returns Comment */\n  createComment: function(/* string */ data) {\n    return new core.Comment(this,data);\n  },\n\n  /* returns CDATASection */\n  createCDATASection: function(/* string */ data) {\n    if (this._doctype && this._doctype.name === \"html\") {\n      throw new core.DOMException(NOT_SUPPORTED_ERR);\n    }\n\n    return new core.CDATASection(this,data);\n  }, // raises: function(DOMException) {},\n\n  /* returns ProcessingInstruction */\n  createProcessingInstruction: function(/* string */ target,/* string */ data) {\n    if (target.match(tagRegEx) || !target || !target.length) {\n      throw new core.DOMException(INVALID_CHARACTER_ERR);\n    }\n\n    return new core.ProcessingInstruction(this, target, data);\n  }, // raises: function(DOMException) {},\n\n  /* returns Attr */\n  createAttribute: function(/* string */ name) {\n    if (!name || !name.length || name.match(invalidAttrRegEx) ) {\n      throw new core.DOMException(INVALID_CHARACTER_ERR, \"attribute name: \" + name);\n    }\n    return new core.Attr(this, name,false);\n  }, // raises: function(DOMException) {},\n\n  /* returns EntityReference */\n  createEntityReference: function(/* string */ name) {\n\n    if (this._doctype && this._doctype.name === \"html\") {\n      throw new core.DOMException(NOT_SUPPORTED_ERR);\n    }\n\n    name = name.replace(/[&;]/g,\"\");\n    if (!name || !name.length) {\n      throw new core.DOMException(INVALID_CHARACTER_ERR);\n    }\n\n    if (name.match(tagRegEx)) {\n      throw new core.DOMException(INVALID_CHARACTER_ERR);\n    }\n\n    var entity;\n    if (this._doctype && this._doctype.entities) {\n      entity = this._doctype.entities.getNamedItem(name);\n    } else {\n      entity = null;\n    }\n\n    var ref    = new core.EntityReference(this, entity);\n\n    ref._entityName = name;\n\n    return ref;\n  }, //raises: function(DOMException) {},\n\n  /* returns Entity */\n  createEntityNode : function(/* string */ name)\n  {\n\n    if (name.match(entRegEx) || !name || !name.length) {\n      throw new core.DOMException(INVALID_CHARACTER_ERR);\n    }\n\n    var ret = new core.Entity(this, name);\n    ret._readonly = false;// TODO: fix me please.\n\n    for (var i=1;i<arguments.length;i++)\n    {\n      ret.appendChild(arguments[i]);\n    }\n\n    core.markTreeReadonly(ret);\n\n    return ret;\n  },\n\n  /* returns Notation */\n  createNotationNode : function(/* string */ name,/* string */ publicId,/* string */ systemId)\n  {\n\n    if (name.match(entRegEx) || !name || !name.length) {\n      throw new core.DOMException(INVALID_CHARACTER_ERR);\n    }\n\n    var ret = new core.Notation(this, name, publicId, systemId);\n    ret._readonly = false;// TODO: fix me please.\n\n    for (var i=3;i<arguments.length;i++)\n    {\n      ret.appendChild(arguments[i]);\n    }\n\n    core.markTreeReadonly(ret);\n\n    return ret;\n  },\n\n  appendChild : function(/* Node */ arg) {\n    if (this.documentElement && arg.nodeType == ELEMENT_NODE) {\n      throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n    }\n    return core.Node.prototype.appendChild.call(this, arg);\n  },\n\n  removeChild : function(/* Node */ arg) {\n    var ret = core.Node.prototype.removeChild.call(this, arg);\n    if (arg == this._documentElement) {\n      this._documentElement = null;// force a recalculation\n    }\n    return ret;\n  },\n\n  /* returns NodeList */\n  getElementsByTagName: function(/* string */ name) {\n    function filterByTagName(child) {\n      if (child.nodeType && child.nodeType === ENTITY_REFERENCE_NODE)\n      {\n        child = child._entity;\n      }\n\n      if (child.nodeName && child.nodeType === ELEMENT_NODE)\n      {\n        if (name === \"*\") {\n          return true;\n\n        // case insensitivity for html\n        } else if (child._ownerDocument && child._ownerDocument._doctype &&\n                   //child._ownerDocument._doctype.name === \"html\" &&\n                   child.nodeName.toLowerCase() === name.toLowerCase())\n        {\n          return true;\n        } else if (child.nodeName.toLowerCase() === name.toLowerCase()) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return new core.NodeList(this.documentElement || this, core.mapper(this, filterByTagName, true));\n  }\n});\n\ncore.CharacterData = function CharacterData(document, value) {\n  core.Node.call(this, document);\n\n  this._nodeValue = value + \"\";\n};\ninheritFrom(core.Node, core.CharacterData, {\n\n  get data() { return this._nodeValue;},\n  set data(data) {\n\n    // readonly\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    this._nodeValue = data;\n  },\n\n  /* returns int */\n  get length() { return this._nodeValue.length || 0;},\n\n  /* returns string */\n  substringData: function(/* int */ offset, /* int */ count) {\n\n    if (count < 0 || offset < 0 || offset > this._nodeValue.length) {\n      throw new core.DOMException(INDEX_SIZE_ERR);\n    }\n\n    return (this._nodeValue.length < offset + count) ?\n            this._nodeValue.substring(offset) :\n            this._nodeValue.substring(offset, offset+count);\n\n  }, // raises: function(DOMException) {},\n\n  /* returns string */\n  appendData: function(/* string */ arg) {\n\n    // readonly\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    this._nodeValue+=arg;\n    return this._nodeValue;\n  }, // raises: function(DOMException) {},\n\n  /* returns string */\n  insertData: function(/* int */ offset, /* string */ arg) {\n\n    // readonly\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    if (offset < 0 || offset > this._nodeValue.length) {\n      throw new core.DOMException(INDEX_SIZE_ERR);\n    }\n\n    var start = this._nodeValue.substring(0,offset);\n    var end = this._nodeValue.substring(offset);\n\n    this._nodeValue = start + arg + end;\n\n  }, //raises: function(DOMException) {},\n\n  /* returns void */\n  deleteData: function(/* int */ offset, /* int */ count) {\n\n    // readonly\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    if (offset       < 0                     ||\n        offset       > this._nodeValue.length ||\n        count        < 0)\n    {\n      throw new core.DOMException(INDEX_SIZE_ERR);\n    }\n\n    var start = this._nodeValue.substring(0,offset);\n\n    this._nodeValue = (offset+count<this._nodeValue.length) ?\n                     start + this._nodeValue.substring(offset+count) :\n                     start;\n  }, // raises: function(DOMException) {},\n\n  /* returns void */\n  replaceData: function(/* int */ offset, /* int */ count, /* string */ arg) {\n\n    // readonly\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    count = (offset+count > this._nodeValue.length) ?\n             this.nodeValue.length-offset           :\n             count;\n\n    if (offset       < 0                     ||\n        offset       > this._nodeValue.length ||\n        count        < 0                     /*||\n        offset+count > this._nodeValue.length*/)\n    {\n      throw new core.DOMException(INDEX_SIZE_ERR);\n    }\n\n    var start = this._nodeValue.substring(0,offset);\n    var end = this._nodeValue.substring(offset+count);\n\n    this._nodeValue = start + arg + end;\n  } // raises: function(DOMException) {},\n});\n\n\ncore.Attr = function Attr(document, name, value) {\n  core.Node.call(this, document);\n  this._nodeValue = value;\n  this._name = name;\n  this._specified = (value) ? true : false;\n  this._tagName   = name;\n  this._nodeName  = name;\n\n  // Proactively set some level 2 information so that AttributeList\n  // can operate.\n  this._namespaceURI = null;\n  this._nodeName = name;\n  this._localName = name;\n  this._prefix = null;\n};\ninheritFrom(core.Node, core.Attr, {\n  nodeType : ATTRIBUTE_NODE,\n  get nodeValue() {\n    var val = '';\n    for (var i=0,len=this._childNodes.length;i<len;i++) {\n      var child = this._childNodes[i];\n      if (child.nodeType === ENTITY_REFERENCE_NODE) {\n        val += Array.prototype.reduce.call(child.childNodes, function(prev, c) {\n          return prev += (c.nodeValue || c);\n        }, '');\n      } else {\n        val += child.nodeValue;\n      }\n    }\n    return val;\n  },\n  set nodeValue(value) {\n    // readonly\n    if (this._readonly) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    this._childNodes._resetTo([this._ownerDocument.createTextNode(value)]);\n    this._modified();\n    this._specified = true;\n    var prev = this._nodeValue;\n    this._nodeValue = value;\n    if (this._ownerElement) {\n      this._ownerElement._attrModified(this._name, value, prev);\n    }\n  },\n  get name() { return this._name;},\n  get specified() { return this._specified },\n  get value() {\n    return this.nodeValue;\n  },\n  set value(value) {\n    this.nodeValue = value;\n  },\n  get parentNode() { return null;},\n  get attributes() { return null;},\n\n  insertBefore : function(/* Node */ newChild, /* Node*/ refChild){\n    if (newChild.nodeType === CDATA_SECTION_NODE ||\n        newChild.nodeType === ELEMENT_NODE)\n    {\n      throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n    }\n\n    return core.Node.prototype.insertBefore.call(this, newChild, refChild);\n  },\n\n  appendChild : function(/* Node */ arg) {\n\n    if (arg.nodeType === CDATA_SECTION_NODE ||\n        arg.nodeType === ELEMENT_NODE)\n    {\n      throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n    }\n\n    return core.Node.prototype.appendChild.call(this, arg);\n  }\n\n});\n\ncore.Text = function Text(document, text, readonly) {\n    core.CharacterData.call(this, document, text);\n    this._nodeName = \"#text\";\n    this._readonly = readonly ? true : false\n};\ninheritFrom(core.CharacterData, core.Text, {\n  nodeType : TEXT_NODE,\n  get attributes() { return null;},\n\n  /* returns Text */\n  splitText: function(offset) {\n\n    // readonly\n    if (this._readonly) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    if (offset < 0 || offset > this._nodeValue.length) {\n      throw new core.DOMException(INDEX_SIZE_ERR);\n    }\n\n    var newText = this._nodeValue.substring(offset);\n    this._nodeValue = this._nodeValue.substring(0, offset);\n    var newNode = this._ownerDocument.createTextNode(newText);\n\n    if(this._parentNode.lastChild === this) {\n      this._parentNode.appendChild(newNode);\n    } else {\n      this._parentNode.insertBefore(newNode, this.nextSibling);\n    }\n\n    return newNode;\n  }, //raises: function(DOMException) {},\n  toString: function() {\n    return this.nodeName;\n  }\n});\n\n\ncore.Comment = function Comment(document, text) {\n  core.Text.call(this, document, text);\n  this._nodeName = \"#comment\";\n  this._tagName  = \"#comment\";\n};\ninheritFrom(core.Text, core.Comment, {\n  nodeType : COMMENT_NODE\n});\n\n\ncore.CDATASection = function CDATASection(document, value) {\n  core.Text.call(this, document, value);\n  this._nodeName = \"#cdata-section\";\n};\ninheritFrom(core.Text, core.CDATASection, {\n  nodeType : CDATA_SECTION_NODE\n});\n\ncore.DocumentType = function DocumentType(document, name, entities, notations, attributes) {\n  core.Node.call(this, document);\n  this._name = name;\n  this._tagName = name;\n  this._nodeName = name;\n  this._entities = entities || new core.EntityNodeMap(document);\n  this._notations = notations || new core.NotationNodeMap(document);\n  this._parentNode = document;\n\n  core.markTreeReadonly(this._notations);\n\n  this._attributes = attributes || new AttributeList(document);\n};\ninheritFrom(core.Node, core.DocumentType, {\n  nodeType : DOCUMENT_TYPE_NODE,\n  get nodeValue() { return null;},\n  set nodeValue(unused) { /* do nothing */ },\n  get name() { return this._name;},\n  get entities() { return this._entities;},\n  get notations() { return this._notations;},\n  get attributes() { return null;}\n});\n\n\ncore.Notation = function Notation(document, name, publicId, systemId){\n  core.Node.call(this, document);\n  this._name = name;\n  this._nodeName = name;\n  this._publicId = publicId || null;\n  this._systemId = systemId || null;\n  this._nodeValue = null;\n};\ninheritFrom(core.Node, core.Notation, {\n  nodeType : NOTATION_NODE,\n  get publicId() { return this._publicId;},\n  get systemId() { return this._systemId;},\n  get name() { return this._name || this._nodeName;},\n  get attributes() { /* as per spec */ return null;},\n  set nodeValue(unused) { /* intentionally left blank */ },\n  get nodeValue() { return this._nodeValue;},\n});\n\n\ncore.Entity = function Entity(document, name) {\n  core.Node.call(this, document);\n  this._name = name;\n  this._nodeName = name;\n  this._tagName = name;\n  this._publicId = null;\n  this._systemId = null;\n  this._notationName = null;\n  this._readonly = true;\n};\ninheritFrom(core.Node, core.Entity, {\n  nodeType : ENTITY_NODE,\n  get nodeValue() { return null;},\n  set nodeValue(unused) {\n    // readonly\n    if (this._readonly === true) {\n      // TODO: is this needed?\n      // throw new DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n    /* do nothing */\n  },\n  get name() { return this._name },\n  get publicId() { return this._publicId;},\n  get systemId() { return this._systemId;},\n\n  set publicId(publicId) { this._publicId = publicId;},\n  set systemId(systemId) { this._systemId = systemId;},\n  set notationName(notationName) { this._notationName = notationName;},\n\n  get notationName() { return this._notationName;},\n  get attributes() { return null;},\n\n});\n\n\ncore.EntityReference = function EntityReference(document, entity) {\n  core.Node.call(this, document);\n  this._entity = entity;\n  this._nodeName = (entity) ? entity.name : null;\n  this._readonly = true;\n};\ninheritFrom(core.Node, core.EntityReference, {\n  nodeType : ENTITY_REFERENCE_NODE,\n  get nodeValue() { return (this._entity) ? this._entity.nodeValue : null;},\n  set nodeValue(unused) {\n    // readonly\n    if (this._readonly === true) {\n      // TODO: is this needed?\n      //throw new DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    /* do nothing */\n  },\n  get attributes() { return null;},\n\n  // Proxy to the entity\n  get nodeName() { return this._entityName;},\n  get firstChild() { return this._entity.firstChild || null;},\n  get childNodes() { return this._entity.childNodes;},\n  get lastChild() { return this._entity.lastChild || null;},\n\n});\n\nexports.dom = { \"level1\" : { \"core\" : core }};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level2/html.js":"var core                  = require(\"./core\").dom.level2.core,\n    events                = require(\"./events\").dom.level2.events,\n    applyDocumentFeatures = require('../browser/documentfeatures').applyDocumentFeatures,\n    defineGetter          = require('../utils').defineGetter,\n    defineSetter          = require('../utils').defineSetter,\n    inheritFrom           = require(\"../utils\").inheritFrom,\n    URL                   = require(\"url\"),\n    Path                  = require('path'),\n    fs                    = require(\"fs\"),\n    http                  = require('http'),\n    https                 = require('https');\n\n// modify cloned instance for more info check: https://github.com/tmpvar/jsdom/issues/325\ncore = Object.create(core);\n\n// Setup the javascript language processor\ncore.languageProcessors = {\n  javascript : require(\"./languages/javascript\").javascript\n};\n\n// TODO its own package? Pull request to Node?\nfunction resolveHref(baseUrl, href) {\n  // When switching protocols, the path doesn't get canonicalized (i.e. .s and ..s are still left):\n  // https://github.com/joyent/node/issues/5453\n  var intermediate = URL.resolve(baseUrl, href);\n\n  // This canonicalizes the path, at the cost of overwriting the hash.\n  var nextStep = URL.resolve(intermediate, '#');\n\n  // So, insert the hash back in, if there was one.\n  var parsed = URL.parse(intermediate);\n  var fixed = nextStep.slice(0, -1) + (parsed.hash || '');\n\n  // Finally, fix file:/// URLs on Windows, where Node removes their drive letters:\n  // https://github.com/joyent/node/issues/5452\n  if (/^file\\:\\/\\/\\/[a-z]\\:\\//i.test(baseUrl) && /^file\\:\\/\\/\\//.test(fixed) && !/^file\\:\\/\\/\\/[a-z]\\:\\//i.test(fixed)) {\n    fixed = fixed.replace(/^file\\:\\/\\/\\//, baseUrl.substring(0, 11));\n  }\n\n  return fixed;\n}\n\ncore.resourceLoader = {\n  load: function(element, href, callback) {\n    var ownerImplementation = element._ownerDocument.implementation;\n\n    if (ownerImplementation.hasFeature('FetchExternalResources', element.tagName.toLowerCase())) {\n      var full = this.resolve(element._ownerDocument, href);\n      var url = URL.parse(full);\n      if (ownerImplementation.hasFeature('SkipExternalResources', full)) {\n        return false;\n      }\n      if (url.hostname) {\n        this.download(url, element._ownerDocument._cookie, element._ownerDocument._cookieDomain, this.baseUrl(element._ownerDocument), this.enqueue(element, callback, full));\n      }\n      else {\n        this.readFile(url.pathname, this.enqueue(element, callback, full));\n      }\n    }\n  },\n  enqueue: function(element, callback, filename) {\n    var loader = this,\n        doc    = element.nodeType === core.Node.DOCUMENT_NODE ?\n                 element                :\n                 element._ownerDocument;\n\n    if (!doc._queue) {\n      return function() {};\n    }\n\n    return doc._queue.push(function(err, data) {\n      var ev = doc.createEvent('HTMLEvents');\n\n      if (!err) {\n        try {\n          callback.call(element, data, filename || doc.URL);\n          ev.initEvent('load', false, false);\n        }\n        catch(e) {\n          err = e;\n        }\n      }\n\n      if (err) {\n        ev.initEvent('error', false, false);\n        ev.error = err;\n      }\n\n      element.dispatchEvent(ev);\n    });\n  },\n\n  baseUrl: function(document) {\n    var baseElements = document.getElementsByTagName('base');\n    var baseUrl = document.URL;\n\n    if (baseElements.length > 0) {\n      var baseHref = baseElements.item(0).href;\n      if (baseHref) {\n        baseUrl = resolveHref(baseUrl, baseHref);\n      }\n    }\n\n    return baseUrl;\n  },\n  resolve: function(document, href) {\n    // if getAttribute returns null, there is no href\n    // lets resolve to an empty string (nulls are not expected farther up)\n    if (href === null) {\n      return '';\n    }\n\n    var baseUrl = this.baseUrl(document);\n\n    return resolveHref(baseUrl, href);\n  },\n  download: function(url, cookie, cookieDomain, referrer, callback) {\n    var path    = url.pathname + (url.search || ''),\n        options = {'method': 'GET', 'host': url.hostname, 'path': path},\n        request;\n    if (url.protocol === 'https:') {\n      options.port = url.port || 443;\n      request = https.request(options);\n    } else {\n      options.port = url.port || 80;\n      request = http.request(options);\n    }\n\n    // set header.\n    if (referrer) {\n        request.setHeader('Referer', referrer);\n    }\n    if (cookie) {\n      var host = url.host.split(':')[0];\n      if (host.indexOf(cookieDomain, host.length - cookieDomain.length) !== -1) {\n        request.setHeader('cookie', cookie);\n      }\n    }\n\n    request.on('response', function (response) {\n      var data = '';\n      function success () {\n        if ([301, 302, 303, 307].indexOf(response.statusCode) > -1) {\n          var redirect = URL.resolve(url, response.headers[\"location\"]);\n          core.resourceLoader.download(URL.parse(redirect), cookie, cookieDomain, referrer, callback);\n        } else {\n          callback(null, data);\n        }\n      }\n      response.setEncoding('utf8');\n      response.on('data', function (chunk) {\n        data += chunk.toString();\n      });\n      response.on('end', function() {\n        // According to node docs, 'close' can fire after 'end', but not\n        // vice versa.  Remove 'close' listener so we don't call success twice.\n        response.removeAllListeners('close');\n        success();\n      });\n      response.on('close', function (err) {\n        if (err) {\n          callback(err);\n        } else {\n          success();\n        }\n      });\n    });\n\n    request.on('error', callback);\n    request.end();\n  },\n  readFile: function(url, callback) {\n    fs.readFile(url.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, '$1:/').replace(/%20/g, ' '), 'utf8', callback);\n  }\n};\n\nfunction define(elementClass, def) {\n  var tagName = def.tagName,\n    tagNames = def.tagNames || (tagName? [tagName] : []),\n    parentClass = def.parentClass || core.HTMLElement,\n    attrs = def.attributes || [],\n    proto = def.proto || {};\n\n  var elem = core[elementClass] = function(document, name) {\n    parentClass.call(this, document, name || tagName.toUpperCase());\n    if (elem._init) {\n      elem._init.call(this);\n    }\n  };\n  elem._init = def.init;\n\n  inheritFrom(parentClass, elem, proto);\n\n  attrs.forEach(function(n) {\n      var prop = n.prop || n,\n        attr = n.attr || prop.toLowerCase();\n\n      if (!n.prop || n.read !== false) {\n        defineGetter(elem.prototype, prop, function() {\n          var s = this.getAttribute(attr);\n          if (n.type && n.type === 'boolean') {\n            return s !== null;\n          }\n          if (n.type && n.type === 'long') {\n            return +s;\n          }\n          if (typeof n === 'object' && n.normalize) { // see GH-491\n            return n.normalize(s);\n          }\n          if (s === null) {\n            s = '';\n          }\n          return s;\n        });\n      }\n\n      if (!n.prop || n.write !== false) {\n        defineSetter(elem.prototype, prop, function(val) {\n          if (!val) {\n            this.removeAttribute(attr);\n          }\n          else {\n            var s = val.toString();\n            if (typeof n === 'object' && n.normalize) {\n              s = n.normalize(s);\n            }\n            this.setAttribute(attr, s);\n          }\n        });\n      }\n  });\n\n  tagNames.forEach(function(tag) {\n    core.Document.prototype._elementBuilders[tag.toLowerCase()] = function(doc, s) {\n      var el = new elem(doc, s);\n\n      if (def.elementBuilder) {\n        return def.elementBuilder(el, doc, s);\n      }\n\n      return el;\n    };\n  });\n}\n\n\n\ncore.HTMLCollection = function HTMLCollection(element, query) {\n  this._keys = [];\n  core.NodeList.call(this, element, query);\n};\ninheritFrom(core.NodeList, core.HTMLCollection, {\n  namedItem: function(name) {\n    // Try property shortcut; should work in most cases\n    if (Object.prototype.hasOwnProperty.call(this, name)) {\n      return this[name];\n    }\n\n    var results = this._toArray(),\n        l       = results.length,\n        node,\n        matchingName = null;\n\n    for (var i=0; i<l; i++) {\n      node = results[i];\n      if (node.getAttribute('id') === name) {\n        return node;\n      } else if (node.getAttribute('name') === name) {\n        matchingName = node;\n      }\n    }\n    return matchingName;\n  },\n  toString: function() {\n    return '[ jsdom HTMLCollection ]: contains ' + this.length + ' items';\n  },\n  _resetTo: function(array) {\n    var i, _this = this;\n\n    for (i = 0; i < this._keys.length; ++i) {\n      delete this[this._keys[i]];\n    }\n    this._keys = [];\n\n    core.NodeList.prototype._resetTo.apply(this, arguments);\n\n    function testAttr(node, attr) {\n      var val = node.getAttribute(attr);\n      if (val && !Object.prototype.hasOwnProperty.call(_this, val)) {\n        _this[val] = node;\n        _this._keys.push(val);\n      }\n    }\n    for (i = 0; i < array.length; ++i) {\n      testAttr(array[i], 'id');\n    }\n    for (i = 0; i < array.length; ++i) {\n      testAttr(array[i], 'name');\n    }\n  }\n});\nObject.defineProperty(core.HTMLCollection.prototype, 'constructor', {\n  value: core.NodeList,\n  writable: true,\n  configurable: true\n});\n\ncore.HTMLOptionsCollection = core.HTMLCollection;\n\nfunction closest(e, tagName) {\n  tagName = tagName.toUpperCase();\n  while (e) {\n    if (e.nodeName.toUpperCase() === tagName ||\n        (e.tagName && e.tagName.toUpperCase() === tagName))\n    {\n      return e;\n    }\n    e = e._parentNode;\n  }\n  return null;\n}\n\nfunction descendants(e, tagName, recursive) {\n  var owner = recursive ? e._ownerDocument || e : e;\n  return new core.HTMLCollection(owner, core.mapper(e, function(n) {\n    return n.nodeName === tagName && typeof n._publicId == 'undefined';\n  }, recursive));\n}\n\nfunction firstChild(e, tagName) {\n  if (!e) {\n    return null;\n  }\n  var c = descendants(e, tagName, false);\n  return c.length > 0 ? c[0] : null;\n}\n\nfunction ResourceQueue(paused) {\n  this.paused = !!paused;\n}\nResourceQueue.prototype = {\n  push: function(callback) {\n    var q = this;\n    var item = {\n      prev: q.tail,\n      check: function() {\n        if (!q.paused && !this.prev && this.fired){\n          callback(this.err, this.data);\n          if (this.next) {\n            this.next.prev = null;\n            this.next.check();\n          }else{//q.tail===this\n      q.tail = null;\n    }\n        }\n      }\n    };\n    if (q.tail) {\n      q.tail.next = item;\n    }\n    q.tail = item;\n    return function(err, data) {\n      item.fired = 1;\n      item.err = err;\n      item.data = data;\n      item.check();\n    };\n  },\n  resume: function() {\n    if(!this.paused){\n      return;\n    }\n    this.paused = false;\n    var head = this.tail;\n    while(head && head.prev){\n      head = head.prev;\n    }\n    if(head){\n      head.check();\n    }\n  }\n};\n\ncore.HTMLDocument = function HTMLDocument(options) {\n  options = options || {};\n  if (!options.contentType) {\n    options.contentType = 'text/html';\n  }\n  core.Document.call(this, options);\n  this._referrer = options.referrer;\n  this._cookie = options.cookie;\n  this._cookieDomain = options.cookieDomain || '127.0.0.1';\n  this._URL = options.url || '/';\n  this._documentRoot = options.documentRoot || Path.dirname(this._URL);\n  this._queue = new ResourceQueue(options.deferClose);\n  this.readyState = 'loading';\n\n  // Add level2 features\n  this.implementation.addFeature('core'  , '2.0');\n  this.implementation.addFeature('html'  , '2.0');\n  this.implementation.addFeature('xhtml' , '2.0');\n  this.implementation.addFeature('xml'   , '2.0');\n};\n\ninheritFrom(core.Document, core.HTMLDocument, {\n  _referrer : \"\",\n  get referrer() {\n    return this._referrer || '';\n  },\n  get domain() {\n    return \"\";\n  },\n  _URL : \"\",\n  get URL() {\n    return this._URL;\n  },\n  get images() {\n    return this.getElementsByTagName('IMG');\n  },\n  get applets() {\n    return new core.HTMLCollection(this, core.mapper(this, function(el) {\n      if (el && el.tagName) {\n        var upper = el.tagName.toUpperCase();\n        if (upper === \"APPLET\") {\n          return true;\n        } else if (upper === \"OBJECT\" &&\n          el.getElementsByTagName('APPLET').length > 0)\n        {\n          return true;\n        }\n      }\n    }));\n  },\n  get links() {\n    return new core.HTMLCollection(this, core.mapper(this, function(el) {\n      if (el && el.tagName) {\n        var upper = el.tagName.toUpperCase();\n        if (upper === \"AREA\" || (upper === \"A\" && el.href)) {\n          return true;\n        }\n      }\n    }));\n  },\n  get forms() {\n    return this.getElementsByTagName('FORM');\n  },\n  get anchors() {\n    return this.getElementsByTagName('A');\n  },\n  open  : function() {\n    this._childNodes = new core.NodeList();\n    this._documentElement = null;\n    this._modified();\n  },\n  close : function() {\n    this._queue.resume();\n    // Set the readyState to 'complete' once all resources are loaded.\n    // As a side-effect the document's load-event will be dispatched.\n    core.resourceLoader.enqueue(this, function() {\n      this.readyState = 'complete';\n      var ev = this.createEvent('HTMLEvents');\n      ev.initEvent('DOMContentLoaded', false, false);\n      this.dispatchEvent(ev);\n    })(null, true);\n  },\n\n  write : function(text) {\n    if (this._writeAfterElement) {\n      // If called from an script element directly (during the first tick),\n      // the new elements are inserted right after that element.\n      var tempDiv       = this.createElement('div');\n      tempDiv.innerHTML = text;\n\n      var child    = tempDiv.firstChild;\n      var previous = this._writeAfterElement;\n      var parent   = this._writeAfterElement.parentNode;\n\n      while (child) {\n        var node = child;\n        child    = child.nextSibling;\n        parent.insertBefore(node, previous.nextSibling);\n        previous = node;\n      }\n    } else if (this.readyState === \"loading\") {\n      // During page loading, document.write appends to the current element\n      // Find the last child that has ben added to the document.\n      var node = this;\n      while (node.lastChild && node.lastChild.nodeType === this.ELEMENT_NODE) {\n        node = node.lastChild;\n      }\n      node.innerHTML = text || \"<html><head></head><body></body></html>\";\n    } else if (text) {\n      this.innerHTML = text;\n    }\n  },\n\n  writeln : function(text) {\n    this.write(text + '\\n');\n  },\n\n  getElementsByName : function(elementName) {\n    return new core.HTMLCollection(this, core.mapper(this, function(el) {\n      return (el.getAttribute && el.getAttribute(\"name\") === elementName);\n    }));\n  },\n\n  get title() {\n    var head = this.head,\n      title = head ? firstChild(head, 'TITLE') : null;\n    return title ? title.textContent : '';\n  },\n\n  set title(val) {\n    var title = firstChild(this.head, 'TITLE');\n    if (!title) {\n      title = this.createElement('TITLE');\n      var head = this.head;\n      if (!head) {\n        head = this.createElement('HEAD');\n        this.documentElement.insertBefore(head, this.documentElement.firstChild);\n      }\n      head.appendChild(title);\n    }\n    title.textContent = val;\n  },\n\n  get head() {\n    return firstChild(this.documentElement, 'HEAD');\n  },\n\n  set head(unused) { /* noop */ },\n\n  get body() {\n    var body = firstChild(this.documentElement, 'BODY');\n    if (!body) {\n      body = firstChild(this.documentElement, 'FRAMESET');\n    }\n    return body;\n  },\n\n  get documentElement() {\n    if (!this._documentElement) {\n      this._documentElement = firstChild(this, 'HTML');\n    }\n    return this._documentElement;\n  },\n\n  _cookie : \"\",\n  get cookie() {\n    var cookies = Array.isArray(this._cookie) ?\n      this._cookie :\n      (this._cookie && this._cookie.length > 0 ? [this._cookie] : []);\n\n    return cookies.map(function (x) {\n      return x.split(';')[0];\n    }).join('; ');\n  },\n  set cookie(val) {\n    var key = val.split('=')[0];\n    var cookies = Array.isArray(this._cookie) ?\n      this._cookie :\n      (this._cookie && this._cookie.length > 0 ? [this._cookie] : []);\n    for (var i = 0; i < cookies.length; i++) {\n      if (cookies[i].lastIndexOf(key + '=', 0) === 0) {\n        cookies[i] = val;\n        key = null;\n        break;\n      }\n    }\n    if (key) {\n      cookies.push(val);\n    }\n    if (cookies.length === 1) {\n      this._cookie = cookies[0];\n    } else {\n      this._cookie = cookies;\n    }\n    return val;\n  }\n});\n\ndefine('HTMLElement', {\n  parentClass: core.Element,\n  proto : {\n    // Add default event behavior (click link to navigate, click button to submit\n    // form, etc). We start by wrapping dispatchEvent so we can forward events to\n    // the element's _eventDefault function (only events that did not incur\n    // preventDefault).\n    dispatchEvent : function (event) {\n      var outcome = core.Node.prototype.dispatchEvent.call(this, event)\n\n      if (!event._preventDefault     &&\n          event.target._eventDefaults[event.type] &&\n          typeof event.target._eventDefaults[event.type] === 'function')\n      {\n        event.target._eventDefaults[event.type](event)\n      }\n      return outcome;\n    },\n    getBoundingClientRect: function () {\n      return {\n        bottom: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        top: 0,\n        width: 0\n      };\n    },\n    _eventDefaults : {}\n  },\n  attributes: [\n    'id',\n    'title',\n    'lang',\n    'dir',\n    {prop: 'className', attr: 'class', normalize: function(s) { return s || ''; }}\n  ]\n});\n\ncore.Document.prototype._defaultElementBuilder = function(document, tagName) {\n  return new core.HTMLElement(document, tagName);\n};\n\n// http://www.whatwg.org/specs/web-apps/current-work/#category-listed\nvar listedElements = /button|fieldset|input|keygen|object|select|textarea/i;\n\ndefine('HTMLFormElement', {\n  tagName: 'FORM',\n  proto: {\n    get elements() {\n      return new core.HTMLCollection(this._ownerDocument, core.mapper(this, function(e) {\n        return listedElements.test(e.nodeName) ; // TODO exclude <input type=\"image\">\n      }));\n    },\n    get length() {\n      return this.elements.length;\n    },\n    _dispatchSubmitEvent: function() {\n      var ev = this._ownerDocument.createEvent('HTMLEvents');\n      ev.initEvent('submit', true, true);\n      if (!this.dispatchEvent(ev)) {\n        this.submit();\n      };\n    },\n    submit: function() {\n    },\n    reset: function() {\n      this.elements._toArray().forEach(function(el) {\n        el.value = el.defaultValue;\n      });\n    }\n  },\n  attributes: [\n    'name',\n    {prop: 'acceptCharset', attr: 'accept-charset'},\n    'action',\n    'enctype',\n    'method',\n    'target'\n  ]\n});\n\ndefine('HTMLLinkElement', {\n  tagName: 'LINK',\n  proto: {\n    get href() {\n      return core.resourceLoader.resolve(this._ownerDocument, this.getAttribute('href'));\n    }\n  },\n  attributes: [\n    {prop: 'disabled', type: 'boolean'},\n    'charset',\n    'href',\n    'hreflang',\n    'media',\n    'rel',\n    'rev',\n    'target',\n    'type'\n  ]\n});\n\ndefine('HTMLMetaElement', {\n  tagName: 'META',\n  attributes: [\n    'content',\n    {prop: 'httpEquiv', attr: 'http-equiv'},\n    'name',\n    'scheme'\n  ]\n});\n\ndefine('HTMLHtmlElement', {\n  tagName: 'HTML',\n  attributes: [\n    'version'\n  ]\n});\n\ndefine('HTMLHeadElement', {\n  tagName: 'HEAD',\n  attributes: [\n    'profile'\n  ]\n});\n\ndefine('HTMLTitleElement', {\n  tagName: 'TITLE',\n  proto: {\n    get text() {\n      return this.innerHTML;\n    },\n    set text(s) {\n      this.innerHTML = s;\n    }\n  }\n});\n\ndefine('HTMLBaseElement', {\n  tagName: 'BASE',\n  attributes: [\n    'href',\n    'target'\n  ]\n});\n\n\n//**Deprecated**\ndefine('HTMLIsIndexElement', {\n  tagName : 'ISINDEX',\n  parentClass : core.Element,\n  proto : {\n    get form() {\n      return closest(this, 'FORM');\n    }\n  },\n  attributes : [\n    'prompt'\n  ]\n});\n\n\ndefine('HTMLStyleElement', {\n  tagName: 'STYLE',\n  attributes: [\n    {prop: 'disabled', type: 'boolean'},\n    'media',\n    'type',\n  ]\n});\n\ndefine('HTMLBodyElement', {\n  proto: (function() {\n    var proto = {};\n    // The body element's \"traditional\" event handlers are proxied to the\n    // window object.\n    // See: http://www.whatwg.org/specs/web-apps/current-work/#the-body-element\n    ['onafterprint', 'onbeforeprint', 'onbeforeunload', 'onblur', 'onerror',\n     'onfocus', 'onhashchange', 'onload', 'onmessage', 'onoffline', 'ononline',\n     'onpagehide', 'onpageshow', 'onpopstate', 'onresize', 'onscroll',\n     'onstorage', 'onunload'].forEach(function (name) {\n      defineSetter(proto, name, function (handler) {\n        this._ownerDocument.parentWindow[name] = handler;\n      });\n      defineGetter(proto, name, function () {\n        return this._ownerDocument.parentWindow[name];\n      });\n    });\n    return proto;\n  })(),\n  tagName: 'BODY',\n  attributes: [\n    'aLink',\n    'background',\n    'bgColor',\n    'link',\n    'text',\n    'vLink'\n  ]\n});\n\ndefine('HTMLSelectElement', {\n  tagName: 'SELECT',\n  proto: {\n    get options() {\n      return new core.HTMLOptionsCollection(this, core.mapper(this, function(n) {\n        return n.nodeName === 'OPTION';\n      }));\n    },\n\n    get length() {\n      return this.options.length;\n    },\n\n    get selectedIndex() {\n      return this.options._toArray().reduceRight(function(prev, option, i) {\n        return option.selected ? i : prev;\n      }, -1);\n    },\n\n    set selectedIndex(index) {\n      this.options._toArray().forEach(function(option, i) {\n        option.selected = i === index;\n      });\n    },\n\n    get value() {\n      var i = this.selectedIndex;\n      if (this.options.length && (i === -1)) {\n        i = 0;\n      }\n      if (i === -1) {\n        return '';\n      }\n      return this.options[i].value;\n    },\n\n    set value(val) {\n      var self = this;\n      this.options._toArray().forEach(function(option) {\n        if (option.value === val) {\n          option.selected = true;\n        } else {\n          if (!self.hasAttribute('multiple')) {\n            // Remove the selected bit from all other options in this group\n            // if the multiple attr is not present on the select\n            option.selected = false;\n          }\n        }\n      });\n    },\n\n    get form() {\n      return closest(this, 'FORM');\n    },\n\n    get type() {\n      return this.multiple ? 'select-multiple' : 'select-one';\n    },\n\n    add: function(opt, before) {\n      if (before) {\n        this.insertBefore(opt, before);\n      }\n      else {\n        this.appendChild(opt);\n      }\n    },\n\n    remove: function(index) {\n      var opts = this.options._toArray();\n      if (index >= 0 && index < opts.length) {\n        var el = opts[index];\n        el._parentNode.removeChild(el);\n      }\n    },\n\n    blur : function() {\n      this._ownerDocument.activeElement = this._ownerDocument.body;\n    },\n    focus : function() {\n      this._ownerDocument.activeElement = this;\n    }\n\n  },\n  attributes: [\n    {prop: 'disabled', type: 'boolean'},\n    {prop: 'multiple', type: 'boolean'},\n    'name',\n    {prop: 'size', type: 'long'},\n    {prop: 'tabIndex', type: 'long'},\n  ]\n});\n\ndefine('HTMLOptGroupElement', {\n  tagName: 'OPTGROUP',\n  attributes: [\n    {prop: 'disabled', type: 'boolean'},\n    'label'\n  ]\n});\n\ndefine('HTMLOptionElement', {\n  tagName: 'OPTION',\n  proto: {\n    _attrModified: function(name, value) {\n      if (name === 'selected') {\n        this.selected = this.defaultSelected;\n      }\n      core.HTMLElement.prototype._attrModified.call(this, arguments);\n    },\n    get form() {\n      return closest(this, 'FORM');\n    },\n    get defaultSelected() {\n      return this.getAttribute('selected') !== null;\n    },\n    set defaultSelected(s) {\n      if (s) this.setAttribute('selected', 'selected');\n      else this.removeAttribute('selected');\n    },\n    get text() {\n      return this.innerHTML;\n    },\n    get value() {\n      return (this.hasAttribute('value')) ? this.getAttribute('value') : this.innerHTML;\n    },\n    set value(val) {\n      this.setAttribute('value', val);\n    },\n    get index() {\n      return closest(this, 'SELECT').options._toArray().indexOf(this);\n    },\n    get selected() {\n      if (this._selected === undefined) {\n        this._selected = this.defaultSelected;\n      }\n\n      if (!this._selected && this.parentNode) {\n        var select = closest(this, 'SELECT');\n\n        if (select) {\n          var options = select.options;\n\n          if (options.item(0) === this && !select.hasAttribute('multiple')) {\n            var found = false, optArray = options._toArray();\n\n            for (var i = 1, l = optArray.length; i<l; i++) {\n              if (optArray[i]._selected) {\n                return false;\n              }\n            }\n            return true;\n          }\n        }\n      }\n\n      return this._selected;\n    },\n    set selected(s) {\n      // TODO: The 'selected' content attribute is the initial value of the\n      // IDL attribute, but the IDL attribute should not relfect the content\n      this._selected = !!s;\n      if (s) {\n        //Remove the selected bit from all other options in this select\n        var select = this._parentNode;\n        if (!select) return;\n        if (select.nodeName !== 'SELECT') {\n          select = select._parentNode;\n          if (!select) return;\n          if (select.nodeName !== 'SELECT') return;\n        }\n        if (!select.multiple) {\n          var o = select.options;\n          for (var i = 0; i < o.length; i++) {\n            if (o[i] !== this) {\n                o[i].selected = false;\n            }\n          }\n        }\n      }\n    }\n  },\n  attributes: [\n    {prop: 'disabled', type: 'boolean'},\n    'label'\n  ]\n});\n\ndefine('HTMLInputElement', {\n  tagName: 'INPUT',\n  init: function() {\n    if (!this.type) {\n      this.type = 'text';\n    }\n  },\n  proto: {\n    _initDefaultValue: function() {\n      if (this._defaultValue === undefined) {\n        var attr = this.getAttributeNode('value');\n        this._defaultValue = attr ? attr.value : null;\n      }\n      return this._defaultValue;\n    },\n    _initDefaultChecked: function() {\n      if (this._defaultChecked === undefined) {\n        this._defaultChecked = !!this.getAttribute('checked');\n      }\n      return this._defaultChecked;\n    },\n    get form() {\n      return closest(this, 'FORM');\n    },\n    get defaultValue() {\n      return this._initDefaultValue();\n    },\n    get defaultChecked() {\n      return this._initDefaultChecked();\n    },\n    get checked() {\n      return !!this._attributes.getNamedItem('checked');\n    },\n    set checked(checked) {\n      this._initDefaultChecked();\n      if (checked) {\n        this.setAttribute('checked', 'checked');\n        if (this.type === 'radio') {\n          var elements = this._ownerDocument.getElementsByName(this.name);\n          for (var i = 0; i < elements.length; i++) {\n            if (elements[i] !== this && elements[i].tagName === \"INPUT\" && elements[i].type === \"radio\") {\n              elements[i].checked = false;\n            }\n          }\n        }\n      } else {\n        this.removeAttribute('checked');\n      }\n    },\n    get value() {\n      return this.getAttribute('value');\n    },\n    set value(val) {\n      this._initDefaultValue();\n      if (val === null) {\n        this.removeAttribute('value');\n      }\n      else {\n        this.setAttribute('value', val);\n      }\n    },\n    get type() {\n        var type = this.getAttribute('type');\n        return type ? type : 'text';\n    },\n    set type(type) {\n        this.setAttribute('type', type);\n    },\n    blur : function() {\n      this._ownerDocument.activeElement = this._ownerDocument.body;\n    },\n    focus : function() {\n      this._ownerDocument.activeElement = this;\n    },\n    select: function() {\n    },\n\n    _dispatchClickEvent: function() {\n      var event = this._ownerDocument.createEvent(\"HTMLEvents\");\n      event.initEvent(\"click\", true, true);\n      this.dispatchEvent(event);\n    },\n\n    click: function() {\n      if (this.type === 'checkbox') {\n        this.checked = !this.checked;\n      }\n      else if (this.type === 'radio') {\n        this.checked = true;\n      }\n      else if (this.type === 'submit') {\n        var form = this.form;\n        if (form) {\n          form._dispatchSubmitEvent();\n        }\n      }\n      this._dispatchClickEvent();\n    }\n  },\n  attributes: [\n    'accept',\n    'accessKey',\n    'align',\n    'alt',\n    {prop: 'disabled', type: 'boolean'},\n    {prop: 'maxLength', type: 'long'},\n    'name',\n    {prop: 'readOnly', type: 'boolean'},\n    {prop: 'size', type: 'long'},\n    'src',\n    {prop: 'tabIndex', type: 'long'},\n    {prop: 'type', normalize: function(val) {\n        return val ? val.toLowerCase() : 'text';\n    }},\n    'useMap'\n  ]\n});\n\ndefine('HTMLTextAreaElement', {\n  tagName: 'TEXTAREA',\n  proto: {\n    _initDefaultValue: function() {\n      if (this._defaultValue === undefined) {\n        this._defaultValue = this.textContent;\n      }\n      return this._defaultValue;\n    },\n    get form() {\n      return closest(this, 'FORM');\n    },\n    get defaultValue() {\n      return this._initDefaultValue();\n    },\n    get value() {\n      return this.textContent;\n    },\n    set value(val) {\n      this._initDefaultValue();\n      this.textContent = val;\n    },\n    get type() {\n      return 'textarea';\n    },\n    blur : function() {\n      this._ownerDocument.activeElement = this._ownerDocument.body;\n    },\n    focus : function() {\n      this._ownerDocument.activeElement = this;\n    },\n    select: function() {\n    }\n  },\n  attributes: [\n    'accessKey',\n    {prop: 'cols', type: 'long'},\n    {prop: 'disabled', type: 'boolean'},\n    {prop: 'maxLength', type: 'long'},\n    'name',\n    {prop: 'readOnly', type: 'boolean'},\n    {prop: 'rows', type: 'long'},\n    {prop: 'tabIndex', type: 'long'}\n  ]\n});\n\ndefine('HTMLButtonElement', {\n  tagName: 'BUTTON',\n  proto: {\n    get form() {\n      return closest(this, 'FORM');\n    },\n    focus : function() {\n      this._ownerDocument.activeElement = this;\n    },\n    blur : function() {\n      this._ownerDocument.activeElement = this._ownerDocument.body;\n    }\n  },\n  attributes: [\n    'accessKey',\n    {prop: 'disabled', type: 'boolean'},\n    'name',\n    {prop: 'tabIndex', type: 'long'},\n    'type',\n    'value'\n  ]\n});\n\ndefine('HTMLLabelElement', {\n  tagName: 'LABEL',\n  proto: {\n    get form() {\n      return closest(this, 'FORM');\n    }\n  },\n  attributes: [\n    'accessKey',\n    {prop: 'htmlFor', attr: 'for'}\n  ]\n});\n\ndefine('HTMLFieldSetElement', {\n  tagName: 'FIELDSET',\n  proto: {\n    get form() {\n      return closest(this, 'FORM');\n    }\n  }\n});\n\ndefine('HTMLLegendElement', {\n  tagName: 'LEGEND',\n  proto: {\n    get form() {\n      return closest(this, 'FORM');\n    }\n  },\n  attributes: [\n    'accessKey',\n    'align'\n  ]\n});\n\ndefine('HTMLUListElement', {\n  tagName: 'UL',\n  attributes: [\n    {prop: 'compact', type: 'boolean'},\n    'type'\n  ]\n});\n\ndefine('HTMLOListElement', {\n  tagName: 'OL',\n  attributes: [\n    {prop: 'compact', type: 'boolean'},\n    {prop: 'start', type: 'long'},\n    'type'\n  ]\n});\n\ndefine('HTMLDListElement', {\n  tagName: 'DL',\n  attributes: [\n    {prop: 'compact', type: 'boolean'}\n  ]\n});\n\ndefine('HTMLDirectoryElement', {\n  tagName: 'DIR',\n  attributes: [\n    {prop: 'compact', type: 'boolean'}\n  ]\n});\n\ndefine('HTMLMenuElement', {\n  tagName: 'MENU',\n  attributes: [\n    {prop: 'compact', type: 'boolean'}\n  ]\n});\n\ndefine('HTMLLIElement', {\n  tagName: 'LI',\n  attributes: [\n    'type',\n    {prop: 'value', type: 'long'}\n  ]\n});\n\ndefine('HTMLCanvasElement', {\n  tagName: 'CANVAS',\n  attributes: [\n    'align'\n  ],\n  elementBuilder: function (element) {\n    // require node-canvas and catch the error if it blows up\n    try {\n      var canvas = new (require('canvas'))(0,0);\n      for (var attr in element) {\n        if (!canvas[attr]) {\n          canvas[attr] = element[attr];\n        }\n      }\n      return canvas;\n    } catch (e) {\n      return element;\n    }\n  }\n});\n\ndefine('HTMLDivElement', {\n  tagName: 'DIV',\n  attributes: [\n    'align'\n  ]\n});\n\ndefine('HTMLParagraphElement', {\n  tagName: 'P',\n  attributes: [\n    'align'\n  ]\n});\n\ndefine('HTMLHeadingElement', {\n  tagNames: ['H1','H2','H3','H4','H5','H6'],\n  attributes: [\n    'align'\n  ]\n});\n\ndefine('HTMLQuoteElement', {\n  tagNames: ['Q','BLOCKQUOTE'],\n  attributes: [\n    'cite'\n  ]\n});\n\ndefine('HTMLPreElement', {\n  tagName: 'PRE',\n  attributes: [\n    {prop: 'width', type: 'long'}\n  ]\n});\n\ndefine('HTMLBRElement', {\n  tagName: 'BR',\n  attributes: [\n    'clear'\n  ]\n});\n\ndefine('HTMLBaseFontElement', {\n  tagName: 'BASEFONT',\n  attributes: [\n    'color',\n    'face',\n    {prop: 'size', type: 'long'}\n  ]\n});\n\ndefine('HTMLFontElement', {\n  tagName: 'FONT',\n  attributes: [\n    'color',\n    'face',\n    'size'\n  ]\n});\n\ndefine('HTMLHRElement', {\n  tagName: 'HR',\n  attributes: [\n    'align',\n    {prop: 'noShade', type: 'boolean'},\n    'size',\n    'width'\n  ]\n});\n\ndefine('HTMLModElement', {\n  tagNames: ['INS', 'DEL'],\n  attributes: [\n    'cite',\n    'dateTime'\n  ]\n});\n\ndefine('HTMLAnchorElement', {\n  tagName: 'A',\n\n  proto: {\n    blur : function() {\n      this._ownerDocument.activeElement = this._ownerDocument.body;\n    },\n    focus : function() {\n      this._ownerDocument.activeElement = this;\n    },\n    get href() {\n      return core.resourceLoader.resolve(this._ownerDocument, this.getAttribute('href'));\n    },\n    get hostname() {\n      return URL.parse(this.href).hostname || '';\n    },\n    get host() {\n      return URL.parse(this.href).host || '';\n    },\n    get origin() {\n      var proto = URL.parse(this.href).protocol;\n\n      if (proto !== undefined && proto !== null) {\n        proto += '//';\n      }\n\n      return proto + URL.parse(this.href).host || '';\n    },\n    get port() {\n      return URL.parse(this.href).port || '';\n    },\n    get protocol() {\n      var protocol = URL.parse(this.href).protocol;\n      return (protocol == null) ? ':' : protocol;\n    },\n    get password() {\n      var auth = URL.parse(this.href).auth;\n      return auth.substr(auth.indexOf(':') + 1);\n    },\n    get pathname() {\n      return URL.parse(this.href).pathname || '';\n    },\n    get username() {\n      var auth = URL.parse(this.href).auth;\n      return auth.substr(0, auth.indexOf(':'));\n    },\n    get search() {\n      return URL.parse(this.href).search || '';\n    },\n    get hash() {\n      return URL.parse(this.href).hash || '';\n    }\n  },\n  attributes: [\n    'accessKey',\n    'charset',\n    'coords',\n    {prop: 'href', type: 'string', read: false},\n    'hreflang',\n    'name',\n    'rel',\n    'rev',\n    'shape',\n    {prop: 'tabIndex', type: 'long'},\n    'target',\n    'type'\n  ]\n});\n\ndefine('HTMLImageElement', {\n  tagName: 'IMG',\n  proto: {\n    _attrModified: function(name, value, oldVal) {\n      if (name == 'src' && value !== oldVal) {\n        core.resourceLoader.enqueue(this, function() {})();\n      }\n    },\n    get src() {\n      return core.resourceLoader.resolve(this._ownerDocument, this.getAttribute('src'));\n    }\n  },\n  attributes: [\n    'name',\n    'align',\n    'alt',\n    'border',\n    {prop: 'height', type: 'long'},\n    {prop: 'hspace', type: 'long'},\n    {prop: 'isMap', type: 'boolean'},\n    'longDesc',\n    {prop: 'src', type: 'string', read: false},\n    'useMap',\n    {prop: 'vspace', type: 'long'},\n    {prop: 'width', type: 'long'}\n  ]\n});\n\ndefine('HTMLObjectElement', {\n  tagName: 'OBJECT',\n  proto: {\n    get form() {\n      return closest(this, 'FORM');\n    },\n    get contentDocument() {\n      return null;\n    }\n  },\n  attributes: [\n    'code',\n    'align',\n    'archive',\n    'border',\n    'codeBase',\n    'codeType',\n    'data',\n    {prop: 'declare', type: 'boolean'},\n    {prop: 'height',  type: 'long'},\n    {prop: 'hspace',  type: 'long'},\n    'name',\n    'standby',\n    {prop: 'tabIndex', type: 'long'},\n    'type',\n    'useMap',\n    {prop: 'vspace', type: 'long'},\n    {prop: 'width', type: 'long'}\n  ]\n});\n\ndefine('HTMLParamElement', {\n  tagName: 'PARAM',\n  attributes: [\n    'name',\n    'type',\n    'value',\n    'valueType'\n  ]\n});\n\ndefine('HTMLAppletElement', {\n  tagName: 'APPLET',\n  attributes: [\n    'align',\n    'alt',\n    'archive',\n    'code',\n    'codeBase',\n    'height',\n    {prop: 'hspace', type: 'long'},\n    'name',\n    'object',\n    {prop: 'vspace', type: 'long'},\n    'width'\n  ]\n});\n\ndefine('HTMLMapElement', {\n  tagName: 'MAP',\n  proto: {\n    get areas() {\n      return this.getElementsByTagName(\"AREA\");\n    }\n  },\n  attributes: [\n    'name'\n  ]\n});\n\ndefine('HTMLAreaElement', {\n  tagName: 'AREA',\n  attributes: [\n    'accessKey',\n    'alt',\n    'coords',\n    'href',\n    {prop: 'noHref', type: 'boolean'},\n    'shape',\n    {prop: 'tabIndex', type: 'long'},\n    'target'\n  ]\n});\n\ndefine('HTMLScriptElement', {\n  tagName: 'SCRIPT',\n  init: function() {\n    this.addEventListener('DOMNodeInsertedIntoDocument', function() {\n      if (this.src) {\n        core.resourceLoader.load(this, this.src, this._eval);\n      }\n      else {\n        var src = this.sourceLocation || {},\n            filename = src.file || this._ownerDocument.URL;\n\n        if (src) {\n          filename += ':' + src.line + ':' + src.col;\n        }\n        filename += '<script>';\n\n        core.resourceLoader.enqueue(this, this._eval, filename)(null, this.text);\n      }\n    });\n  },\n  proto: {\n    _eval: function(text, filename) {\n      if (this._ownerDocument.implementation.hasFeature(\"ProcessExternalResources\", \"script\") &&\n          this.language                                                                      &&\n          core.languageProcessors[this.language])\n      {\n        this._ownerDocument._writeAfterElement = this;\n        core.languageProcessors[this.language](this, text, filename);\n        delete this._ownerDocument._writeAfterElement;\n      }\n    },\n    get language() {\n      var type = this.type || \"text/javascript\";\n      return type.split(\"/\").pop().toLowerCase();\n    },\n    get text() {\n      var i=0, children = this.childNodes, l = children.length, ret = [];\n\n      for (i; i<l; i++) {\n        ret.push(children.item(i).nodeValue);\n      }\n\n      return ret.join(\"\");\n    },\n    set text(text) {\n      while (this.childNodes.length) {\n        this.removeChild(this.childNodes[0]);\n      }\n      this.appendChild(this._ownerDocument.createTextNode(text));\n    }\n  },\n  attributes : [\n    {prop: 'defer', 'type': 'boolean'},\n    'htmlFor',\n    'event',\n    'charset',\n    'type',\n    'src'\n  ]\n})\n\ndefine('HTMLTableElement', {\n  tagName: 'TABLE',\n  proto: {\n    get caption() {\n      return firstChild(this, 'CAPTION');\n    },\n    get tHead() {\n      return firstChild(this, 'THEAD');\n    },\n    get tFoot() {\n      return firstChild(this, 'TFOOT');\n    },\n    get rows() {\n      if (!this._rows) {\n        var table = this;\n        this._rows = new core.HTMLCollection(this._ownerDocument, function() {\n          var sections = [table.tHead].concat(table.tBodies._toArray(), table.tFoot).filter(function(s) { return !!s });\n\n          if (sections.length === 0) {\n            return core.mapDOMNodes(table, false, function(el) {\n              return el.tagName === 'TR';\n            });\n          }\n\n          return sections.reduce(function(prev, s) {\n            return prev.concat(s.rows._toArray());\n          }, []);\n\n        });\n      }\n      return this._rows;\n    },\n    get tBodies() {\n      if (!this._tBodies) {\n        this._tBodies = descendants(this, 'TBODY', false);\n      }\n      return this._tBodies;\n    },\n    createTHead: function() {\n      var el = this.tHead;\n      if (!el) {\n        el = this._ownerDocument.createElement('THEAD');\n        this.appendChild(el);\n      }\n      return el;\n    },\n    deleteTHead: function() {\n      var el = this.tHead;\n      if (el) {\n        el._parentNode.removeChild(el);\n      }\n    },\n    createTFoot: function() {\n      var el = this.tFoot;\n      if (!el) {\n        el = this._ownerDocument.createElement('TFOOT');\n        this.appendChild(el);\n      }\n      return el;\n    },\n    deleteTFoot: function() {\n      var el = this.tFoot;\n      if (el) {\n        el._parentNode.removeChild(el);\n      }\n    },\n    createCaption: function() {\n      var el = this.caption;\n      if (!el) {\n        el = this._ownerDocument.createElement('CAPTION');\n        this.appendChild(el);\n      }\n      return el;\n    },\n    deleteCaption: function() {\n      var c = this.caption;\n      if (c) {\n        c._parentNode.removeChild(c);\n      }\n    },\n    insertRow: function(index) {\n      var tr = this._ownerDocument.createElement('TR');\n      if (this.childNodes.length === 0) {\n        this.appendChild(this._ownerDocument.createElement('TBODY'));\n      }\n      var rows = this.rows._toArray();\n      if (index < -1 || index > rows.length) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      if (index === -1 || (index === 0 && rows.length === 0)) {\n        this.tBodies.item(0).appendChild(tr);\n      }\n      else if (index === rows.length) {\n        var ref = rows[index-1];\n        ref._parentNode.appendChild(tr);\n      }\n      else {\n        var ref = rows[index];\n        ref._parentNode.insertBefore(tr, ref);\n      }\n      return tr;\n    },\n    deleteRow: function(index) {\n      var rows = this.rows._toArray(), l = rows.length;\n      if (index === -1) {\n        index = l-1;\n      }\n      if (index < 0 || index >= l) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      var tr = rows[index];\n      tr._parentNode.removeChild(tr);\n    }\n  },\n  attributes: [\n    'align',\n    'bgColor',\n    'border',\n    'cellPadding',\n    'cellSpacing',\n    'frame',\n    'rules',\n    'summary',\n    'width'\n  ]\n});\n\ndefine('HTMLTableCaptionElement', {\n  tagName: 'CAPTION',\n  attributes: [\n    'align'\n  ]\n});\n\ndefine('HTMLTableColElement', {\n  tagNames: ['COL','COLGROUP'],\n  attributes: [\n    'align',\n    {prop: 'ch', attr: 'char'},\n    {prop: 'chOff', attr: 'charoff'},\n    {prop: 'span', type: 'long'},\n    'vAlign',\n    'width',\n  ]\n});\n\ndefine('HTMLTableSectionElement', {\n  tagNames: ['THEAD','TBODY','TFOOT'],\n  proto: {\n    get rows() {\n      if (!this._rows) {\n        this._rows = descendants(this, 'TR', false);\n      }\n      return this._rows;\n    },\n    insertRow: function(index) {\n      var tr = this._ownerDocument.createElement('TR');\n      var rows = this.rows._toArray();\n      if (index < -1 || index > rows.length) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      if (index === -1 || index === rows.length) {\n        this.appendChild(tr);\n      }\n      else {\n        var ref = rows[index];\n        this.insertBefore(tr, ref);\n      }\n      return tr;\n    },\n    deleteRow: function(index) {\n      var rows = this.rows._toArray();\n      if (index === -1) {\n        index = rows.length-1;\n      }\n      if (index < 0 || index >= rows.length) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      var tr = this.rows[index];\n      this.removeChild(tr);\n    }\n  },\n  attributes: [\n    'align',\n    {prop: 'ch', attr: 'char'},\n    {prop: 'chOff', attr: 'charoff'},\n    {prop: 'span', type: 'long'},\n    'vAlign',\n    'width',\n  ]\n});\n\ndefine('HTMLTableRowElement', {\n  tagName: 'TR',\n  proto: {\n    get cells() {\n      if (!this._cells) {\n        this._cells = new core.HTMLCollection(this, core.mapper(this, function(n) {\n          return n.nodeName === 'TD' || n.nodeName === 'TH';\n        }, false));\n      }\n      return this._cells;\n    },\n    get rowIndex() {\n      var table = closest(this, 'TABLE');\n      return table ? table.rows._toArray().indexOf(this) : -1;\n    },\n\n    get sectionRowIndex() {\n      return this._parentNode.rows._toArray().indexOf(this);\n    },\n    insertCell: function(index) {\n      var td = this._ownerDocument.createElement('TD');\n      var cells = this.cells._toArray();\n      if (index < -1 || index > cells.length) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      if (index === -1 || index === cells.length) {\n        this.appendChild(td);\n      }\n      else {\n        var ref = cells[index];\n        this.insertBefore(td, ref);\n      }\n      return td;\n    },\n    deleteCell: function(index) {\n      var cells = this.cells._toArray();\n      if (index === -1) {\n        index = cells.length-1;\n      }\n      if (index < 0 || index >= cells.length) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      var td = this.cells[index];\n      this.removeChild(td);\n    }\n  },\n  attributes: [\n    'align',\n    'bgColor',\n    {prop: 'ch', attr: 'char'},\n    {prop: 'chOff', attr: 'charoff'},\n    'vAlign'\n  ]\n});\n\ndefine('HTMLTableCellElement', {\n  tagNames: ['TH','TD'],\n  proto: {\n    _headers: null,\n    set headers(h) {\n      if (h === '') {\n        //Handle resetting headers so the dynamic getter returns a query\n        this._headers = null;\n        return;\n      }\n      if (!(h instanceof Array)) {\n        h = [h];\n      }\n      this._headers = h;\n    },\n    get headers() {\n      if (this._headers) {\n        return this._headers.join(' ');\n      }\n      var cellIndex = this.cellIndex,\n          headings  = [],\n          siblings  = this._parentNode.getElementsByTagName(this.tagName);\n\n      for (var i=0; i<siblings.length; i++) {\n        if (siblings.item(i).cellIndex >= cellIndex) {\n          break;\n        }\n        headings.push(siblings.item(i).id);\n      }\n      this._headers = headings;\n      return headings.join(' ');\n    },\n    get cellIndex() {\n      return closest(this, 'TR').cells._toArray().indexOf(this);\n    }\n  },\n  attributes: [\n    'abbr',\n    'align',\n    'axis',\n    'bgColor',\n    {prop: 'ch', attr: 'char'},\n    {prop: 'chOff', attr: 'charoff'},\n    {prop: 'colSpan', type: 'long'},\n    'height',\n    {prop: 'noWrap', type: 'boolean'},\n    {prop: 'rowSpan', type: 'long'},\n    'scope',\n    'vAlign',\n    'width'\n  ]\n});\n\ndefine('HTMLFrameSetElement', {\n  tagName: 'FRAMESET',\n  attributes: [\n    'cols',\n    'rows'\n  ]\n});\n\nfunction loadFrame (frame) {\n  if (frame._contentDocument) {\n    // We don't want to access document.parentWindow, since the getter will\n    // cause a new window to be allocated if it doesn't exist.  Probe the\n    // private variable instead.\n    if (frame._contentDocument._parentWindow) {\n      // close calls delete on its document.\n      frame._contentDocument.parentWindow.close();\n    } else {\n      delete frame._contentDocument;\n    }\n  }\n\n  var src = frame.src.trim() === '' ? 'about:blank' : frame.src;\n  var parentDoc = frame._ownerDocument;\n\n  // If the URL can't be resolved or the src attribute is missing / blank,\n  // then url should be set to the string \"about:blank\".\n  // (http://www.whatwg.org/specs/web-apps/current-work/#the-iframe-element)\n  var url = core.resourceLoader.resolve(parentDoc, src);\n  var contentDoc = frame._contentDocument = new core.HTMLDocument({\n    url: url,\n    documentRoot: Path.dirname(url)\n  });\n  applyDocumentFeatures(contentDoc, parentDoc.implementation._features);\n\n  var parent = parentDoc.parentWindow;\n  var contentWindow = contentDoc.parentWindow;\n  contentWindow.parent = parent;\n  contentWindow.top = parent.top;\n\n  // Handle about:blank with a simulated load of an empty document.\n  if(url === 'about:blank') {\n    core.resourceLoader.enqueue(frame, function() {\n      contentDoc.write();\n      contentDoc.close();\n    })();\n  } else {\n    core.resourceLoader.load(frame, url, function(html, filename) {\n      contentDoc.write(html);\n      contentDoc.close();\n    });\n  }\n}\n\ndefine('HTMLFrameElement', {\n  tagName: 'FRAME',\n  init : function () {\n    // Set up the frames array.  window.frames really just returns a reference\n    // to the window object, so the frames array is just implemented as indexes\n    // on the window.\n    var parent = this._ownerDocument.parentWindow;\n    var frameID = parent._length++;\n    var self = this;\n    defineGetter(parent, frameID, function () {\n      return self.contentWindow;\n    });\n\n    // The contentDocument/contentWindow shouldn't be created until the frame\n    // is inserted:\n    // \"When an iframe element is first inserted into a document, the user\n    //  agent must create a nested browsing context, and then process the\n    //  iframe attributes for the first time.\"\n    //  (http://www.whatwg.org/specs/web-apps/current-work/#the-iframe-element)\n    this._initInsertListener = function () {\n      loadFrame(self);\n    };\n    this.addEventListener('DOMNodeInsertedIntoDocument', this._initInsertListener, false);\n  },\n  proto: {\n    _attrModified: function(name, value, oldVal) {\n      core.HTMLElement.prototype._attrModified.call(this, name, value, oldVal);\n      var self = this;\n      if (name === 'name') {\n        // Remove named frame access.\n        if (oldVal) {\n          this._ownerDocument.parentWindow._frame(oldVal);\n        }\n        // Set up named frame access.\n        if (value) {\n          this._ownerDocument.parentWindow._frame(value, this);\n        }\n      } else if (name === 'src') {\n        // Page we don't fetch the page until the node is inserted. This at\n        // least seems to be the way Chrome does it.\n        if (!this._attachedToDocument) {\n          if (!this._waitingOnInsert) {\n            // First, remove the listener added in 'init'.\n            this.removeEventListener('DOMNodeInsertedIntoDocument',\n                                     this._initInsertListener, false)\n\n            // If we aren't already waiting on an insert, add a listener.\n            // This guards against src being set multiple times before the frame\n            // is inserted into the document - we don't want to register multiple\n            // callbacks.\n            this.addEventListener('DOMNodeInsertedIntoDocument', function loader () {\n              self.removeEventListener('DOMNodeInsertedIntoDocument', loader, false);\n              this._waitingOnInsert = false;\n              loadFrame(self);\n            }, false);\n            this._waitingOnInsert = true;\n          }\n        } else {\n          loadFrame(self);\n        }\n      }\n    },\n    _contentDocument : null,\n    get contentDocument() {\n      if (this._contentDocument == null) {\n        this._contentDocument = new core.HTMLDocument();\n      }\n      return this._contentDocument;\n    },\n    get contentWindow() {\n      return this.contentDocument.parentWindow;\n    }\n  },\n  attributes: [\n    'frameBorder',\n    'longDesc',\n    'marginHeight',\n    'marginWidth',\n    'name',\n    {prop: 'noResize', type: 'boolean'},\n    'scrolling',\n    {prop: 'src', type: 'string', write: false}\n  ]\n});\n\ndefine('HTMLIFrameElement', {\n  tagName: 'IFRAME',\n  parentClass: core.HTMLFrameElement,\n  attributes: [\n    'align',\n    'frameBorder',\n    'height',\n    'longDesc',\n    'marginHeight',\n    'marginWidth',\n    'name',\n    'scrolling',\n    'src',\n    'width'\n  ]\n});\n\nexports.define = define;\nexports.dom = {\n  level2 : {\n    html : core\n  }\n}\n\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level2/events.js":"/* DOM Level2 Events implemented as described here:\n *\n * http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html\n *\n */\nvar core = require(\"./core\").dom.level2.core,\n    utils = require(\"../utils\"),\n    defineGetter = utils.defineGetter,\n    defineSetter = utils.defineSetter,\n    inheritFrom = utils.inheritFrom;\n\n// modify cloned instance for more info check: https://github.com/tmpvar/jsdom/issues/325\ncore = Object.create(core);\n\nvar events = {};\n\nevents.EventException = function() {\n    if (arguments.length > 0) {\n        this._code = arguments[0];\n    } else {\n        this._code = 0;\n    }\n    if (arguments.length > 1) {\n        this._message = arguments[1];\n    } else {\n        this._message = \"Unspecified event type\";\n    }\n    Error.call(this, this._message);\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, events.EventException);\n    }\n};\ninheritFrom(Error, events.EventException, {\n  UNSPECIFIED_EVENT_TYPE_ERR : 0,\n  get code() { return this._code;}\n});\n\nevents.Event = function(eventType) {\n    this._eventType = eventType;\n    this._type = null;\n    this._bubbles = null;\n    this._cancelable = null;\n    this._target = null;\n    this._currentTarget = null;\n    this._eventPhase = null;\n    this._timeStamp = null;\n    this._preventDefault = false;\n    this._stopPropagation = false;\n};\nevents.Event.prototype = {\n    initEvent: function(type, bubbles, cancelable) {\n        this._type = type;\n        this._bubbles = bubbles;\n        this._cancelable = cancelable;\n    },\n    preventDefault: function() {\n        if (this._cancelable) {\n            this._preventDefault = true;\n        }\n    },\n    stopPropagation: function() {\n        this._stopPropagation = true;\n    },\n    CAPTURING_PHASE : 1,\n    AT_TARGET       : 2,\n    BUBBLING_PHASE  : 3,\n    get eventType() { return this._eventType; },\n    get type() { return this._type; },\n    get bubbles() { return this._bubbles; },\n    get cancelable() { return this._cancelable; },\n    get target() { return this._target; },\n    get currentTarget() { return this._currentTarget; },\n    get eventPhase() { return this._eventPhase; },\n    get timeStamp() { return this._timeStamp; }\n};\n\n\nevents.UIEvent = function(eventType) {\n    events.Event.call(this, eventType);\n    this.view = null;\n    this.detail = null;\n};\ninheritFrom(events.Event, events.UIEvent, {\n    initUIEvent: function(type, bubbles, cancelable, view, detail) {\n        this.initEvent(type, bubbles, cancelable);\n        this.view = view;\n        this.detail = detail;\n    },\n});\n\n\nevents.MouseEvent = function(eventType) {\n    events.UIEvent.call(this, eventType);\n    this.screenX = null;\n    this.screenY = null;\n    this.clientX = null;\n    this.clientY = null;\n    this.ctrlKey = null;\n    this.shiftKey = null;\n    this.altKey = null;\n    this.metaKey = null;\n    this.button = null;\n    this.relatedTarget = null;\n};\ninheritFrom(events.UIEvent, events.MouseEvent, {\n    initMouseEvent:   function(type,\n                               bubbles,\n                               cancelable,\n                               view,\n                               detail,\n                               screenX,\n                               screenY,\n                               clientX,\n                               clientY,\n                               ctrlKey,\n                               altKey,\n                               shiftKey,\n                               metaKey,\n                               button,\n                               relatedTarget) {\n        this.initUIEvent(type, bubbles, cancelable, view, detail);\n        this.screenX  = screenX\n        this.screenY  = screenY\n        this.clientX  = clientX\n        this.clientY  = clientY\n        this.ctrlKey  = ctrlKey\n        this.shiftKey  = shiftKey\n        this.altKey  = altKey\n        this.metaKey  = metaKey\n        this.button  = button\n        this.relatedTarget  = relatedTarget\n    }\n});\n\n\nevents.MutationEvent = function(eventType) {\n    events.Event.call(this, eventType);\n    this.relatedNode = null;\n    this.prevValue = null;\n    this.newValue = null;\n    this.attrName = null;\n    this.attrChange = null;\n};\ninheritFrom(events.Event, events.MutationEvent, {\n    initMutationEvent:   function(type,\n                                  bubbles,\n                                  cancelable,\n                                  relatedNode,\n                                  prevValue,\n                                  newValue,\n                                  attrName,\n                                  attrChange) {\n        this.initEvent(type, bubbles, cancelable);\n        this.relatedNode = relatedNode;\n        this.prevValue = prevValue;\n        this.newValue = newValue;\n        this.attrName = attrName;\n        this.attrChange = attrChange;\n    },\n    MODIFICATION : 1,\n    ADDITION     : 2,\n    REMOVAL      : 3\n});\n\nevents.EventTarget = function() {};\n\nevents.EventTarget.getListeners = function getListeners(target, type, capturing) {\n    var listeners = target._listeners\n            && target._listeners[type]\n            && target._listeners[type][capturing] || [];\n    if (!capturing) {\n        var traditionalHandler = target['on' + type];\n        if (traditionalHandler) {\n            var implementation = (target._ownerDocument ? target._ownerDocument.implementation\n                                                        : target.document.implementation);\n\n            if (implementation.hasFeature('ProcessExternalResources', 'script')) {\n                listeners.push(traditionalHandler);\n            }\n        }\n    }\n    return listeners;\n};\n\nevents.EventTarget.dispatch = function dispatch(event, iterator, capturing) {\n    var listeners,\n        currentListener,\n        target = iterator();\n\n    while (target && !event._stopPropagation) {\n        listeners = events.EventTarget.getListeners(target, event._type, capturing);\n        currentListener = listeners.length;\n        while (currentListener--) {\n            event._currentTarget = target;\n            try {\n              listeners[currentListener].call(target, event);\n            } catch (e) {\n              target.raise(\n                'error', \"Dispatching event '\" + event._type + \"' failed\",\n                {error: e, event: event}\n              );\n            }\n        }\n        target = iterator();\n    }\n    return !event._stopPropagation;\n};\n\nevents.EventTarget.forwardIterator = function forwardIterator(list) {\n  var i = 0, len = list.length;\n  return function iterator() { return i < len ? list[i++] : null };\n};\n\nevents.EventTarget.backwardIterator = function backwardIterator(list) {\n  var i = list.length;\n  return function iterator() { return i >=0 ? list[--i] : null };\n};\n\nevents.EventTarget.singleIterator = function singleIterator(obj) {\n  var i = 1;\n  return function iterator() { return i-- ? obj : null };\n};\n\nevents.EventTarget.prototype = {\n    addEventListener: function(type, listener, capturing) {\n        this._listeners = this._listeners || {};\n        var listeners = this._listeners[type] || {};\n        capturing = (capturing === true);\n        var capturingListeners = listeners[capturing] || [];\n        for (var i=0; i < capturingListeners.length; i++) {\n            if (capturingListeners[i] === listener) {\n                return;\n            }\n        }\n        capturingListeners.push(listener);\n        listeners[capturing] = capturingListeners;\n        this._listeners[type] = listeners;\n    },\n\n    removeEventListener: function(type, listener, capturing) {\n        var listeners  = this._listeners && this._listeners[type];\n        if (!listeners) return;\n        var capturingListeners = listeners[(capturing === true)];\n        if (!capturingListeners) return;\n        for (var i=0; i < capturingListeners.length; i++) {\n            if (capturingListeners[i] === listener) {\n                capturingListeners.splice(i, 1);\n                return;\n            }\n        }\n    },\n\n    dispatchEvent: function(event) {\n        if (event == null) {\n            throw new events.EventException(0, \"Null event\");\n        }\n        if (event._type == null || event._type == \"\") {\n            throw new events.EventException(0, \"Uninitialized event\");\n        }\n\n        var targetList = [];\n\n        event._target = this;\n\n        //per the spec we gather the list of targets first to ensure\n        //against dom modifications during actual event dispatch\n        var target = this,\n            targetParent = target._parentNode;\n        while (targetParent) {\n            targetList.push(targetParent);\n            target = targetParent;\n            targetParent = target._parentNode;\n        }\n        targetParent = target._parentWindow;\n        if (targetParent) {\n            targetList.push(targetParent);\n        }\n\n        var iterator = events.EventTarget.backwardIterator(targetList);\n\n        event._eventPhase = event.CAPTURING_PHASE;\n        if (!events.EventTarget.dispatch(event, iterator, true)) return event._preventDefault;\n\n        iterator = events.EventTarget.singleIterator(event._target);\n        event._eventPhase = event.AT_TARGET;\n        if (!events.EventTarget.dispatch(event, iterator, false)) return event._preventDefault;\n\n        if (event._bubbles && !event._stopPropagation) {\n            var i = 0;\n            iterator = events.EventTarget.forwardIterator(targetList);\n            event._eventPhase = event.BUBBLING_PHASE;\n            events.EventTarget.dispatch(event, iterator, false);\n        }\n\n        return event._preventDefault;\n    }\n\n};\n\n// Reinherit class heirarchy with EventTarget at its root\ninheritFrom(events.EventTarget, core.Node, core.Node.prototype);\n\n// Node\ninheritFrom(core.Node, core.Attr, core.Attr.prototype);\ninheritFrom(core.Node, core.CharacterData, core.CharacterData.prototype);\ninheritFrom(core.Node, core.Document, core.Document.prototype);\ninheritFrom(core.Node, core.DocumentFragment, core.DocumentFragment.prototype);\ninheritFrom(core.Node, core.DocumentType, core.DocumentType.prototype);\ninheritFrom(core.Node, core.Element, core.Element.prototype);\ninheritFrom(core.Node, core.Entity, core.Entity.prototype);\ninheritFrom(core.Node, core.EntityReference, core.EntityReference.prototype);\ninheritFrom(core.Node, core.Notation, core.Notation.prototype);\ninheritFrom(core.Node, core.ProcessingInstruction, core.ProcessingInstruction.prototype);\n\n// CharacterData\ninheritFrom(core.CharacterData, core.Text, core.Text.prototype);\n\n// Text\ninheritFrom(core.Text, core.CDATASection, core.CDATASection.prototype);\ninheritFrom(core.Text, core.Comment, core.Comment.prototype);\n\nfunction getDocument(el) {\n  return el.nodeType == core.Node.DOCUMENT_NODE ? el : el._ownerDocument;\n}\n\nfunction mutationEventsEnabled(el) {\n  return el.nodeType != core.Node.ATTRIBUTE_NODE &&\n         getDocument(el).implementation.hasFeature('MutationEvents');\n}\n\nutils.intercept(core.Node, 'insertBefore', function(_super, args, newChild, refChild) {\n  var ret = _super.apply(this, args);\n  if (mutationEventsEnabled(this)) {\n    var doc = getDocument(this),\n        ev = doc.createEvent(\"MutationEvents\");\n\n    ev.initMutationEvent(\"DOMNodeInserted\", true, false, this, null, null, null, null);\n    newChild.dispatchEvent(ev);\n    if (this.nodeType == core.Node.DOCUMENT_NODE || this._attachedToDocument) {\n      ev = doc.createEvent(\"MutationEvents\");\n      ev.initMutationEvent(\"DOMNodeInsertedIntoDocument\", false, false, null, null, null, null, null);\n      core.visitTree(newChild, function(el) {\n        if (el.nodeType == core.Node.ELEMENT_NODE) {\n          el.dispatchEvent(ev);\n          el._attachedToDocument = true;\n        }\n      });\n    }\n  }\n  return ret;\n});\n\nutils.intercept(core.Node, 'removeChild', function (_super, args, oldChild) {\n  if (mutationEventsEnabled(this)) {\n    var doc = getDocument(this),\n        ev = doc.createEvent(\"MutationEvents\");\n\n    ev.initMutationEvent(\"DOMNodeRemoved\", true, false, this, null, null, null, null);\n    oldChild.dispatchEvent(ev);\n\n    ev = doc.createEvent(\"MutationEvents\");\n    ev.initMutationEvent(\"DOMNodeRemovedFromDocument\", false, false, null, null, null, null, null);\n    core.visitTree(oldChild, function(el) {\n      if (el.nodeType == core.Node.ELEMENT_NODE) {\n        el.dispatchEvent(ev);\n        el._attachedToDocument = false;\n      }\n    });\n  }\n  return _super.apply(this, args);\n});\n\nfunction dispatchAttrEvent(doc, target, prevVal, newVal, attrName, attrChange) {\n  if (!newVal || newVal != prevVal) {\n    var ev = doc.createEvent(\"MutationEvents\");\n    ev.initMutationEvent(\"DOMAttrModified\", true, false, target, prevVal,\n                         newVal, attrName, attrChange);\n    target.dispatchEvent(ev);\n  }\n}\n\nfunction attrNodeInterceptor(change) {\n  return function(_super, args, node) {\n    var target = this._parentNode,\n        prev = _super.apply(this, args);\n\n    if (mutationEventsEnabled(target)) {\n      dispatchAttrEvent(target._ownerDocument,\n                        target,\n                        prev && prev.value || null,\n                        change == 'ADDITION' ? node.value : null,\n                        prev && prev.name || node.name,\n                        events.MutationEvent.prototype[change]);\n    }\n\n    return prev;\n  };\n}\n\nfunction attrInterceptor(ns) {\n  return function(_super, args, localName, value, _name, _prefix, namespace) {\n    var target = this._parentNode;\n\n    if (!mutationEventsEnabled(target)) {\n      _super.apply(this, args);\n      return;\n    }\n\n    if (namespace === undefined) {\n        namespace = null;\n    }\n\n    var prev =\n          ns ? this.$getNode(namespace, localName) : this.$getNoNS(localName);\n    var prevVal = prev && prev.value || null;\n\n    _super.apply(this, args);\n\n    var node = ns ? this.$getNode(namespace, localName):\n            this.$getNoNS(localName);\n\n    dispatchAttrEvent(target._ownerDocument,\n                      target,\n                      prevVal,\n                      node.value,\n                      node.name,\n                      events.MutationEvent.prototype.ADDITION);\n  };\n}\n\n\nutils.intercept(core.AttributeList, '$removeNode',\n                attrNodeInterceptor('REMOVAL'));\nutils.intercept(core.AttributeList, '$setNode',\n                attrNodeInterceptor('ADDITION'));\nutils.intercept(core.AttributeList, '$set', attrInterceptor(true));\nutils.intercept(core.AttributeList, '$setNoNS', attrInterceptor(false));\n\ndefineGetter(core.CharacterData.prototype, \"_nodeValue\", function() {\n  return this.__nodeValue;\n});\ndefineSetter(core.CharacterData.prototype, \"_nodeValue\", function(value) {\n  var oldValue = this.__nodeValue;\n  this.__nodeValue = value;\n  if (this._ownerDocument && this._parentNode && mutationEventsEnabled(this)) {\n    var ev = this._ownerDocument.createEvent(\"MutationEvents\")\n    ev.initMutationEvent(\"DOMCharacterDataModified\", true, false, this, oldValue, value, null, null);\n    this.dispatchEvent(ev);\n  }\n});\n\ncore.Document.prototype.createEvent = function(eventType) {\n    switch (eventType) {\n        case \"MutationEvents\": return new events.MutationEvent(eventType);\n        case \"UIEvents\": return new events.UIEvent(eventType);\n        case \"MouseEvents\": return new events.MouseEvent(eventType);\n        case \"HTMLEvents\": return new events.Event(eventType);\n    }\n    return new events.Event(eventType);\n};\n\nexports.dom =\n{\n  level2 : {\n    core   : core,\n    events : events\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/browser/documentfeatures.js":"exports.availableDocumentFeatures = [\n  'FetchExternalResources',\n  'ProcessExternalResources',\n  'MutationEvents',\n  'SkipExternalResources'\n];\n\nexports.defaultDocumentFeatures = {\n  \"FetchExternalResources\": ['script', 'link'/*, 'img', 'css', 'frame'*/],\n  \"ProcessExternalResources\": ['script'/*, 'frame', 'iframe'*/],\n  \"MutationEvents\": '2.0',\n  \"SkipExternalResources\": false\n};\n\nexports.applyDocumentFeatures = function(doc, features) {\n  var i, maxFeatures = exports.availableDocumentFeatures.length,\n      defaultFeatures = exports.defaultDocumentFeatures,\n      j,\n      k,\n      featureName,\n      featureSource;\n\n  features = features || {};\n\n  for (i=0; i<maxFeatures; i++) {\n    featureName = exports.availableDocumentFeatures[i];\n    if (typeof features[featureName] !== 'undefined') {\n      featureSource = features[featureName];\n    // We have to check the lowercase version also because the Document feature\n    // methods convert everything to lowercase.\n    } else if (typeof features[featureName.toLowerCase()] !== 'undefined') {\n      featureSource = features[featureName.toLowerCase()];\n    } else if (defaultFeatures[featureName]) {\n      featureSource = defaultFeatures[featureName];\n    } else {\n      continue;\n    }\n\n    doc.implementation.removeFeature(featureName);\n\n    if (typeof featureSource !== 'undefined') {\n      if (featureSource instanceof Array) {\n        k = featureSource.length;\n        for (j=0; j<k; j++) {\n          doc.implementation.addFeature(featureName, featureSource[j]);\n        }\n      } else {\n        doc.implementation.addFeature(featureName, featureSource);\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level2/languages/javascript.js":"exports.javascript = function(element, code, filename) {\n  var doc = element.ownerDocument, window = doc && doc.parentWindow;\n  if (window) {\n    try {\n      window.run(code, filename);\n    } catch (e) {\n      element.raise(\n        'error', 'Running ' + filename + ' failed.',\n        {error: e, filename: filename}\n      );\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level3/index.js":"module.exports.dom = {\n  level3 : {\n    core   : require(\"./core\").dom.level3.core,\n    xpath  : require(\"./xpath\"),\n    events : require(\"./events\").dom.level3.events,\n    html   : require(\"./html\").dom.level3.html,\n  }\n};\n\nmodule.exports.dom.ls = require('./ls').dom.level3.ls;\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level3/core.js":"var events        = require(\"../level2/events\"),\n    core          = require(\"../level2/core\").dom.level2.core,\n    defineGetter  = require('../utils').defineGetter,\n    defineSetter  = require('../utils').defineSetter,\n    HtmlToDom     = require('../browser/htmltodom').HtmlToDom,\n    domToHtml     = require('../browser/domtohtml').domToHtml;\n\n// modify cloned instance for more info check: https://github.com/tmpvar/jsdom/issues/325\ncore = Object.create(core);\n\n/*\n  valuetype DOMString sequence<unsigned short>;\n  typedef   unsigned long long DOMTimeStamp;\n  typedef   any DOMUserData;\n  typedef   Object DOMObject;\n\n*/\n// ExceptionCode\ncore.VALIDATION_ERR                 = 16;\ncore.TYPE_MISMATCH_ERR              = 17;\n\n/*\n  // Introduced in DOM Level 3:\n  interface NameList {\n    DOMString          getName(in unsigned long index);\n    DOMString          getNamespaceURI(in unsigned long index);\n    readonly attribute unsigned long   length;\n    boolean            contains(in DOMString str);\n    boolean            containsNS(in DOMString namespaceURI,\n                                  in DOMString name);\n  };\n\n  // Introduced in DOM Level 3:\n  interface DOMImplementationList {\n    DOMImplementation  item(in unsigned long index);\n    readonly attribute unsigned long   length;\n  };\n\n  // Introduced in DOM Level 3:\n  interface DOMImplementationSource {\n    DOMImplementation  getDOMImplementation(in DOMString features);\n    DOMImplementationList getDOMImplementationList(in DOMString features);\n  };\n*/\n\n\ncore.DOMImplementation.prototype.getFeature = function(feature, version)  {\n\n};\n\n/*\n  interface Node {\n    // Modified in DOM Level 3:\n    Node               insertBefore(in Node newChild,\n                                    in Node refChild)\n                                        raises(DOMException);\n    // Modified in DOM Level 3:\n    Node               replaceChild(in Node newChild,\n                                    in Node oldChild)\n                                        raises(DOMException);\n    // Modified in DOM Level 3:\n    Node               removeChild(in Node oldChild)\n                                        raises(DOMException);\n    // Modified in DOM Level 3:\n    Node               appendChild(in Node newChild)\n                                        raises(DOMException);\n    boolean            hasChildNodes();\n    Node               cloneNode(in boolean deep);\n    // Modified in DOM Level 3:\n    void               normalize();\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       baseURI;\n*/\n\n// Compare Document Position\nvar DOCUMENT_POSITION_DISCONNECTED = core.Node.DOCUMENT_POSITION_DISCONNECTED =\n                                     core.Node.prototype.DOCUMENT_POSITION_DISCONNECTED = 0x01;\n\nvar DOCUMENT_POSITION_PRECEDING    = core.Node.DOCUMENT_POSITION_PRECEDING =\n                                     core.Node.prototype.DOCUMENT_POSITION_PRECEDING    = 0x02;\n\nvar DOCUMENT_POSITION_FOLLOWING    = core.Node.DOCUMENT_POSITION_FOLLOWING =\n                                     core.Node.prototype.DOCUMENT_POSITION_FOLLOWING    = 0x04;\n\nvar DOCUMENT_POSITION_CONTAINS     = core.Node.DOCUMENT_POSITION_CONTAINS =\n                                     core.Node.prototype.DOCUMENT_POSITION_CONTAINS     = 0x08;\n\nvar DOCUMENT_POSITION_CONTAINED_BY = core.Node.DOCUMENT_POSITION_CONTAINED_BY =\n                                     core.Node.prototype.DOCUMENT_POSITION_CONTAINED_BY = 0x10;\n\nvar DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = core.Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC =\n                                                core.Node.prototype.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;\n\nvar DOCUMENT_TYPE_NODE = core.Node.prototype.DOCUMENT_TYPE_NODE;\n\ncore.Node.prototype.compareDocumentPosition = function compareDocumentPosition( otherNode ) {\n  if( !(otherNode instanceof core.Node) ) {\n    throw Error(\"Comparing position against non-Node values is not allowed\")\n  }\n  var thisOwner, otherOwner;\n\n  if( this.nodeType === this.DOCUMENT_NODE)\n    thisOwner = this\n  else\n    thisOwner = this.ownerDocument\n\n  if( otherNode.nodeType === this.DOCUMENT_NODE)\n    otherOwner = otherNode\n  else\n    otherOwner = otherNode.ownerDocument\n\n  if( this === otherNode ) return 0\n  if( this === otherNode.ownerDocument ) return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY\n  if( this.ownerDocument === otherNode ) return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS\n  if( thisOwner !== otherOwner ) return DOCUMENT_POSITION_DISCONNECTED\n\n  // Text nodes for attributes does not have a _parentNode. So we need to find them as attribute child.\n  if( this.nodeType === this.ATTRIBUTE_NODE && this._childNodes && this._childNodes._toArray().indexOf(otherNode) !== -1)\n    return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY\n\n  if( otherNode.nodeType === this.ATTRIBUTE_NODE && otherNode._childNodes && otherNode._childNodes._toArray().indexOf(this) !== -1)\n    return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS\n\n  var point = this\n  var parents = [ ]\n  var previous = null\n  while( point ) {\n    if( point == otherNode ) return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS\n    parents.push( point )\n    point = point._parentNode\n  }\n  point = otherNode\n  previous = null\n  while( point ) {\n    if( point == this ) return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY\n    var location_index = parents.indexOf( point )\n    if( location_index !== -1) {\n     var smallest_common_ancestor = parents[ location_index ]\n     var this_index = smallest_common_ancestor._childNodes._toArray().indexOf( parents[location_index - 1] )\n     var other_index = smallest_common_ancestor._childNodes._toArray().indexOf( previous )\n     if( this_index > other_index ) {\n           return DOCUMENT_POSITION_PRECEDING\n     }\n     else {\n       return DOCUMENT_POSITION_FOLLOWING\n     }\n    }\n    previous = point\n    point = point._parentNode\n  }\n  return DOCUMENT_POSITION_DISCONNECTED\n};\n/*\n    // Introduced in DOM Level 3:\n             attribute DOMString       textContent;\n                                        // raises(DOMException) on setting\n                                        // raises(DOMException) on retrieval\n*/\ncore.Node.prototype.isSameNode = function(other) {\n  return (other === this);\n};\n\n// @see http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-textContent\ndefineGetter(core.Node.prototype, 'textContent', function() {\n  switch (this.nodeType) {\n    case this.COMMENT_NODE:\n    case this.CDATA_SECTION_NODE:\n    case this.PROCESSING_INSTRUCTION_NODE:\n    case this.TEXT_NODE:\n      return this.nodeValue;\n\n    case this.ATTRIBUTE_NODE:\n    case this.DOCUMENT_FRAGMENT_NODE:\n    case this.ELEMENT_NODE:\n    case this.ENTITY_NODE:\n    case this.ENTITY_REFERENCE_NODE:\n      var out = '';\n      for (var i = 0 ; i < this.childNodes.length ; ++i) {\n        if (this.childNodes[i].nodeType !== this.COMMENT_NODE &&\n            this.childNodes[i].nodeType !== this.PROCESSING_INSTRUCTION_NODE) {\n          out += this.childNodes[i].textContent || '';\n        }\n      }\n      return out;\n\n    default:\n      return null;\n  }\n});\n\ndefineSetter(core.Node.prototype, 'textContent', function(txt) {\n  switch (this.nodeType) {\n    case this.COMMENT_NODE:\n    case this.CDATA_SECTION_NODE:\n    case this.PROCESSING_INSTRUCTION_NODE:\n    case this.TEXT_NODE:\n      return this.nodeValue = String(txt);\n  }\n\n  for (var i = this.childNodes.length; --i >=0;) {\n    this.removeChild(this.childNodes.item(i));\n  }\n  if (txt !== \"\" && txt != null) {\n    this.appendChild(this._ownerDocument.createTextNode(txt));\n  }\n  return txt;\n});\n\n/*\n    // Introduced in DOM Level 3:\n    DOMString          lookupPrefix(in DOMString namespaceURI);\n    // Introduced in DOM Level 3:\n    boolean            isDefaultNamespace(in DOMString namespaceURI);\n    // Introduced in DOM Level 3:\n    DOMString          lookupNamespaceURI(in DOMString prefix);\n*/\n// Introduced in DOM Level 3:\ncore.Node.prototype.isEqualNode = function(other) {\n  var self = this;\n  var diffValues = function() {\n    for (var i=0;i<arguments.length;i++) {\n      var k = arguments[i];\n      if (self[k] != other[k]) return(true);\n    }\n    return(false);\n  };\n  var diffNamedNodeMaps = function(snnm, onnm) {\n    if ((snnm == null) && (onnm == null)) return(false);\n    if ((snnm == null) || (onnm == null)) return(true);\n    if (snnm.length != onnm.length) return(true);\n    var js = [];\n    for (var j=0;j<onnm.length;j++) { js[j] = j }\n    for (var i=0;i<snnm.length;i++) {\n      var found=false;\n      for (var j=0;j<js.length;j++) {\n        if (snnm.item(i).isEqualNode(onnm.item(js[j]))) {\n          found = true;\n          // in order to be 100% accurate, we remove index values from consideration once they've matched\n          js.splice(j,1);\n          break;\n        }\n      }\n      if (!found) return(true);\n    }\n    return(false);\n  };\n  var diffNodeLists = function(snl, onl) {\n    if ((snl == null) && (onl == null)) return(false);\n    if ((snl == null) || (onl == null)) return(true);\n    if (snl.length != onl.length) return(true);\n    for (var i=0;i<snl.length;i++) {\n      if (!snl.item(i).isEqualNode(onl.item(i))) return(true);\n    }\n    return(false);\n  };\n  if (!other) return(false);\n  if (this.isSameNode(other)) return(true);\n  if (this.nodeType != other.nodeType) return(false);\n  if (diffValues('nodeName', 'localName', 'namespaceURI', 'prefix', 'nodeValue')) return(false);\n  if (diffNamedNodeMaps(this.attributes, other.attributes)) return(false);\n  if (diffNodeLists(this.childNodes, other.childNodes)) return(false);\n  if (this.nodeType == DOCUMENT_TYPE_NODE) {\n    if (diffValues('publicId', 'systemId', 'internalSubset')) return(false);\n    if (diffNamedNodeMaps(this.entities, other.entities)) return(false);\n    if (diffNamedNodeMaps(this.notations, other.notations)) return(false);\n  }\n  return (true);\n};\n/*\n    // Introduced in DOM Level 3:\n    DOMObject          getFeature(in DOMString feature,\n                                  in DOMString version);\n*/\n// Introduced in DOM Level 3:\ncore.Node.prototype.setUserData = function(key, data, handler) {\n  var r = this[key] || null;\n  this[key] = data;\n  return(r);\n};\n\n// Introduced in DOM Level 3:\ncore.Node.prototype.getUserData = function(key) {\n  var r = this[key] || null;\n  return(r);\n};\n/*\n  interface NodeList {\n    Node               item(in unsigned long index);\n    readonly attribute unsigned long   length;\n  };\n\n  interface NamedNodeMap {\n    Node               getNamedItem(in DOMString name);\n    Node               setNamedItem(in Node arg)\n                                        raises(DOMException);\n    Node               removeNamedItem(in DOMString name)\n                                        raises(DOMException);\n    Node               item(in unsigned long index);\n    readonly attribute unsigned long   length;\n    // Introduced in DOM Level 2:\n    Node               getNamedItemNS(in DOMString namespaceURI,\n                                      in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Node               setNamedItemNS(in Node arg)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Node               removeNamedItemNS(in DOMString namespaceURI,\n                                         in DOMString localName)\n                                        raises(DOMException);\n  };\n\n  interface CharacterData : Node {\n             attribute DOMString       data;\n                                        // raises(DOMException) on setting\n                                        // raises(DOMException) on retrieval\n\n    readonly attribute unsigned long   length;\n    DOMString          substringData(in unsigned long offset,\n                                     in unsigned long count)\n                                        raises(DOMException);\n    void               appendData(in DOMString arg)\n                                        raises(DOMException);\n    void               insertData(in unsigned long offset,\n                                  in DOMString arg)\n                                        raises(DOMException);\n    void               deleteData(in unsigned long offset,\n                                  in unsigned long count)\n                                        raises(DOMException);\n    void               replaceData(in unsigned long offset,\n                                   in unsigned long count,\n                                   in DOMString arg)\n                                        raises(DOMException);\n  };\n\n  interface Attr : Node {\n    readonly attribute DOMString       name;\n    readonly attribute boolean         specified;\n             attribute DOMString       value;\n                                        // raises(DOMException) on setting\n\n    // Introduced in DOM Level 2:\n    readonly attribute Element         ownerElement;\n    // Introduced in DOM Level 3:\n    readonly attribute TypeInfo        schemaTypeInfo;\n\n*/\n    // Introduced in DOM Level 3:\ndefineGetter(core.Attr.prototype, 'isId', function() {\n  return (this.name.toLowerCase() === 'id');\n});\n/*\n  };\n\n  interface Element : Node {\n    readonly attribute DOMString       tagName;\n    DOMString          getAttribute(in DOMString name);\n    void               setAttribute(in DOMString name,\n                                    in DOMString value)\n                                        raises(DOMException);\n    void               removeAttribute(in DOMString name)\n                                        raises(DOMException);\n    Attr               getAttributeNode(in DOMString name);\n    Attr               setAttributeNode(in Attr newAttr)\n                                        raises(DOMException);\n    Attr               removeAttributeNode(in Attr oldAttr)\n                                        raises(DOMException);\n    NodeList           getElementsByTagName(in DOMString name);\n    // Introduced in DOM Level 2:\n    DOMString          getAttributeNS(in DOMString namespaceURI,\n                                      in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    void               setAttributeNS(in DOMString namespaceURI,\n                                      in DOMString qualifiedName,\n                                      in DOMString value)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    void               removeAttributeNS(in DOMString namespaceURI,\n                                         in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Attr               getAttributeNodeNS(in DOMString namespaceURI,\n                                          in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Attr               setAttributeNodeNS(in Attr newAttr)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    NodeList           getElementsByTagNameNS(in DOMString namespaceURI,\n                                              in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    boolean            hasAttribute(in DOMString name);\n    // Introduced in DOM Level 2:\n    boolean            hasAttributeNS(in DOMString namespaceURI,\n                                      in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 3:\n    readonly attribute TypeInfo        schemaTypeInfo;\n    // Introduced in DOM Level 3:\n    void               setIdAttribute(in DOMString name,\n                                      in boolean isId)\n                                        raises(DOMException);\n    // Introduced in DOM Level 3:\n    void               setIdAttributeNS(in DOMString namespaceURI,\n                                        in DOMString localName,\n                                        in boolean isId)\n                                        raises(DOMException);\n    // Introduced in DOM Level 3:\n    void               setIdAttributeNode(in Attr idAttr,\n                                          in boolean isId)\n                                        raises(DOMException);\n  };\n\n  interface Text : CharacterData {\n    Text               splitText(in unsigned long offset)\n                                        raises(DOMException);\n    // Introduced in DOM Level 3:\n    readonly attribute boolean         isElementContentWhitespace;\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       wholeText;\n    // Introduced in DOM Level 3:\n    Text               replaceWholeText(in DOMString content)\n                                        raises(DOMException);\n  };\n\n  interface Comment : CharacterData {\n  };\n\n  // Introduced in DOM Level 3:\n  interface TypeInfo {\n    readonly attribute DOMString       typeName;\n    readonly attribute DOMString       typeNamespace;\n\n    // DerivationMethods\n    const unsigned long       DERIVATION_RESTRICTION         = 0x00000001;\n    const unsigned long       DERIVATION_EXTENSION           = 0x00000002;\n    const unsigned long       DERIVATION_UNION               = 0x00000004;\n    const unsigned long       DERIVATION_LIST                = 0x00000008;\n\n    boolean            isDerivedFrom(in DOMString typeNamespaceArg,\n                                     in DOMString typeNameArg,\n                                     in unsigned long derivationMethod);\n  };\n*/\n// Introduced in DOM Level 3:\ncore.UserDataHandler = function() {};\ncore.UserDataHandler.prototype.NODE_CLONED   = 1;\ncore.UserDataHandler.prototype.NODE_IMPORTED = 2;\ncore.UserDataHandler.prototype.NODE_DELETED  = 3;\ncore.UserDataHandler.prototype.NODE_RENAMED  = 4;\ncore.UserDataHandler.prototype.NODE_ADOPTED  = 5;\ncore.UserDataHandler.prototype.handle = function(operation, key, data, src, dst) {};\n\n// Introduced in DOM Level 3:\ncore.DOMError = function(severity, message, type, relatedException, relatedData, location) {\n  this._severity         = severity;\n  this._message          = message;\n  this._type             = type;\n  this._relatedException = relatedException;\n  this._relatedData      = relatedData;\n  this._location         = location;\n};\ncore.DOMError.prototype = {};\ncore.DOMError.prototype.SEVERITY_WARNING     = 1;\ncore.DOMError.prototype.SEVERITY_ERROR       = 2;\ncore.DOMError.prototype.SEVERITY_FATAL_ERROR = 3;\ndefineGetter(core.DOMError.prototype, 'severity', function() {\n  return this._severity;\n});\ndefineGetter(core.DOMError.prototype, 'message', function() {\n  return this._message;\n});\ndefineGetter(core.DOMError.prototype, 'type', function() {\n  return this._type;\n});\ndefineGetter(core.DOMError.prototype, 'relatedException', function() {\n  return this._relatedException;\n});\ndefineGetter(core.DOMError.prototype, 'relatedData', function() {\n  return this._relatedData;\n});\ndefineGetter(core.DOMError.prototype, 'location', function() {\n  return this._location;\n});\n\n/*\n  // Introduced in DOM Level 3:\n  interface DOMErrorHandler {\n    boolean            handleError(in DOMError error);\n  };\n\n  // Introduced in DOM Level 3:\n  interface DOMLocator {\n    readonly attribute long            lineNumber;\n    readonly attribute long            columnNumber;\n    readonly attribute long            byteOffset;\n    readonly attribute long            utf16Offset;\n    readonly attribute Node            relatedNode;\n    readonly attribute DOMString       uri;\n  };\n*/\n\n// Introduced in DOM Level 3:\ncore.DOMConfiguration = function(){\n  var possibleParameterNames = {\n    'canonical-form': [false, true], // extra rules for true\n    'cdata-sections': [true, false],\n    'check-character-normalization': [false, true],\n    'comments': [true, false],\n    'datatype-normalization': [false, true],\n    'element-content-whitespace': [true, false],\n    'entities': [true, false],\n    // 'error-handler': [],\n    'infoset': [undefined, true, false], // extra rules for true\n    'namespaces': [true, false],\n    'namespace-declarations': [true, false], // only checked if namespaces is true\n    'normalize-characters': [false, true],\n    // 'schema-location': [],\n    // 'schema-type': [],\n    'split-cdata-sections': [true, false],\n    'validate': [false, true],\n    'validate-if-schema': [false, true],\n    'well-formed': [true, false]\n  }\n};\n\ncore.DOMConfiguration.prototype = {\n  setParameter: function(name, value) {},\n  getParameter: function(name) {},\n  canSetParameter: function(name, value) {},\n  parameterNames: function() {}\n};\n\n//core.Document.prototype._domConfig = new core.DOMConfiguration();\ndefineGetter(core.Document.prototype, 'domConfig', function() {\n  return this._domConfig || new core.DOMConfiguration();;\n});\n\n// Introduced in DOM Level 3:\ncore.DOMStringList = function() {};\n\ncore.DOMStringList.prototype = {\n  item: function() {},\n  length: function() {},\n  contains: function() {}\n};\n\n\n/*\n  interface CDATASection : Text {\n  };\n\n  interface DocumentType : Node {\n    readonly attribute DOMString       name;\n    readonly attribute NamedNodeMap    entities;\n    readonly attribute NamedNodeMap    notations;\n    // Introduced in DOM Level 2:\n    readonly attribute DOMString       publicId;\n    // Introduced in DOM Level 2:\n    readonly attribute DOMString       systemId;\n    // Introduced in DOM Level 2:\n    readonly attribute DOMString       internalSubset;\n  };\n\n  interface Notation : Node {\n    readonly attribute DOMString       publicId;\n    readonly attribute DOMString       systemId;\n  };\n\n  interface Entity : Node {\n    readonly attribute DOMString       publicId;\n    readonly attribute DOMString       systemId;\n    readonly attribute DOMString       notationName;\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       inputEncoding;\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       xmlEncoding;\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       xmlVersion;\n  };\n\n  interface EntityReference : Node {\n  };\n\n  interface ProcessingInstruction : Node {\n    readonly attribute DOMString       target;\n             attribute DOMString       data;\n                                        // raises(DOMException) on setting\n\n  };\n\n  interface DocumentFragment : Node {\n  };\n\n  interface Document : Node {\n    // Modified in DOM Level 3:\n    readonly attribute DocumentType    doctype;\n    readonly attribute DOMImplementation implementation;\n    readonly attribute Element         documentElement;\n    Element            createElement(in DOMString tagName)\n                                        raises(DOMException);\n    DocumentFragment   createDocumentFragment();\n    Text               createTextNode(in DOMString data);\n    Comment            createComment(in DOMString data);\n    CDATASection       createCDATASection(in DOMString data)\n                                        raises(DOMException);\n    ProcessingInstruction createProcessingInstruction(in DOMString target,\n                                                      in DOMString data)\n                                        raises(DOMException);\n    Attr               createAttribute(in DOMString name)\n                                        raises(DOMException);\n    EntityReference    createEntityReference(in DOMString name)\n                                        raises(DOMException);\n    NodeList           getElementsByTagName(in DOMString tagname);\n    // Introduced in DOM Level 2:\n    Node               importNode(in Node importedNode,\n                                  in boolean deep)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Element            createElementNS(in DOMString namespaceURI,\n                                       in DOMString qualifiedName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Attr               createAttributeNS(in DOMString namespaceURI,\n                                         in DOMString qualifiedName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    NodeList           getElementsByTagNameNS(in DOMString namespaceURI,\n                                              in DOMString localName);\n    // Introduced in DOM Level 2:\n    Element            getElementById(in DOMString elementId);\n*/\n\n// Introduced in DOM Level 3:\ncore.Document.prototype._inputEncoding = null;\ndefineGetter(core.Document.prototype, 'inputEncoding', function() {\n  return this._inputEncoding;\n});\n/*\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       xmlEncoding;\n    // Introduced in DOM Level 3:\n             attribute boolean         xmlStandalone;\n                                        // raises(DOMException) on setting\n\n    // Introduced in DOM Level 3:\n             attribute DOMString       xmlVersion;\n                                        // raises(DOMException) on setting\n\n    // Introduced in DOM Level 3:\n             attribute boolean         strictErrorChecking;\n    // Introduced in DOM Level 3:\n             attribute DOMString       documentURI;\n    // Introduced in DOM Level 3:\n    Node               adoptNode(in Node source)\n                                        raises(DOMException);\n    // Introduced in DOM Level 3:\n    readonly attribute DOMConfiguration domConfig;\n    // Introduced in DOM Level 3:\n    void               normalizeDocument();\n    // Introduced in DOM Level 3:\n    Node               renameNode(in Node n,\n                                  in DOMString namespaceURI,\n                                  in DOMString qualifiedName)\n                                        raises(DOMException);\n  };\n};\n\n#endif // _DOM_IDL_\n*/\n\nexports.dom = {\n  level3 : {\n    core: core\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/browser/htmltodom.js":"function HtmlToDom(parser) {\n\n  if(parser && parser.write) {\n    // sax parser\n    this.appendHtmlToElement = function(html, element){\n\n      var currentElement = element, currentLevel = 0;\n\n      parser.onerror = function (e) {};\n\n      parser.ontext = function (t) {\n        var ownerDocument = currentElement.ownerDocument || currentElement;\n        var newText = ownerDocument.createTextNode(t);\n        currentElement.appendChild(newText);\n      };\n\n      parser.onopentag = function (node) {\n        var nodeName  = node.name.toLowerCase(),\n            document   = currentElement.ownerDocument || currentElement,\n            newElement = document.createElement(nodeName),\n            i          = 0,\n            length     = (node.attributes && node.attributes.length) ?\n                          node.attributes.length                     :\n                          0;\n\n        for (i in node.attributes) {\n          if (node.attributes.hasOwnProperty(i)) {\n            newElement.setAttribute(i, node.attributes[i]);\n          }\n        }\n\n        for (i=0; i<node.attributes.length; i++) {\n            newElement.setAttribute(i, node.attributes.item(i));\n        }\n        currentElement.appendChild(newElement);\n        currentElement = newElement;\n      };\n\n      parser.onclosetag = function(node) {\n        currentElement = currentElement.parentNode;\n      };\n\n      parser.write(html).close();\n\n      return element;\n    };\n\n  } else if (parser && (parser.ParseHtml || parser.DefaultHandler || (parser.Parser && parser.TreeAdapters))) {\n\n    // Forgiving HTML parser\n\n    if (parser.ParseHtml) {\n      // davglass/node-htmlparser\n    } else if (parser.DefaultHandler){\n      // fb55/htmlparser2\n\n      parser.ParseHtml = function(rawHtml) {\n        var handler = new parser.DefaultHandler();\n        // Check if document is XML\n        var isXML = (/^<\\?\\s*xml.*version=[\"']1\\.0[\"'].*\\s*\\?>/i).test(rawHtml);\n        var parserInstance = new parser.Parser(handler, {\n          xmlMode: isXML,\n          lowerCaseTags: !isXML,\n          lowerCaseAttributeNames: !isXML,\n          decodeEntities: true\n        });\n\n        parserInstance.includeLocation = false;\n        parserInstance.parseComplete(rawHtml);\n        return handler.dom;\n      };\n    } else if (parser.Parser && parser.TreeAdapters) {\n      parser.ParseHtml = function (rawHtml) {\n        if (rawHtml.match(/^<\\?\\s*xml.*version=[\"']1\\.0[\"'].*\\s*\\?>/i)) {\n          throw new Error('Can\\'t parse XML with parse5, please use htmlparser2 instead.');\n        }\n        var instance = new parser.Parser(parser.TreeAdapters.htmlparser2);\n        var dom = instance.parse(rawHtml);\n        return dom.children;\n      };\n    }\n\n    this.appendHtmlToElement = function(html, element) {\n\n      if (typeof html !== 'string') {\n        html +='';\n      }\n\n      var parsed = parser.ParseHtml(html);\n\n      for (var i = 0; i < parsed.length; i++) {\n        setChild(element, parsed[i]);\n      }\n\n      return element;\n    };\n    this.appendHtmlToDocument = this.appendHtmlToElement;\n\n    if (parser.Parser && parser.TreeAdapters) {\n      this.appendHtmlToElement = function (html, element) {\n\n        if (typeof html !== 'string') {\n          html += '';\n        }\n\n        var instance = new parser.Parser(parser.TreeAdapters.htmlparser2);\n        var dom = instance.parseFragment(html, element);\n        var parsed = dom.children;\n\n        for (var i = 0; i < parsed.length; i++) {\n          setChild(element, parsed[i]);\n        }\n\n        return element;\n      };\n    }\n\n  } else if (parser && parser.moduleName == 'HTML5') { /* HTML5 parser */\n    this.appendHtmlToElement = function(html, element) {\n\n      if (typeof html !== 'string') {\n        html += '';\n      }\n      if (html.length > 0) {\n        if (element.nodeType == 9) {\n          new parser.Parser({document: element}).parse(html);\n        }\n        else {\n          var p = new parser.Parser({document: element.ownerDocument});\n          p.parse_fragment(html, element);\n        }\n      }\n    };\n  } else {\n\n    this.appendHtmlToElement = function(){\n      console.log('');\n      console.log('###########################################################');\n      console.log('#  WARNING: No HTML parser could be found.');\n      console.log('#  Element.innerHTML setter support has been disabled');\n      console.log('#  Element.innerHTML getter support will still function');\n      console.log('#  Download: http://github.com/tautologistics/node-htmlparser');\n      console.log('###########################################################');\n      console.log('');\n    };\n\n  }\n};\n\n// utility function for forgiving parser\nfunction setChild(parent, node) {\n\n  var c, newNode, currentDocument = parent._ownerDocument || parent;\n\n  switch (node.type)\n  {\n    case 'tag':\n    case 'script':\n    case 'style':\n      try {\n        newNode = currentDocument._createElementNoTagNameValidation(node.name);\n        if (node.location) {\n          newNode.sourceLocation = node.location;\n          newNode.sourceLocation.file = parent.sourceLocation.file;\n        }\n      } catch (err) {\n        currentDocument.raise('error', 'invalid markup', {\n          exception: err,\n          node : node\n        });\n\n        return null;\n      }\n    break;\n\n    case 'text':\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n    break;\n\n    case 'comment':\n      newNode = currentDocument.createComment(node.data);\n    break;\n\n    default:\n      return null;\n    break;\n  }\n\n  if (!newNode)\n    return null;\n\n  if (node.attribs) {\n    for (c in node.attribs) {\n      // catchin errors here helps with improperly escaped attributes\n      // but properly fixing parent should (can only?) be done in the htmlparser itself\n      try {\n        newNode.setAttribute(c, node.attribs[c]);\n      } catch(e2) { /* noop */ }\n    }\n  }\n\n  if (node.children) {\n    for (c = 0; c < node.children.length; c++) {\n      setChild(newNode, node.children[c]);\n    }\n  }\n\n  try{\n    return parent.appendChild(newNode);\n  }catch(err){\n    currentDocument.raise('error', err.message, {\n          exception: err,\n          node : node\n        });\n    return null;\n  }\n}\n\nexports.HtmlToDom = HtmlToDom;\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/browser/domtohtml.js":"//List from htmlparser2\nvar voidElements = {\n  area: true,\n  base: true,\n  basefont: true,\n  br: true,\n  col: true,\n  command: true,\n  embed: true,\n  frame: true,\n  hr: true,\n  img: true,\n  input: true,\n  isindex: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\nvar expr = {\n  upperCaseChars: /([A-Z])/g,\n  breakBetweenTags: /(<(\\/?\\w+).*?>)(?=<(?!\\/\\2))/gi,\n  voidElement: (function() {\n    var tags = [];\n    for (var i in voidElements) {\n      tags.push(i);\n    }\n    return new RegExp('<' + tags.join('|<'), 'i');\n  })()\n};\n\nvar uncanon = function(str, letter) {\n  return '-' + letter.toLowerCase();\n};\n\nvar HTMLEncode = require('./htmlencoding').HTMLEncode;\n\nexports.stringifyElement = function stringifyElement(element) {\n  var tagName = element.tagName.toLowerCase(),\n      ret = {\n        start: \"<\" + tagName,\n        end:''\n      },\n      attributes = [],\n      i,\n      attribute = null;\n\n  if (element.attributes.length) {\n    ret.start += \" \";\n    for (i = 0; i<element.attributes.length; i++) {\n      attribute = element.attributes.item(i);\n      attributes.push(attribute.name + '=\"' +\n                      HTMLEncode(attribute.nodeValue, true) + '\"');\n    }\n  }\n  ret.start += attributes.join(\" \");\n\n  if (voidElements[tagName]) {\n    ret.start += \">\";\n    ret.end = '';\n  } else {\n    ret.start += \">\";\n    ret.end = \"</\" + tagName + \">\";\n  }\n\n  return ret;\n};\n\nvar rawTextElements = /SCRIPT|STYLE/i;\n\nfunction stringifyDoctype (doctype) {\n  if (doctype.ownerDocument && doctype.ownerDocument._fullDT) {\n    return doctype.ownerDocument._fullDT;\n  }\n\n  var dt = '<!DOCTYPE ' + doctype.name;\n  if (doctype.publicId) {\n    // Public ID may never contain double quotes, so this is always safe.\n    dt += ' PUBLIC \"' + doctype.publicId + '\" ';\n  }\n  if (!doctype.publicId && doctype.systemId) {\n    dt += ' SYSTEM ';\n  }\n  if (doctype.systemId) {\n    // System ID may contain double quotes OR single quotes, not never both.\n    if (doctype.systemId.indexOf('\"') > -1) {\n      dt += \"'\" + doctype.systemId + \"'\";\n    } else {\n      dt += '\"' + doctype.systemId + '\"';\n    }\n  }\n  dt += '>';\n  return dt;\n}\n\nexports.makeHtmlGenerator = function makeHtmlGenerator(indentUnit, eol) {\n  indentUnit = indentUnit || \"\";\n  eol = eol || \"\";\n\n  return function generateHtmlRecursive(node, rawText, curIndent) {\n    var ret = \"\", parent, current, i;\n    curIndent = curIndent || \"\";\n    if (node) {\n      if (node.nodeType &&\n          node.nodeType === node.ENTITY_REFERENCE_NODE) {\n        node = node._entity;\n      }\n\n      var childNodesRawText = rawText || rawTextElements.test(node.nodeName);\n\n      switch (node.nodeType) {\n        case node.ELEMENT_NODE:\n          current = exports.stringifyElement(node);\n          if (childNodesRawText) {\n            ret += curIndent + current.start;\n          } else {\n            ret += curIndent + current.start;\n          }\n          var len = node._childNodes.length;\n          if (len > 0) {\n            if (node._childNodes[0].nodeType !== node.TEXT_NODE) {\n              ret += eol;\n            }\n            for (i=0; i<len; i++) {\n              ret += generateHtmlRecursive(node._childNodes[i], childNodesRawText, curIndent + indentUnit);\n            }\n            if (node._childNodes[len - 1].nodeType !== node.TEXT_NODE) {\n              ret += curIndent;\n            }\n            ret += current.end + eol;\n          } else {\n            ret += ((rawText ? node.nodeValue : HTMLEncode(node.nodeValue, false)) || '') + current.end + eol;\n          }\n          break;\n        case node.TEXT_NODE:\n          // Skip pure whitespace nodes if we're indenting\n          if (!indentUnit || !/^[\\s\\n]*$/.test(node.nodeValue)) {\n            ret += (rawText ? node.nodeValue : HTMLEncode(node.nodeValue, false)) || '';\n          }\n          break;\n        case node.COMMENT_NODE:\n          ret += curIndent + '<!--' + node.nodeValue + '-->' + eol;\n          break;\n        case node.DOCUMENT_NODE:\n          for (i=0; i<node._childNodes.length; i++) {\n            ret += generateHtmlRecursive(node._childNodes[i], childNodesRawText, curIndent);\n          }\n          break;\n        case node.DOCUMENT_TYPE_NODE:\n          ret += stringifyDoctype(node);\n        break;\n      }\n    }\n    return ret;\n  };\n};\n\nexports.domToHtml = function(dom, noformat, raw) {\n  var htmlGenerator = exports.makeHtmlGenerator(noformat ? \"\" : \"  \",\n                                                noformat ? \"\" : \"\\n\");\n  if (dom._toArray) {\n    // node list\n    dom = dom._toArray();\n  }\n  if (typeof dom.length !== 'undefined') {\n    var ret = \"\";\n    for (var i=0,len=dom.length; i<len; i++) {\n      ret += htmlGenerator(dom[i], raw);\n    }\n    return ret;\n  } else {\n    // single node\n    return htmlGenerator(dom, raw);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/browser/htmlencoding.js":"var charByEntityName = {\n  'quot': '\"',\n  'amp': '&',\n  'apos': '\\'',\n  'lt': '<',\n  'gt': '>',\n  'nbsp': '',\n  'iexcl': '',\n  'cent': '',\n  'pound': '',\n  'curren': '',\n  'yen': '',\n  'brvbar': '',\n  'sect': '',\n  'uml': '',\n  'copy': '',\n  'ordf': '',\n  'laquo': '',\n  'not': '',\n  'shy': '',\n  'reg': '',\n  'macr': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'strns': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'deg': '',\n  'plusmn': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'pm': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'sup2': '',\n  'sup3': '',\n  'acute': '',\n  'micro': '',\n  'para': '',\n  'middot': '',\n  'cedil': '',\n  'sup1': '',\n  'ordm': '',\n  'raquo': '',\n  'frac14': '',\n  'half': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'frac12': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'frac34': '',\n  'iquest': '',\n  'Agrave': '',\n  'Aacute': '',\n  'Acirc': '',\n  'Atilde': '',\n  'Auml': '',\n  'Aring': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'angst': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'AElig': '',\n  'Ccedil': '',\n  'Egrave': '',\n  'Eacute': '',\n  'Ecirc': '',\n  'Euml': '',\n  'Igrave': '',\n  'Iacute': '',\n  'Icirc': '',\n  'Iuml': '',\n  'ETH': '',\n  'Ntilde': '',\n  'Ograve': '',\n  'Oacute': '',\n  'Ocirc': '',\n  'Otilde': '',\n  'Ouml': '',\n  'times': '',\n  'Oslash': '',\n  'Ugrave': '',\n  'Uacute': '',\n  'Ucirc': '',\n  'Uuml': '',\n  'Yacute': '',\n  'THORN': '',\n  'szlig': '',\n  'agrave': '',\n  'aacute': '',\n  'acirc': '',\n  'atilde': '',\n  'auml': '',\n  'aring': '',\n  'aelig': '',\n  'ccedil': '',\n  'egrave': '',\n  'eacute': '',\n  'ecirc': '',\n  'euml': '',\n  'igrave': '',\n  'iacute': '',\n  'icirc': '',\n  'iuml': '',\n  'eth': '',\n  'ntilde': '',\n  'ograve': '',\n  'oacute': '',\n  'ocirc': '',\n  'otilde': '',\n  'ouml': '',\n  'divide': '',\n  'oslash': '',\n  'ugrave': '',\n  'uacute': '',\n  'ucirc': '',\n  'uuml': '',\n  'yacute': '',\n  'thorn': '',\n  'yuml': '',\n  'Amacr': '',\n  'amacr': '',\n  'Abreve': '',\n  'abreve': '',\n  'Aogon': '',\n  'aogon': '',\n  'Cacute': '',\n  'cacute': '',\n  'Ccirc': '',\n  'ccirc': '',\n  'Cdot': '',\n  'cdot': '',\n  'Ccaron': '',\n  'ccaron': '',\n  'Dcaron': '',\n  'dcaron': '',\n  'Dstrok': '',\n  'dstrok': '',\n  'Emacr': '',\n  'emacr': '',\n  'Edot': '',\n  'edot': '',\n  'Eogon': '',\n  'eogon': '',\n  'Ecaron': '',\n  'ecaron': '',\n  'Gcirc': '',\n  'gcirc': '',\n  'Gbreve': '',\n  'gbreve': '',\n  'Gdot': '',\n  'gdot': '',\n  'Gcedil': '',\n  'Hcirc': '',\n  'hcirc': '',\n  'Hstrok': '',\n  'hstrok': '',\n  'Itilde': '',\n  'itilde': '',\n  'Imacr': '',\n  'imacr': '',\n  'Iogon': '',\n  'iogon': '',\n  'Idot': '',\n  'inodot': '',\n  'IJlig': '',\n  'ijlig': '',\n  'Jcirc': '',\n  'jcirc': '',\n  'Kcedil': '',\n  'kcedil': '',\n  'kgreen': '',\n  'Lacute': '',\n  'lacute': '',\n  'Lcedil': '',\n  'lcedil': '',\n  'Lcaron': '',\n  'lcaron': '',\n  'Lmidot': '',\n  'lmidot': '',\n  'Lstrok': '',\n  'lstrok': '',\n  'Nacute': '',\n  'nacute': '',\n  'Ncedil': '',\n  'ncedil': '',\n  'Ncaron': '',\n  'ncaron': '',\n  'napos': '',\n  'ENG': '',\n  'eng': '',\n  'Omacr': '',\n  'omacr': '',\n  'Odblac': '',\n  'odblac': '',\n  'OElig': '',\n  'oelig': '',\n  'Racute': '',\n  'racute': '',\n  'Rcedil': '',\n  'rcedil': '',\n  'Rcaron': '',\n  'rcaron': '',\n  'Sacute': '',\n  'sacute': '',\n  'Scirc': '',\n  'scirc': '',\n  'Scedil': '',\n  'scedil': '',\n  'Scaron': '',\n  'scaron': '',\n  'Tcedil': '',\n  'tcedil': '',\n  'Tcaron': '',\n  'tcaron': '',\n  'Tstrok': '',\n  'tstrok': '',\n  'Utilde': '',\n  'utilde': '',\n  'Umacr': '',\n  'umacr': '',\n  'Ubreve': '',\n  'ubreve': '',\n  'Uring': '',\n  'uring': '',\n  'Udblac': '',\n  'udblac': '',\n  'Uogon': '',\n  'uogon': '',\n  'Wcirc': '',\n  'wcirc': '',\n  'Ycirc': '',\n  'ycirc': '',\n  'Yuml': '',\n  'Zacute': '',\n  'zacute': '',\n  'Zdot': '',\n  'zdot': '',\n  'Zcaron': '',\n  'zcaron': '',\n  'fnof': '',\n  'imped': '',\n  'gacute': '',\n  'jmath': '',\n  'circ': '',\n  'caron': '',\n  'breve': '',\n  'dot': '',\n  'ring': '',\n  'ogon': '',\n  'tilde': '',\n  'dblac': '',\n  'Alpha': '',\n  'Beta': '',\n  'Gamma': '',\n  'Delta': '',\n  'Epsilon': '',\n  'Zeta': '',\n  'Eta': '',\n  'Theta': '',\n  'Iota': '',\n  'Kappa': '',\n  'Lambda': '',\n  'Mu': '',\n  'Nu': '',\n  'Xi': '',\n  'Omicron': '',\n  'Pi': '',\n  'Rho': '',\n  'Sigma': '',\n  'Tau': '',\n  'Upsilon': '',\n  'Phi': '',\n  'Chi': '',\n  'Psi': '',\n  'Omega': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'ohm': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'alpha': '',\n  'beta': '',\n  'gamma': '',\n  'delta': '',\n  'epsilon': '',\n  'zeta': '',\n  'eta': '',\n  'theta': '',\n  'iota': '',\n  'kappa': '',\n  'lambda': '',\n  'mu': '',\n  'nu': '',\n  'xi': '',\n  'omicron': '',\n  'pi': '',\n  'rho': '',\n  'sigmaf': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'varsigma': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'sigma': '',\n  'tau': '',\n  'upsilon': '',\n  'phi': '',\n  'chi': '',\n  'psi': '',\n  'omega': '',\n  'thetasym': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'vartheta': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'upsih': '',\n  'varphi': '',\n  'piv': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'varpi': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'Gammad': '',\n  'gammad': '',\n  'varkappa': '',\n  'varrho': '',\n  'varepsilon': '',\n  'bepsi': '',\n  'IOcy': '',\n  'DJcy': '',\n  'GJcy': '',\n  'Jukcy': '',\n  'DScy': '',\n  'Iukcy': '',\n  'YIcy': '',\n  'Jsercy': '',\n  'LJcy': '',\n  'NJcy': '',\n  'TSHcy': '',\n  'KJcy': '',\n  'Ubrcy': '',\n  'DZcy': '',\n  'Acy': '',\n  'Bcy': '',\n  'Vcy': '',\n  'Gcy': '',\n  'Dcy': '',\n  'IEcy': '',\n  'ZHcy': '',\n  'Zcy': '',\n  'Icy': '',\n  'Jcy': '',\n  'Kcy': '',\n  'Lcy': '',\n  'Mcy': '',\n  'Ncy': '',\n  'Ocy': '',\n  'Pcy': '',\n  'Rcy': '',\n  'Scy': '',\n  'Tcy': '',\n  'Ucy': '',\n  'Fcy': '',\n  'KHcy': '',\n  'TScy': '',\n  'CHcy': '',\n  'SHcy': '',\n  'SHCHcy': '',\n  'HARDcy': '',\n  'Ycy': '',\n  'SOFTcy': '',\n  'Ecy': '',\n  'YUcy': '',\n  'YAcy': '',\n  'acy': '',\n  'bcy': '',\n  'vcy': '',\n  'gcy': '',\n  'dcy': '',\n  'iecy': '',\n  'zhcy': '',\n  'zcy': '',\n  'icy': '',\n  'jcy': '',\n  'kcy': '',\n  'lcy': '',\n  'mcy': '',\n  'ncy': '',\n  'ocy': '',\n  'pcy': '',\n  'rcy': '',\n  'scy': '',\n  'tcy': '',\n  'ucy': '',\n  'fcy': '',\n  'khcy': '',\n  'tscy': '',\n  'chcy': '',\n  'shcy': '',\n  'shchcy': '',\n  'hardcy': '',\n  'ycy': '',\n  'softcy': '',\n  'ecy': '',\n  'yucy': '',\n  'yacy': '',\n  'iocy': '',\n  'djcy': '',\n  'gjcy': '',\n  'jukcy': '',\n  'dscy': '',\n  'iukcy': '',\n  'yicy': '',\n  'jsercy': '',\n  'ljcy': '',\n  'njcy': '',\n  'tshcy': '',\n  'kjcy': '',\n  'ubrcy': '',\n  'dzcy': '',\n  'ensp': '',\n  'emsp': '',\n  'emsp13': '',\n  'emsp14': '',\n  'numsp': '',\n  'puncsp': '',\n  'thinsp': '',\n  'hairsp': '',\n  'ZeroWidthSpace': '',\n  'zwnj': '',\n  'zwj': '',\n  'lrm': '',\n  'rlm': '',\n  'hyphen': '',\n  'ndash': '',\n  'mdash': '',\n  'horbar': '',\n  'Vert': '',\n  'lsquo': '',\n  'rsquo': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'rsquor': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'sbquo': '',\n  'ldquo': '',\n  'rdquo': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'rdquor': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'ldquo': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'ldquor': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'dagger': '',\n  'Dagger': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'ddagger': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'bull': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'bullet': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'nldr': '',\n  'hellip': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'mldr': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'permil': '',\n  'pertenk': '',\n  'prime': '',\n  'Prime': '',\n  'tprime': '',\n  'bprime': '',\n  'lsaquo': '',\n  'rsaquo': '',\n  'oline': '',\n  'caret': '',\n  'hybull': '',\n  'frasl': '',\n  'bsemi': '',\n  'qprime': '',\n  'MediumSpace': '',\n  'NoBreak': '',\n  'af': '',\n  'it': '',\n  'ic': '',\n  'euro': '',\n  'complexes': '',\n  'incare': '',\n  'gscr': '',\n  'hamilt': '',\n  'Poincareplane': '',\n  'quaternions': '',\n  'planckh': '',\n  'plankv': '',\n  'imagline': '',\n  'image': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'imagpart': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'lagran': '',\n  'ell': '',\n  'naturals': '',\n  'numero': '',\n  'copysr': '',\n  'weierp': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'wp': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'primes': '',\n  'rationals': '',\n  'realine': '',\n  'real': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'realpart': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'reals': '',\n  'rx': '',\n  'trade': '',\n  'integers': '',\n  'mho': '',\n  'zeetrf': '',\n  'iiota': '',\n  'bernou': '',\n  'Cfr': '',\n  'escr': '',\n  'expectation': '',\n  'Fscr': '',\n  'phmmat': '',\n  'oscr': '',\n  'alefsym': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'aleph': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'beth': '',\n  'gimel': '',\n  'daleth': '',\n  'DD': '',\n  'dd': '',\n  'exponentiale': '',\n  'ii': '',\n  'frac13': '',\n  'frac23': '',\n  'frac15': '',\n  'frac25': '',\n  'frac35': '',\n  'frac45': '',\n  'frac16': '',\n  'frac56': '',\n  'frac18': '',\n  'frac38': '',\n  'frac58': '',\n  'frac78': '',\n  'larr': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'slarr': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'uarr': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'uparrow': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'rarr': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'srarr': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'darr': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'downarrow': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'harr': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'leftrightarrow': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'varr': '',\n  'nwarrow': '',\n  'nearrow': '',\n  'searrow': '',\n  'swarrow': '',\n  'nleftarrow': '',\n  'nrightarrow': '',\n  'rightsquigarrow': '',\n  'twoheadleftarrow': '',\n  'Uarr': '',\n  'twoheadrightarrow': '',\n  'Darr': '',\n  'leftarrowtail': '',\n  'rightarrowtail': '',\n  'mapstoleft': '',\n  'mapstoup': '',\n  'mapsto': '',\n  'mapstodown': '',\n  'larrhk': '',\n  'rarrhk': '',\n  'looparrowleft': '',\n  'rarrlp': '',\n  'leftrightsquigarrow': '',\n  'nleftrightarrow': '',\n  'lsh': '',\n  'rsh': '',\n  'ldsh': '',\n  'rdsh': '',\n  'crarr': '',\n  'curvearrowleft': '',\n  'curvearrowright': '',\n  'olarr': '',\n  'orarr': '',\n  'lharu': '',\n  'lhard': '',\n  'upharpoonright': '',\n  'upharpoonleft': '',\n  'rightharpoonup': '',\n  'rightharpoondown': '',\n  'downharpoonright': '',\n  'downharpoonleft': '',\n  'rlarr': '',\n  'udarr': '',\n  'lrarr': '',\n  'llarr': '',\n  'uuarr': '',\n  'rrarr': '',\n  'downdownarrows': '',\n  'lrhar': '',\n  'rlhar': '',\n  'nlArr': '',\n  'nhArr': '',\n  'nrArr': '',\n  'lArr': '',\n  'uArr': '',\n  'rArr': '',\n  'dArr': '',\n  'hArr': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'iff': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'vArr': '',\n  'nwArr': '',\n  'neArr': '',\n  'seArr': '',\n  'swArr': '',\n  'lAarr': '',\n  'rAarr': '',\n  'zigrarr': '',\n  'larrb': '',\n  'rarrb': '',\n  'duarr': '',\n  'loarr': '',\n  'roarr': '',\n  'hoarr': '',\n  'forall': '',\n  'complement': '',\n  'part': '',\n  'exist': '',\n  'nexists': '',\n  'empty': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'varnothing': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'nabla': '',\n  'isin': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'isinv': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'notin': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'notinva': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'ni': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'niv': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'notniva': '',\n  'prod': '',\n  'coprod': '',\n  'sum': '',\n  'minus': '',\n  'mp': '',\n  'plusdo': '',\n  'ssetmn': '',\n  'lowast': '',\n  'compfn': '',\n  'radic': '',\n  'prop': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'vprop': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'infin': '',\n  'angrt': '',\n  'ang': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'angle': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'measuredangle': '',\n  'angsph': '',\n  'smid': '',\n  'nsmid': '',\n  'spar': '',\n  'nspar': '',\n  'and': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'wedge': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'or': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'vee': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'cap': '',\n  'cup': '',\n  'int': '',\n  'Int': '',\n  'tint': '',\n  'oint': '',\n  'DoubleContourIntegral': '',\n  'Cconint': '',\n  'cwint': '',\n  'cwconint': '',\n  'awconint': '',\n  'there4': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'therefore': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'because': '',\n  'ratio': '',\n  'Proportion': '',\n  'minusd': '',\n  'mDDot': '',\n  'homtht': '',\n  'sim': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'thksim': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'bsim': '',\n  'mstpos': '',\n  'acd': '',\n  'wreath': '',\n  'nsim': '',\n  'esim': '',\n  'simeq': '',\n  'nsimeq': '',\n  'cong': '',\n  'simne': '',\n  'ncong': '',\n  'asymp': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'thkap': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'napprox': '',\n  'approxeq': '',\n  'apid': '',\n  'bcong': '',\n  'asympeq': '',\n  'bump': '',\n  'bumpeq': '',\n  'esdot': '',\n  'eDot': '',\n  'fallingdotseq': '',\n  'risingdotseq': '',\n  'coloneq': '',\n  'eqcolon': '',\n  'eqcirc': '',\n  'cire': '',\n  'wedgeq': '',\n  'veeeq': '',\n  'trie': '',\n  'questeq': '',\n  'ne': '',\n  'equiv': '',\n  'nequiv': '',\n  'le': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'leq': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'ge': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'geq': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'leqq': '',\n  'geqq': '',\n  'lneqq': '',\n  'gneqq': '',\n  'll': '',\n  'gg': '',\n  'twixt': '',\n  'NotCupCap': '',\n  'nlt': '',\n  'ngtr': '',\n  'nleq': '',\n  'ngeq': '',\n  'lsim': '',\n  'gtrsim': '',\n  'nlsim': '',\n  'ngsim': '',\n  'lg': '',\n  'gtrless': '',\n  'ntlg': '',\n  'ntgl': '',\n  'prec': '',\n  'succ': '',\n  'preccurlyeq': '',\n  'succcurlyeq': '',\n  'prsim': '',\n  'succsim': '',\n  'nprec': '',\n  'nsucc': '',\n  'sub': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'subset': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'sup': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'supset': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'nsub': '',\n  'nsup': '',\n  'sube': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'subseteq': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'supe': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'supseteq': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'nsubseteq': '',\n  'nsupseteq': '',\n  'subsetneq': '',\n  'supsetneq': '',\n  'cupdot': '',\n  'uplus': '',\n  'sqsubset': '',\n  'sqsupset': '',\n  'sqsubseteq': '',\n  'sqsupseteq': '',\n  'sqcap': '',\n  'sqcup': '',\n  'oplus': '',\n  'ominus': '',\n  'otimes': '',\n  'osol': '',\n  'odot': '',\n  'ocir': '',\n  'oast': '',\n  'odash': '',\n  'plusb': '',\n  'minusb': '',\n  'timesb': '',\n  'sdotb': '',\n  'vdash': '',\n  'dashv': '',\n  'top': '',\n  'perp': '',\n  'models': '',\n  'vDash': '',\n  'Vdash': '',\n  'Vvdash': '',\n  'VDash': '',\n  'nvdash': '',\n  'nvDash': '',\n  'nVdash': '',\n  'nVDash': '',\n  'prurel': '',\n  'vltri': '',\n  'vrtri': '',\n  'trianglelefteq': '',\n  'trianglerighteq': '',\n  'origof': '',\n  'imof': '',\n  'mumap': '',\n  'hercon': '',\n  'intercal': '',\n  'veebar': '',\n  'barvee': '',\n  'angrtvb': '',\n  'lrtri': '',\n  'xwedge': '',\n  'xvee': '',\n  'xcap': '',\n  'xcup': '',\n  'diamond': '',\n  'sdot': '',\n  'sstarf': '',\n  'divonx': '',\n  'bowtie': '',\n  'ltimes': '',\n  'rtimes': '',\n  'lthree': '',\n  'rthree': '',\n  'bsime': '',\n  'cuvee': '',\n  'cuwed': '',\n  'Subset': '',\n  'Supset': '',\n  'Cap': '',\n  'Cup': '',\n  'pitchfork': '',\n  'epar': '',\n  'ltdot': '',\n  'gtrdot': '',\n  'Ll': '',\n  'ggg': '',\n  'lesseqgtr': '',\n  'gtreqless': '',\n  'curlyeqprec': '',\n  'curlyeqsucc': '',\n  'nprcue': '',\n  'nsccue': '',\n  'nsqsube': '',\n  'nsqsupe': '',\n  'lnsim': '',\n  'gnsim': '',\n  'prnsim': '',\n  'succnsim': '',\n  'ntriangleleft': '',\n  'ntriangleright': '',\n  'ntrianglelefteq': '',\n  'ntrianglerighteq': '',\n  'vellip': '',\n  'ctdot': '',\n  'utdot': '',\n  'dtdot': '',\n  'disin': '',\n  'isinsv': '',\n  'isins': '',\n  'isindot': '',\n  'notinvc': '',\n  'notinvb': '',\n  'isinE': '',\n  'nisd': '',\n  'xnis': '',\n  'nis': '',\n  'notnivc': '',\n  'notnivb': '',\n  'barwedge': '',\n  'doublebarwedge': '',\n  'lceil': '',\n  'rceil': '',\n  'lfloor': '',\n  'rfloor': '',\n  'drcrop': '',\n  'dlcrop': '',\n  'urcrop': '',\n  'ulcrop': '',\n  'bnot': '',\n  'profline': '',\n  'profsurf': '',\n  'telrec': '',\n  'target': '',\n  'ulcorner': '',\n  'urcorner': '',\n  'llcorner': '',\n  'lrcorner': '',\n  'sfrown': '',\n  'ssmile': '',\n  'lang': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'rang': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'cylcty': '',\n  'profalar': '',\n  'topbot': '',\n  'ovbar': '',\n  'solbar': '',\n  'angzarr': '',\n  'lmoustache': '',\n  'rmoustache': '',\n  'tbrk': '',\n  'bbrk': '',\n  'bbrktbrk': '',\n  'OverParenthesis': '',\n  'UnderParenthesis': '',\n  'OverBrace': '',\n  'UnderBrace': '',\n  'trpezium': '',\n  'elinters': '',\n  'blank': '',\n  'oS': '',\n  'boxh': '',\n  'boxv': '',\n  'boxdr': '',\n  'boxdl': '',\n  'boxur': '',\n  'boxul': '',\n  'boxvr': '',\n  'boxvl': '',\n  'boxhd': '',\n  'boxhu': '',\n  'boxvh': '',\n  'boxH': '',\n  'boxV': '',\n  'boxdR': '',\n  'boxDr': '',\n  'boxDR': '',\n  'boxdL': '',\n  'boxDl': '',\n  'boxDL': '',\n  'boxuR': '',\n  'boxUr': '',\n  'boxUR': '',\n  'boxuL': '',\n  'boxUl': '',\n  'boxUL': '',\n  'boxvR': '',\n  'boxVr': '',\n  'boxVR': '',\n  'boxvL': '',\n  'boxVl': '',\n  'boxVL': '',\n  'boxHd': '',\n  'boxhD': '',\n  'boxHD': '',\n  'boxHu': '',\n  'boxhU': '',\n  'boxHU': '',\n  'boxvH': '',\n  'boxVh': '',\n  'boxVH': '',\n  'uhblk': '',\n  'lhblk': '',\n  'block': '',\n  'blk14': '',\n  'blk12': '',\n  'blk34': '',\n  'square': '',\n  'squf': '',\n  'EmptyVerySmallSquare': '',\n  'rect': '',\n  'marker': '',\n  'fltns': '',\n  'xutri': '',\n  'utrif': '',\n  'utri': '',\n  'rtrif': '',\n  'triangleright': '',\n  'xdtri': '',\n  'dtrif': '',\n  'triangledown': '',\n  'ltrif': '',\n  'triangleleft': '',\n  'loz': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'lozenge': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'cir': '',\n  'tridot': '',\n  'xcirc': '',\n  'ultri': '',\n  'urtri': '',\n  'lltri': '',\n  'EmptySmallSquare': '',\n  'FilledSmallSquare': '',\n  'starf': '',\n  'star': '',\n  'phone': '',\n  'female': '',\n  'male': '',\n  'spades': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'spadesuit': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'clubs': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'clubsuit': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'hearts': '', // http://www.w3.org/TR/html4/sgml/entities.html\n  'heartsuit': '', // http://www.w3.org/TR/html5/named-character-references.html\n  'diams': '',\n  'sung': '',\n  'flat': '',\n  'natural': '',\n  'sharp': '',\n  'checkmark': '',\n  'cross': '',\n  'maltese': '',\n  'sext': '',\n  'VerticalSeparator': '',\n  'lbbrk': '',\n  'rbbrk': '',\n  'bsolhsub': '',\n  'suphsol': '',\n  'lobrk': '',\n  'robrk': '',\n  'langle': '',\n  'rangle': '',\n  'Lang': '',\n  'Rang': '',\n  'loang': '',\n  'roang': '',\n  'xlarr': '',\n  'xrarr': '',\n  'xharr': '',\n  'xlArr': '',\n  'xrArr': '',\n  'xhArr': '',\n  'xmap': '',\n  'dzigrarr': '',\n  'nvlArr': '',\n  'nvrArr': '',\n  'nvHarr': '',\n  'Map': '',\n  'lbarr': '',\n  'rbarr': '',\n  'lBarr': '',\n  'rBarr': '',\n  'drbkarow': '',\n  'DDotrahd': '',\n  'UpArrowBar': '',\n  'DownArrowBar': '',\n  'Rarrtl': '',\n  'latail': '',\n  'ratail': '',\n  'lAtail': '',\n  'rAtail': '',\n  'larrfs': '',\n  'rarrfs': '',\n  'larrbfs': '',\n  'rarrbfs': '',\n  'nwarhk': '',\n  'nearhk': '',\n  'searhk': '',\n  'swarhk': '',\n  'nwnear': '',\n  'toea': '',\n  'tosa': '',\n  'swnwar': '',\n  'rarrc': '',\n  'cudarrr': '',\n  'ldca': '',\n  'rdca': '',\n  'cudarrl': '',\n  'larrpl': '',\n  'curarrm': '',\n  'cularrp': '',\n  'rarrpl': '',\n  'harrcir': '',\n  'Uarrocir': '',\n  'lurdshar': '',\n  'ldrushar': '',\n  'LeftRightVector': '',\n  'RightUpDownVector': '',\n  'DownLeftRightVector': '',\n  'LeftUpDownVector': '',\n  'LeftVectorBar': '',\n  'RightVectorBar': '',\n  'RightUpVectorBar': '',\n  'RightDownVectorBar': '',\n  'DownLeftVectorBar': '',\n  'DownRightVectorBar': '',\n  'LeftUpVectorBar': '',\n  'LeftDownVectorBar': '',\n  'LeftTeeVector': '',\n  'RightTeeVector': '',\n  'RightUpTeeVector': '',\n  'RightDownTeeVector': '',\n  'DownLeftTeeVector': '',\n  'DownRightTeeVector': '',\n  'LeftUpTeeVector': '',\n  'LeftDownTeeVector': '',\n  'lHar': '',\n  'uHar': '',\n  'rHar': '',\n  'dHar': '',\n  'luruhar': '',\n  'ldrdhar': '',\n  'ruluhar': '',\n  'rdldhar': '',\n  'lharul': '',\n  'llhard': '',\n  'rharul': '',\n  'lrhard': '',\n  'udhar': '',\n  'duhar': '',\n  'RoundImplies': '',\n  'erarr': '',\n  'simrarr': '',\n  'larrsim': '',\n  'rarrsim': '',\n  'rarrap': '',\n  'ltlarr': '',\n  'gtrarr': '',\n  'subrarr': '',\n  'suplarr': '',\n  'lfisht': '',\n  'rfisht': '',\n  'ufisht': '',\n  'dfisht': '',\n  'lopar': '',\n  'ropar': '',\n  'lbrke': '',\n  'rbrke': '',\n  'lbrkslu': '',\n  'rbrksld': '',\n  'lbrksld': '',\n  'rbrkslu': '',\n  'langd': '',\n  'rangd': '',\n  'lparlt': '',\n  'rpargt': '',\n  'gtlPar': '',\n  'ltrPar': '',\n  'vzigzag': '',\n  'vangrt': '',\n  'angrtvbd': '',\n  'ange': '',\n  'range': '',\n  'dwangle': '',\n  'uwangle': '',\n  'angmsdaa': '',\n  'angmsdab': '',\n  'angmsdac': '',\n  'angmsdad': '',\n  'angmsdae': '',\n  'angmsdaf': '',\n  'angmsdag': '',\n  'angmsdah': '',\n  'bemptyv': '',\n  'demptyv': '',\n  'cemptyv': '',\n  'raemptyv': '',\n  'laemptyv': '',\n  'ohbar': '',\n  'omid': '',\n  'opar': '',\n  'operp': '',\n  'olcross': '',\n  'odsold': '',\n  'olcir': '',\n  'ofcir': '',\n  'olt': '',\n  'ogt': '',\n  'cirscir': '',\n  'cirE': '',\n  'solb': '',\n  'bsolb': '',\n  'boxbox': '',\n  'trisb': '',\n  'rtriltri': '',\n  'LeftTriangleBar': '',\n  'RightTriangleBar': '',\n  'iinfin': '',\n  'infintie': '',\n  'nvinfin': '',\n  'eparsl': '',\n  'smeparsl': '',\n  'eqvparsl': '',\n  'lozf': '',\n  'RuleDelayed': '',\n  'dsol': '',\n  'xodot': '',\n  'xoplus': '',\n  'xotime': '',\n  'xuplus': '',\n  'xsqcup': '',\n  'qint': '',\n  'fpartint': '',\n  'cirfnint': '',\n  'awint': '',\n  'rppolint': '',\n  'scpolint': '',\n  'npolint': '',\n  'pointint': '',\n  'quatint': '',\n  'intlarhk': '',\n  'pluscir': '',\n  'plusacir': '',\n  'simplus': '',\n  'plusdu': '',\n  'plussim': '',\n  'plustwo': '',\n  'mcomma': '',\n  'minusdu': '',\n  'loplus': '',\n  'roplus': '',\n  'Cross': '',\n  'timesd': '',\n  'timesbar': '',\n  'smashp': '',\n  'lotimes': '',\n  'rotimes': '',\n  'otimesas': '',\n  'Otimes': '',\n  'odiv': '',\n  'triplus': '',\n  'triminus': '',\n  'tritime': '',\n  'iprod': '',\n  'amalg': '',\n  'capdot': '',\n  'ncup': '',\n  'ncap': '',\n  'capand': '',\n  'cupor': '',\n  'cupcap': '',\n  'capcup': '',\n  'cupbrcap': '',\n  'capbrcup': '',\n  'cupcup': '',\n  'capcap': '',\n  'ccups': '',\n  'ccaps': '',\n  'ccupssm': '',\n  'And': '',\n  'Or': '',\n  'andand': '',\n  'oror': '',\n  'orslope': '',\n  'andslope': '',\n  'andv': '',\n  'orv': '',\n  'andd': '',\n  'ord': '',\n  'wedbar': '',\n  'sdote': '',\n  'simdot': '',\n  'congdot': '',\n  'easter': '',\n  'apacir': '',\n  'apE': '',\n  'eplus': '',\n  'pluse': '',\n  'Esim': '',\n  'Colone': '',\n  'Equal': '',\n  'eDDot': '',\n  'equivDD': '',\n  'ltcir': '',\n  'gtcir': '',\n  'ltquest': '',\n  'gtquest': '',\n  'les': '',\n  'ges': '',\n  'lesdot': '',\n  'gesdot': '',\n  'lesdoto': '',\n  'gesdoto': '',\n  'lesdotor': '',\n  'gesdotol': '',\n  'lessapprox': '',\n  'gtrapprox': '',\n  'lneq': '',\n  'gneq': '',\n  'lnapprox': '',\n  'gnapprox': '',\n  'lesseqqgtr': '',\n  'gtreqqless': '',\n  'lsime': '',\n  'gsime': '',\n  'lsimg': '',\n  'gsiml': '',\n  'lgE': '',\n  'glE': '',\n  'lesges': '',\n  'gesles': '',\n  'eqslantless': '',\n  'eqslantgtr': '',\n  'elsdot': '',\n  'egsdot': '',\n  'el': '',\n  'eg': '',\n  'siml': '',\n  'simg': '',\n  'simlE': '',\n  'simgE': '',\n  'LessLess': '',\n  'GreaterGreater': '',\n  'glj': '',\n  'gla': '',\n  'ltcc': '',\n  'gtcc': '',\n  'lescc': '',\n  'gescc': '',\n  'smt': '',\n  'lat': '',\n  'smte': '',\n  'late': '',\n  'bumpE': '',\n  'preceq': '',\n  'succeq': '',\n  'prE': '',\n  'scE': '',\n  'prnE': '',\n  'succneqq': '',\n  'precapprox': '',\n  'succapprox': '',\n  'prnap': '',\n  'succnapprox': '',\n  'Pr': '',\n  'Sc': '',\n  'subdot': '',\n  'supdot': '',\n  'subplus': '',\n  'supplus': '',\n  'submult': '',\n  'supmult': '',\n  'subedot': '',\n  'supedot': '',\n  'subseteqq': '',\n  'supseteqq': '',\n  'subsim': '',\n  'supsim': '',\n  'subsetneqq': '',\n  'supsetneqq': '',\n  'csub': '',\n  'csup': '',\n  'csube': '',\n  'csupe': '',\n  'subsup': '',\n  'supsub': '',\n  'subsub': '',\n  'supsup': '',\n  'suphsub': '',\n  'supdsub': '',\n  'forkv': '',\n  'topfork': '',\n  'mlcp': '',\n  'DoubleLeftTee': '',\n  'Vdashl': '',\n  'Barv': '',\n  'vBar': '',\n  'vBarv': '',\n  'Vbar': '',\n  'Not': '',\n  'bNot': '',\n  'rnmid': '',\n  'cirmid': '',\n  'midcir': '',\n  'topcir': '',\n  'nhpar': '',\n  'parsim': '',\n  'parsl': '',\n  'fflig': '',\n  'filig': '',\n  'fllig': '',\n  'ffilig': '',\n  'ffllig': '',\n  'Ascr': '',\n  'Cscr': '',\n  'Dscr': '',\n  'Gscr': '',\n  'Jscr': '',\n  'Kscr': '',\n  'Nscr': '',\n  'Oscr': '',\n  'Pscr': '',\n  'Qscr': '',\n  'Sscr': '',\n  'Tscr': '',\n  'Uscr': '',\n  'Vscr': '',\n  'Wscr': '',\n  'Xscr': '',\n  'Yscr': '',\n  'Zscr': '',\n  'ascr': '',\n  'bscr': '',\n  'cscr': '',\n  'dscr': '',\n  'fscr': '',\n  'hscr': '',\n  'iscr': '',\n  'jscr': '',\n  'kscr': '',\n  'lscr': '',\n  'mscr': '',\n  'nscr': '',\n  'pscr': '',\n  'qscr': '',\n  'rscr': '',\n  'sscr': '',\n  'tscr': '',\n  'uscr': '',\n  'vscr': '',\n  'wscr': '',\n  'xscr': '',\n  'yscr': '',\n  'zscr': '',\n  'Afr': '',\n  'Bfr': '',\n  'Dfr': '',\n  'Efr': '',\n  'Ffr': '',\n  'Gfr': '',\n  'Jfr': '',\n  'Kfr': '',\n  'Lfr': '',\n  'Mfr': '',\n  'Nfr': '',\n  'Ofr': '',\n  'Pfr': '',\n  'Qfr': '',\n  'Sfr': '',\n  'Tfr': '',\n  'Ufr': '',\n  'Vfr': '',\n  'Wfr': '',\n  'Xfr': '',\n  'Yfr': '',\n  'afr': '',\n  'bfr': '',\n  'cfr': '',\n  'dfr': '',\n  'efr': '',\n  'ffr': '',\n  'gfr': '',\n  'hfr': '',\n  'ifr': '',\n  'jfr': '',\n  'kfr': '',\n  'lfr': '',\n  'mfr': '',\n  'nfr': '',\n  'ofr': '',\n  'pfr': '',\n  'qfr': '',\n  'rfr': '',\n  'sfr': '',\n  'tfr': '',\n  'ufr': '',\n  'vfr': '',\n  'wfr': '',\n  'xfr': '',\n  'yfr': '',\n  'zfr': '',\n  'Aopf': '',\n  'Bopf': '',\n  'Dopf': '',\n  'Eopf': '',\n  'Fopf': '',\n  'Gopf': '',\n  'Iopf': '',\n  'Jopf': '',\n  'Kopf': '',\n  'Lopf': '',\n  'Mopf': '',\n  'Oopf': '',\n  'Sopf': '',\n  'Topf': '',\n  'Uopf': '',\n  'Vopf': '',\n  'Wopf': '',\n  'Xopf': '',\n  'Yopf': '',\n  'aopf': '',\n  'bopf': '',\n  'copf': '',\n  'dopf': '',\n  'eopf': '',\n  'fopf': '',\n  'gopf': '',\n  'hopf': '',\n  'iopf': '',\n  'jopf': '',\n  'kopf': '',\n  'lopf': '',\n  'mopf': '',\n  'nopf': '',\n  'oopf': '',\n  'popf': '',\n  'qopf': '',\n  'ropf': '',\n  'sopf': '',\n  'topf': '',\n  'uopf': '',\n  'vopf': '',\n  'wopf': '',\n  'xopf': '',\n  'yopf': '',\n  'zopf': ''\n};\n\nvar specialCharEntities = {\n  '&': '&amp;',\n  '\"': '&quot;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\xA0': '&nbsp;'\n};\n\nvar entityRegExp = /&(?:#([0-9]+)|#x([0-9a-f]+)|([a-z0-9]+));/gi;\nvar attributeModeSpecialCharRegExp = /[\"&<>\\xA0]/g;\nvar nonAttributeModeSpecialCharRegExp = /[&<>\\xA0]/g;\n\nfunction specialCharToEntity(s) {\n  var entity = specialCharEntities[s];\n  return entity ? entity : s;\n}\n\nexports.HTMLEncode = function encode(s, attributeMode) {\n  if (!s) return '';\n  if (!s.replace) return s;\n  if(attributeMode) {\n\t  return s.replace(attributeModeSpecialCharRegExp, specialCharToEntity);\n  } else {\n\t  return s.replace(nonAttributeModeSpecialCharRegExp, specialCharToEntity);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level3/xpath.js":"/** Here is yet another implementation of XPath 1.0 in Javascript.\n *\n * My goal was to make it relatively compact, but as I fixed all the axis bugs\n * the axes became more and more complicated. :-(.\n *\n * I have not implemented namespaces or case-sensitive axes for XML yet.\n *\n * How to test it in Chrome: You can make a Chrome extension that replaces\n * the WebKit XPath parser with this one. But it takes a bit of effort to\n * get around isolated world and same-origin restrictions:\n * manifest.json:\n    {\n      \"name\": \"XPathTest\",\n      \"version\": \"0.1\",\n      \"content_scripts\": [{\n        \"matches\": [\"http://localhost/*\"],  // or wildcard host\n        \"js\": [\"xpath.js\", \"injection.js\"],\n        \"all_frames\": true, \"run_at\": \"document_start\"\n      }]\n    }\n * injection.js:\n    // goal: give my xpath object to the website's JS context.\n    var script = document.createElement('script');\n    script.textContent =\n        \"document.addEventListener('xpathextend', function(e) {\\n\" +\n        \"  console.log('extending document with xpath...');\\n\" +\n        \"  e.detail(window);\" +\n        \"});\";\n    document.documentElement.appendChild(script);\n    document.documentElement.removeChild(script);\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);\n    document.dispatchEvent(evt);\n */\n(function() {\n  var core;\n  var xpath;\n  if ('function' === typeof require) {\n    core = require(\"../level3/core\").dom.level3.core;\n    xpath = exports;\n  } else {\n    core = this;\n    xpath = {};\n  }\n\n\n  /***************************************************************************\n   *                            Tokenization                                 *\n   ***************************************************************************/\n  /**\n   * The XPath lexer is basically a single regular expression, along with\n   * some helper functions to pop different types.\n   */\n  var Stream = xpath.Stream = function Stream(str) {\n    this.original = this.str = str;\n    this.peeked = null;\n    // TODO: not really needed, but supposedly tokenizer also disambiguates\n    // a * b vs. node test *\n    this.prev = null;  // for debugging\n    this.prevprev = null;\n  }\n  Stream.prototype = {\n    peek: function() {\n      if (this.peeked) return this.peeked;\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      this.str = this.str.substr(m[0].length);\n      return this.peeked = m[1];\n    },\n    /** Peek 2 tokens ahead. */\n    peek2: function() {\n      this.peek();  // make sure this.peeked is set\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      return m[1];\n    },\n    pop: function() {\n      var r = this.peek();\n      this.peeked = null;\n      this.prevprev = this.prev;\n      this.prev = r;\n      return r;\n    },\n    trypop: function(tokens) {\n      var tok = this.peek();\n      if (tok === tokens) return this.pop();\n      if (Array.isArray(tokens)) {\n        for (var i = 0; i < tokens.length; ++i) {\n          var t = tokens[i];\n          if (t == tok) return this.pop();;\n        }\n      }\n    },\n    trypopfuncname: function() {\n      var tok = this.peek();\n      if (!this.isQnameRe.test(tok))\n        return null;\n      switch (tok) {\n        case 'comment': case 'text': case 'processing-instruction': case 'node':\n          return null;\n      }\n      if ('(' != this.peek2()) return null;\n      return this.pop();\n    },\n    trypopaxisname: function() {\n      var tok = this.peek();\n      switch (tok) {\n        case 'ancestor': case 'ancestor-or-self': case 'attribute':\n        case 'child': case 'descendant': case 'descendant-or-self':\n        case 'following': case 'following-sibling': case 'namespace':\n        case 'parent': case 'preceding': case 'preceding-sibling': case 'self':\n          if ('::' == this.peek2()) return this.pop();\n      }\n      return null;\n    },\n    trypopnametest: function() {\n      var tok = this.peek();\n      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();\n      return null;\n    },\n    trypopliteral: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      var first = tok.charAt(0);\n      var last = tok.charAt(tok.length - 1);\n      if ('\"' === first && '\"' === last ||\n          \"'\" === first && \"'\" === last) {\n        this.pop();\n        return tok.substr(1, tok.length - 2);\n      }\n    },\n    trypopnumber: function() {\n      var tok = this.peek();\n      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());\n      else return null;\n    },\n    trypopvarref: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      if ('$' === tok.charAt(0)) return this.pop().substr(1);\n      else return null;\n    },\n    position: function() {\n      return this.original.length - this.str.length;\n    }\n  };\n  (function() {\n    // http://www.w3.org/TR/REC-xml-names/#NT-NCName\n    var nameStartCharsExceptColon =\n        'A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF' +\n        '\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF' +\n        '\\uFDF0-\\uFFFD';  // JS doesn't support [#x10000-#xEFFFF]\n    var nameCharExceptColon = nameStartCharsExceptColon +\n        '\\\\-\\\\.0-9\\xb7\\u0300-\\u036F\\u203F-\\u2040';\n    var ncNameChars = '[' + nameStartCharsExceptColon +\n        '][' + nameCharExceptColon + ']*'\n    // http://www.w3.org/TR/REC-xml-names/#NT-QName\n    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';\n    var otherChars = '\\\\.\\\\.|[\\\\(\\\\)\\\\[\\\\].@,]|::';  // .. must come before [.]\n    var operatorChars =\n        'and|or|mod|div|' +\n        '//|!=|<=|>=|[*/|+\\\\-=<>]';  // //, !=, <=, >= before individual ones.\n    var literal = '\"[^\"]*\"|' + \"'[^']*'\";\n    var numberChars = '[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+';\n    var variableReference = '\\\\$' + qNameChars;\n    var nameTestChars = '\\\\*|' + ncNameChars + ':\\\\*|' + qNameChars;\n    var optionalSpace = '[ \\t\\r\\n]*';  // stricter than regexp \\s.\n    var nodeType = 'comment|text|processing-instruction|node';\n    var re = new RegExp(\n        // numberChars before otherChars so that leading-decimal doesn't become .\n        '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' +\n        nameTestChars + '|' + operatorChars + '|' + literal + '|' +\n        variableReference + ')'\n        // operatorName | nodeType | functionName | axisName are lumped into\n        // qName for now; we'll check them on pop.\n    );\n    Stream.prototype.re = re;\n    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);\n    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');\n    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');\n  })();\n\n  /***************************************************************************\n   *                               Parsing                                   *\n   ***************************************************************************/\n  var parse = xpath.parse = function parse(stream, a) {\n    var r = orExpr(stream,a);\n    var x, unparsed = [];\n    while (x = stream.pop()) {\n      unparsed.push(x);\n    }\n    if (unparsed.length)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Unparsed tokens: ' + unparsed.join(' '));\n    return r;\n  }\n\n  /**\n   * binaryL  ::= subExpr\n   *            | binaryL op subExpr\n   * so a op b op c becomes ((a op b) op c)\n   */\n  function binaryL(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op;\n    while (op = stream.trypop(ops)) {\n      var rhs = subExpr(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      lhs = a.node(op, lhs, rhs);\n    }\n    return lhs;\n  }\n  /**\n   * Too bad this is never used. If they made a ** operator (raise to power),\n   ( we would use it.\n   * binaryR  ::= subExpr\n   *            | subExpr op binaryR\n   * so a op b op c becomes (a op (b op c))\n   */\n  function binaryR(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op = stream.trypop(ops);\n    if (op) {\n      var rhs = binaryR(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      return a.node(op, lhs, rhs);\n    } else {\n      return lhs;// TODO\n    }\n  }\n  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath\n   * e.g. a, a/b, //a/b\n   */\n  function locationPath(stream, a) {\n    return absoluteLocationPath(stream, a) ||\n           relativeLocationPath(null, stream, a);\n  }\n  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath\n   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath\n   */\n  function absoluteLocationPath(stream, a) {\n    var op = stream.peek();\n    if ('/' === op || '//' === op) {\n      var lhs = a.node('Root');\n      return relativeLocationPath(lhs, stream, a, true);\n    } else {\n      return null;\n    }\n  }\n  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |\n   *                            | AbbreviatedRelativeLocationPath\n   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step\n   * e.g. p/a, etc.\n   */\n  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {\n    if (null == lhs) {\n      lhs = step(stream, a);\n      if (null == lhs) return lhs;\n    }\n    var op;\n    while (op = stream.trypop(['/', '//'])) {\n      if ('//' === op) {\n        lhs = a.node('/', lhs,\n                     a.node('Axis', 'descendant-or-self', 'node', undefined));\n      }\n      var rhs = step(stream, a);\n      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;\n      else isOnlyRootOk = false;\n      if (null == rhs)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected step after ' + op);\n      lhs = a.node('/', lhs, rhs);\n    }\n    return lhs;\n  }\n  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep\n   *  [12] AbbreviatedStep::= '.' | '..'\n   * e.g. @href, self::p, p, a[@href], ., ..\n   */\n  function step(stream, a) {\n    var abbrStep = stream.trypop(['.', '..']);\n    if ('.' === abbrStep)  // A location step of . is short for self::node().\n      return a.node('Axis', 'self', 'node');\n    if ('..' === abbrStep)  // A location step of .. is short for parent::node()\n      return a.node('Axis', 'parent', 'node');\n\n    var axis = axisSpecifier(stream, a);\n    var nodeType = nodeTypeTest(stream, a);\n    var nodeName;\n    if (null == nodeType) nodeName = nodeNameTest(stream, a);\n    if (null == axis && null == nodeType && null == nodeName) return null;\n    if (null == nodeType && null == nodeName)\n        throw new XPathException(\n            XPathException.INVALID_EXPRESSION_ERR,\n            'Position ' + stream.position() +\n            ': Expected nodeTest after axisSpecifier ' + axis);\n    if (null == axis) axis = 'child';\n    if (null == nodeType) {\n      // When there's only a node name, then the node type is forced to be the\n      // principal node type of the axis.\n      // see http://www.w3.org/TR/xpath/#dt-principal-node-type\n      if ('attribute' === axis) nodeType = 'attribute';\n      else if ('namespace' === axis) nodeType = 'namespace';\n      else nodeType = 'element';\n    }\n    var lhs = a.node('Axis', axis, nodeType, nodeName);\n    var pred;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier\n   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'\n   *                | 'descendant' | 'descendant-or-self' | 'following'\n   *                | 'following-sibling' | 'namespace' | 'parent' |\n   *                | 'preceding' | 'preceding-sibling' | 'self'\n   *  [13] AbbreviatedAxisSpecifier::= '@'?\n   */\n  function axisSpecifier(stream, a) {\n    var attr = stream.trypop('@');\n    if (null != attr) return 'attribute';\n    var axisName = stream.trypopaxisname();\n    if (null != axisName) {\n      var coloncolon = stream.trypop('::');\n      if (null == coloncolon)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen. Should be ::.');\n      return axisName;\n    }\n  }\n  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'\n   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'\n   * I've split nodeTypeTest from nodeNameTest for convenience.\n   */\n  function nodeTypeTest(stream, a) {\n    if ('(' !== stream.peek2()) {\n      return null;\n    }\n    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);\n    if (null != type) {\n      if (null == stream.trypop('('))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen.');\n      var param = undefined;\n      if (type == 'processing-instruction') {\n        param = stream.trypopliteral();\n      }\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected close parens.');\n      return type\n    }\n  }\n  function nodeNameTest(stream, a) {\n    var name = stream.trypopnametest();\n    if (name != null) return name;\n    else return null;\n  }\n  /** [8] Predicate::= '[' PredicateExpr ']'\n   *  [9] PredicateExpr::= Expr\n   */\n  function predicate(lhs, stream, a) {\n    if (null == stream.trypop('[')) return null;\n    var expr = orExpr(stream, a);\n    if (null == expr)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected expression after [');\n    if (null == stream.trypop(']'))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ] after expression.');\n    return a.node('Predicate', lhs, expr);\n  }\n  /** [14] Expr::= OrExpr\n   */\n  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall\n   * e.g. $x,  (3+4),  \"hi\",  32,  f(x)\n   */\n  function primaryExpr(stream, a) {\n    var x = stream.trypopliteral();\n    if (null == x)\n      x = stream.trypopnumber();\n    if (null != x) {\n      return x;\n    }\n    var varRef = stream.trypopvarref();\n    if (null != varRef) return a.node('VariableReference', varRef);\n    var funCall = functionCall(stream, a);\n    if (null != funCall) {\n      return funCall;\n    }\n    if (stream.trypop('(')) {\n      var e = orExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression after (.');\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected ) after expression.');\n      return e;\n    }\n    return null;\n  }\n  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'\n   *  [17] Argument::= Expr\n   */\n  function functionCall(stream, a) {\n    var name = stream.trypopfuncname(stream, a);\n    if (null == name) return null;\n    if (null == stream.trypop('('))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ( ) after function name.');\n    var params = [];\n    var first = true;\n    while (null == stream.trypop(')')) {\n      if (!first && null == stream.trypop(','))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected , between arguments of the function.');\n      first = false;\n      var param = orExpr(stream, a);\n      if (param == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression as argument of function.');\n      params.push(param);\n    }\n    return a.node('FunctionCall', name, params);\n  }\n\n  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr\n   */\n  function unionExpr(stream, a) { return binaryL(pathExpr, stream, a, '|'); }\n  /** [19] PathExpr ::= LocationPath\n   *                  | FilterExpr\n   *                  | FilterExpr '/' RelativeLocationPath\n   *                  | FilterExpr '//' RelativeLocationPath\n   * Unlike most other nodes, this one always generates a node because\n   * at this point all reverse nodesets must turn into a forward nodeset\n   */\n  function pathExpr(stream, a) {\n    // We have to do FilterExpr before LocationPath because otherwise\n    // LocationPath will eat up the name from a function call.\n    var filter = filterExpr(stream, a);\n    if (null == filter) {\n      var loc = locationPath(stream, a);\n      if (null == loc) {\n        throw new Error\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': The expression shouldn\\'t be empty...');\n      }\n      return a.node('PathExpr', loc);\n    }\n    var rel = relativeLocationPath(filter, stream, a, false);\n    if (filter === rel) return rel;\n    else return a.node('PathExpr', rel);\n  }\n  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate\n   * aka. FilterExpr ::= PrimaryExpr Predicate*\n   */\n  function filterExpr(stream, a) {\n    var primary = primaryExpr(stream, a);\n    if (primary == null) return null;\n    var pred, lhs = primary;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n\n  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr\n   */\n  function orExpr(stream, a) {\n    var orig = (stream.peeked || '') + stream.str\n    var r = binaryL(andExpr, stream, a, 'or');\n    var now = (stream.peeked || '') + stream.str;\n    return r;\n  }\n  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr\n   */\n  function andExpr(stream, a) { return binaryL(equalityExpr, stream, a, 'and'); }\n  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr\n   *                     | EqualityExpr '!=' RelationalExpr\n   */\n  function equalityExpr(stream, a) { return binaryL(relationalExpr, stream, a, ['=','!=']); }\n  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr\n   *                       | RelationalExpr '>' AdditiveExpr\n   *                       | RelationalExpr '<=' AdditiveExpr\n   *                       | RelationalExpr '>=' AdditiveExpr\n   */\n  function relationalExpr(stream, a) { return binaryL(additiveExpr, stream, a, ['<','>','<=','>=']); }\n  /** [25] AdditiveExpr::= MultiplicativeExpr\n   *                     | AdditiveExpr '+' MultiplicativeExpr\n   *                     | AdditiveExpr '-' MultiplicativeExpr\n   */\n  function additiveExpr(stream, a) { return binaryL(multiplicativeExpr, stream, a, ['+','-']); }\n  /** [26] MultiplicativeExpr::= UnaryExpr\n   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr\n   *                           | MultiplicativeExpr 'div' UnaryExpr\n   *                           | MultiplicativeExpr 'mod' UnaryExpr\n   */\n  function multiplicativeExpr(stream, a) { return binaryL(unaryExpr, stream, a, ['*','div','mod']); }\n  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr\n   */\n  function unaryExpr(stream, a) {\n    if (stream.trypop('-')) {\n      var e = unaryExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected unary expression after -');\n      return a.node('UnaryMinus', e);\n    }\n    else return unionExpr(stream, a);\n  }\n  var astFactory = {\n    node: function() {return Array.prototype.slice.call(arguments);}\n  };\n\n\n  /***************************************************************************\n   *                            Optimizations (TODO)                         *\n   ***************************************************************************/\n  /**\n   * Some things I've been considering:\n   * 1) a//b becomes a/descendant::b if there's no predicate that uses\n   *    position() or last()\n   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per\n   *    node in the node-set rather than once per (node, position, last).\n   * For more optimizations, look up Gecko's optimizer:\n   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp\n   */\n  // TODO\n  function optimize(ast) {\n  }\n\n  /***************************************************************************\n   *                           Evaluation: axes                              *\n   ***************************************************************************/\n\n  /**\n   * Data types: For string, number, boolean, we just use Javascript types.\n   * Node-sets have the form\n   *    {nodes: [node, ...]}\n   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}\n   *\n   * Most of the time, only the node is used and the position information is\n   * discarded. But if you use a predicate, we need to try every value of\n   * position and last in case the predicate calls position() or last().\n   */\n\n  /**\n   * The NodeMultiSet is a helper class to help generate\n   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the\n   * descendant, descendant-or-self, following-sibling, and\n   * preceding-sibling axes for which we can use a stack to organize things.\n   */\n  function NodeMultiSet(isReverseAxis) {\n    this.nodes = [];\n    this.pos = [];\n    this.lasts = [];\n    this.nextPos = [];\n    this.seriesIndexes = [];  // index within nodes that each series begins.\n    this.isReverseAxis = isReverseAxis;\n    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;\n  }\n  NodeMultiSet.prototype = {\n    pushSeries: function pushSeries() {\n      this.nextPos.push(1);\n      this.seriesIndexes.push(this.nodes.length);\n    },\n    popSeries: function popSeries() {\n      console.assert(0 < this.nextPos.length, this.nextPos);\n      var last = this.nextPos.pop() - 1,\n          indexInPos = this.nextPos.length,\n          seriesBeginIndex = this.seriesIndexes.pop(),\n          seriesEndIndex = this.nodes.length;\n      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {\n        console.assert(indexInPos < this.lasts[i].length);\n        console.assert(undefined === this.lasts[i][indexInPos]);\n        this.lasts[i][indexInPos] = last;\n      }\n    },\n    finalize: function() {\n      if (null == this.nextPos) return this;\n      console.assert(0 === this.nextPos.length);\n      for (var i = 0; i < this.lasts.length; ++i) {\n        for (var j = 0; j < this.lasts[i].length; ++j) {\n          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + JSON.stringify(this.lasts));\n        }\n      }\n      this.pushSeries = this.popSeries = this.addNode = function() {\n        throw new Error('Already finalized.');\n      };\n      return this;\n    },\n    addNode: function addNode(node) {\n      console.assert(node);\n      this._pushToNodes.call(this.nodes, node)\n      this._pushToNodes.call(this.pos, this.nextPos.slice());\n      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));\n      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;\n    },\n    simplify: function() {\n      this.finalize();\n      return {nodes:this.nodes, pos:this.pos, lasts:this.lasts};\n    }\n  };\n  function eachContext(nodeMultiSet) {\n    var r = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var node = nodeMultiSet.nodes[i];\n      if (!nodeMultiSet.pos) {\n        r.push({nodes:[node], pos: [[i + 1]], lasts: [[nodeMultiSet.nodes.length]]});\n      } else {\n        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {\n          r.push({nodes:[node], pos: [[nodeMultiSet.pos[i][j]]], lasts: [[nodeMultiSet.lasts[i][j]]]});\n        }\n      }\n    }\n    return r;\n  }\n  /** Matcher used in the axes.\n   */\n  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {\n    this.nodeTypeNum = nodeTypeNum;\n    this.nodeName = nodeName;\n    this.shouldLowerCase = shouldLowerCase;\n    this.nodeNameTest =\n      null == nodeName ? this._alwaysTrue :\n      shouldLowerCase ? this._nodeNameLowerCaseEquals :\n      this._nodeNameEquals;\n  }\n  NodeMatcher.prototype = {\n    matches: function matches(node) {\n      return (0 === this.nodeTypeNum || node.nodeType === this.nodeTypeNum) &&\n          this.nodeNameTest(node.nodeName);\n    },\n    _alwaysTrue: function(name) {return true;},\n    _nodeNameEquals: function _nodeNameEquals(name) {\n      return this.nodeName === name;\n    },\n    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {\n      return this.nodeName === name.toLowerCase();\n    }\n  };\n\n  function followingSiblingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(isReverseAxis);\n    while (0 < nodeList.length) {  // can be if for following, preceding\n      var node = shift.call(nodeList);\n      console.assert(node != null);\n      node = followingNode(node);\n      nodeMultiSet.pushSeries();\n      var numPushed = 1;\n      while (null != node) {\n        if (! andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        if (node === peek.call(nodeList)) {\n          shift.call(nodeList);\n          nodeMultiSet.pushSeries();\n          numPushed++;\n        }\n        if (andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        node = followingNode(node);\n      }\n      while (0 < numPushed--)\n        nodeMultiSet.popSeries();\n    }\n    return nodeMultiSet;\n  }\n\n  /** Returns the next non-descendant node in document order.\n   * This is the first node in following::node(), if node is the context.\n   */\n  function followingNonDescendantNode(node) {\n    if (node.ownerElement) {\n      if (node.ownerElement.firstChild)\n        return node.ownerElement.firstChild;\n      node = node.ownerElement;\n    }\n    do {\n      if (node.nextSibling) return node.nextSibling;\n    } while (node = node.parentNode);\n    return null;\n  }\n\n  /** Returns the next node in a document-order depth-first search.\n   * See the definition of document order[1]:\n   *   1) element\n   *   2) namespace nodes\n   *   3) attributes\n   *   4) children\n   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order\n   */\n  function followingNode(node) {\n    if (node.ownerElement)  // attributes: following node of element.\n      node = node.ownerElement;\n    if (null != node.firstChild)\n      return node.firstChild;\n    do {\n      if (null != node.nextSibling) {\n        return node.nextSibling;\n      }\n      node = node.parentNode;\n    } while (node);\n    return null;\n  }\n  /** Returns the previous node in document order (excluding attributes\n   * and namespace nodes).\n   */\n  function precedingNode(node) {\n    if (node.ownerElement)\n      return node.ownerElement;\n    if (null != node.previousSibling) {\n      node = node.previousSibling;\n      while (null != node.lastChild) {\n        node = node.lastChild;\n      }\n      return node;\n    }\n    if (null != node.parentNode) {\n      return node.parentNode;\n    }\n    return null;\n  }\n  /** This axis is inefficient if there are many nodes in the nodeList.\n   * But I think it's a pretty useless axis so it's ok. */\n  function followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var cursor = nodeList[0];\n    var unorderedFollowingStarts = [];\n    for (var i = 0; i < nodeList.length; i++) {\n      var node = nodeList[i];\n      var start = followingNonDescendantNode(node);\n      if (start)\n        unorderedFollowingStarts.push(start);\n    }\n    if (0 === unorderedFollowingStarts.length)\n      return {nodes:[]};\n    var pos = [], nextPos = [];\n    var started = 0;\n    while (cursor = followingNode(cursor)) {\n      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--){\n        if (cursor === unorderedFollowingStarts[i]) {\n          nodeMultiSet.pushSeries();\n          unorderedFollowingStarts.splice(i,i+1);\n          started++;\n        }\n      }\n      if (started && matcher.matches(cursor)) {\n        nodeMultiSet.addNode(cursor);\n      }\n    }\n    console.assert(0 === unorderedFollowingStarts.length);\n    for (var i = 0; i < started; i++)\n      nodeMultiSet.popSeries();\n    return nodeMultiSet.finalize();\n  }\n  function precedingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var cursor = nodeList.pop();\n    if (null == cursor) return {nodes:{}};\n    var r = {nodes:[], pos:[], lasts:[]};\n    var nextParents = [cursor.parentNode || cursor.ownerElement], nextPos = [1];\n    while (cursor = precedingNode(cursor)) {\n      if (cursor === nodeList[nodeList.length - 1]) {\n        nextParents.push(nodeList.pop());\n        nextPos.push(1);\n      }\n      var matches = matcher.matches(cursor);\n      var pos, someoneUsed = false;\n      if (matches)\n        pos = nextPos.slice();\n\n      for (var i = 0; i < nextParents.length; ++i) {\n        if (cursor === nextParents[i]) {\n          nextParents[i] = cursor.parentNode || cursor.ownerElement;\n          if (matches) {\n            pos[i] = null;\n          }\n        } else {\n          if (matches) {\n            pos[i] = nextPos[i]++;\n            someoneUsed = true;\n          }\n        }\n      }\n      if (someoneUsed) {\n        r.nodes.unshift(cursor);\n        r.pos.unshift(pos);\n      }\n    }\n    for (var i = 0; i < r.pos.length; ++i) {\n      var lasts = [];\n      r.lasts.push(lasts);\n      for (var j = r.pos[i].length - 1; j >= 0; j--) {\n        if (null == r.pos[i][j]) {\n          r.pos[i].splice(j, j+1);\n        } else {\n          lasts.unshift(nextPos[j] - 1);\n        }\n      }\n    }\n    return r;\n  }\n\n  /** node-set, axis -> node-set */\n  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {\n    while (0 < remaining.length && null != remaining[0].ownerElement) {\n      var attr = remaining.shift();\n      if (andSelf && matcher.matches(attr)) {\n        attrNodes.push(attr);\n        attrIndices.push(nodeMultiSet.nodes.length);\n      }\n    }\n    if (null != node && !andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    var pushed = false;\n    if (null == node) {\n      if (0 === remaining.length) return;\n      node = remaining.shift();\n      nodeMultiSet.pushSeries();\n      pushed = true;\n    } else if (0 < remaining.length && node === remaining[0]) {\n      nodeMultiSet.pushSeries();\n      pushed = true;\n      remaining.shift();\n    }\n    if (andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    // TODO: use optimization. Also try element.getElementsByTagName\n    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;\n    var nodeList = node.childNodes;\n    for (var j = 0; j < nodeList.length; ++j) {\n      var child = nodeList[j];\n      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);\n    }\n    if (pushed) {\n      nodeMultiSet.popSeries();\n    }\n  }\n  function descenantHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var attrIndices = [], attrNodes = [];\n    while (0 < nodeList.length) {\n      // var node = nodeList.shift();\n      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);\n    }\n    nodeMultiSet.finalize();\n    for (var i = attrNodes.length-1; i >= 0; --i) {\n      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);\n      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);\n      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);\n    }\n    return nodeMultiSet;\n  }\n  /**\n   */\n  function ancestorHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var ancestors = []; // array of non-empty arrays of matching ancestors\n    for (var i = 0; i < nodeList.length; ++i) {\n      var node = nodeList[i];\n      var isFirst = true;\n      var a = [];\n      while (null != node) {\n        if (!isFirst || andSelf) {\n          if (matcher.matches(node))\n            a.push(node);\n        }\n        isFirst = false;\n        node = node.parentNode || node.ownerElement;\n      }\n      if (0 < a.length)\n        ancestors.push(a);\n    }\n    var lasts = [];\n    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);\n    var nodeMultiSet = new NodeMultiSet(true);\n    var newCtx = {nodes:[], pos:[], lasts:[]};\n    while (0 < ancestors.length) {\n      var pos = [ancestors[0].length];\n      var last = [lasts[0]];\n      var node = ancestors[0].pop();\n      for (var i = ancestors.length - 1; i > 0; --i) {\n        if (node === ancestors[i][ancestors[i].length - 1]) {\n          pos.push(ancestors[i].length);\n          last.push(lasts[i]);\n          ancestors[i].pop();\n          if (0 === ancestors[i].length) {\n            ancestors.splice(i, i+1);\n            lasts.splice(i, i+1);\n          }\n        }\n      }\n      if (0 === ancestors[0].length) {\n        ancestors.shift();\n        lasts.shift();\n      }\n      newCtx.nodes.push(node);\n      newCtx.pos.push(pos);\n      newCtx.lasts.push(last);\n    }\n    return newCtx;\n  }\n  /** Helper function for sortDocumentOrder. Returns a list of indices, from the\n   * node to the root, of positions within parent.\n   * For convenience, the node is the first element of the array.\n   */\n  function addressVector(node) {\n    var r = [node];\n    if (null != node.ownerElement) {\n      node = node.ownerElement;\n      r.push(-1);\n    }\n    while (null != node) {\n      var i = 0;\n      while (null != node.previousSibling) {\n        node = node.previousSibling;\n        i++;\n      }\n      r.push(i);\n      node = node.parentNode\n    }\n    return r;\n  }\n  function addressComparator(a, b) {\n    var minlen = Math.min(a.length - 1, b.length - 1),  // not including [0]=node\n        alen = a.length,\n        blen = b.length;\n    if (a[0] === b[0]) return 0;\n    var c;\n    for (var i = 0; i < minlen; ++i) {\n      c = a[alen - i - 1] - b[blen - i - 1];\n      if (0 !== c)\n        break;\n    }\n    if (null == c || 0 === c) {\n      // All equal until one of the nodes. The longer one is the descendant.\n      c = alen - blen;\n    }\n    if (0 === c)\n      c = a.nodeName - b.nodeName;\n    if (0 === c)\n      c = 1;\n    return c;\n  }\n  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function(nodes) {\n    var a = [];\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var v = addressVector(node);\n      a.push(v);\n    }\n    a.sort(addressComparator);\n    var b = [];\n    for (var i = 0; i < a.length; i++) {\n      if (0 < i && a[i][0] === a[i - 1][0])\n        continue;\n      b.push(a[i][0]);\n    }\n    return b;\n  }\n  /** Sort node multiset. Does not do any de-duping. */\n  function sortNodeMultiSet(nodeMultiSet) {\n    var a = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var v = addressVector(nodeMultiSet.nodes[i]);\n      a.push({v:v, n:nodeMultiSet.nodes[i],\n              p:nodeMultiSet.pos[i], l:nodeMultiSet.lasts[i]});\n    }\n    a.sort(compare);\n    var r = {nodes:[], pos:[], lasts:[]};\n    for (var i = 0; i < a.length; ++i) {\n      r.nodes.push(a[i].n);\n      r.pos.push(a[i].p);\n      r.lasts.push(a[i].l);\n    }\n    function compare(x, y) {\n      return addressComparator(x.v, y.v);\n    }\n    return r;\n  }\n  /** Returns an array containing all the ancestors down to a node.\n   * The array starts with document.\n   */\n  function nodeAndAncestors(node) {\n    var ancestors = [node];\n    var p = node;\n    while (p = p.parentNode || p.ownerElement) {\n      ancestors.unshift(p);\n    }\n    return ancestors;\n  }\n  function compareSiblings(a, b) {\n    if (a === b) return 0;\n    var c = a;\n    while (c = c.previousSibling) {\n      if (c === b)\n        return 1;  // b < a\n    }\n    c = b;\n    while (c = c.previousSibling) {\n      if (c === a)\n        return -1;  // a < b\n    }\n    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));\n  }\n  /** The merge in merge-sort.*/\n  function mergeNodeLists(x, y) {\n    var a, b, aanc, banc, r = [];\n    if ('object' !== typeof x)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + x);\n    if ('object' !== typeof y)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + y);\n    while (true) {\n      if (null == a) {\n        a = x.shift();\n        if (null != a)\n          aanc = addressVector(a);\n      }\n      if (null == b) {\n        b = y.shift();\n        if (null != b)\n          banc = addressVector(b);\n      }\n      if (null == a || null == b) break;\n      var c = addressComparator(aanc, banc);\n      if (c < 0) {\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (c > 0) {\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a.nodeName < b.nodeName) {  // attributes\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (a.nodeName > b.nodeName) {  // attributes\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a !== b) {\n        // choose b arbitrarily\n        r.push(b);\n        b = null;\n        banc = null;\n      } else {\n        console.assert(a === b, c);\n        // just skip b without pushing it.\n        b = null;\n        banc = null;\n      }\n    }\n    while (a) {\n      r.push(a);\n      a = x.shift();\n    }\n    while (b) {\n      r.push(b);\n      b = y.shift();\n    }\n    return r;\n  }\n  function comparisonHelper(test, x, y, isNumericComparison) {\n    var coersion;\n    if (isNumericComparison)\n      coersion = fn.number;\n    else coersion =\n      'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] :\n      'number' === typeof x || 'number' === typeof y ? fn.number :\n      fn.string;\n    if ('object' === typeof x && 'object' === typeof y) {\n      var aMap = {};\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]});\n        for (var j = 0; j < y.nodes.length; ++j) {\n          var yj = coersion({nodes:[y.nodes[j]]});\n          if (test(xi, yj)) return true;\n        }\n      }\n      return false;\n    } else if ('object' === typeof x && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]}), yc = coersion(y);\n        if (test(xi, yc))\n          return true;\n      }\n      return false;\n    } else if ('object' === typeof y && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var yi = coersion({nodes:[y.nodes[i]]}), xc = coersion(x);\n        if (test(xc, yi))\n          return true;\n      }\n      return false;\n    } else {\n      var xc = coersion(x), yc = coersion(y);\n      return test(xc, yc);\n    }\n  }\n  var axes = xpath.axes = {\n    'ancestor':\n      function ancestor(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'ancestor-or-self':\n      function ancestorOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'attribute':\n      function attribute(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO: figure out whether positions should be undefined here.\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        if (null != nodeName) {\n          // TODO: with namespace\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null == node.getAttributeNode)\n              continue;  // only Element has .getAttributeNode\n            var attr = node.getAttributeNode(nodeName);\n            if (null != attr && matcher.matches(attr)) {\n              nodeMultiSet.pushSeries();\n              nodeMultiSet.addNode(attr);\n              nodeMultiSet.popSeries();\n            }\n          }\n        } else {\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null != node.attributes) {\n              nodeMultiSet.pushSeries();\n              for (var j = 0; j < node.attributes.length; j++) {  // all nodes have .attributes\n                var attr = node.attributes[j];\n                if (matcher.matches(attr))  // TODO: I think this check is unnecessary\n                  nodeMultiSet.addNode(attr);\n              }\n              nodeMultiSet.popSeries();\n            }\n          }\n        }\n        return nodeMultiSet.finalize();\n      },\n    'child':\n      function child(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        for (var i = 0; i < nodeList.length; ++i) {\n          var n = nodeList[i];\n          if (n.ownerElement)  // skip attribute nodes' text child.\n            continue;\n          if (n.childNodes) {\n            nodeMultiSet.pushSeries();\n            var childList = 1 === nodeTypeNum && null != n.children ?\n                n.children : n.childNodes;\n            for (var j = 0; j < childList.length; ++j) {\n              var child = childList[j];\n              if (matcher.matches(child)) {\n                nodeMultiSet.addNode(child);\n              }\n              // don't have to do de-duping because children have parent,\n              // which are current context.\n            }\n            nodeMultiSet.popSeries();\n          }\n        }\n        nodeMultiSet.finalize();\n        return sortNodeMultiSet(nodeMultiSet);\n      },\n    'descendant':\n      function descenant(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'descendant-or-self':\n      function descenantOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'following':\n      function following(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'following-sibling':\n      function followingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.shift, function() {return this[0];},\n          function(node) {return node.nextSibling;});\n      },\n    'namespace':\n      function namespace(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO\n      },\n    'parent':\n      function parent(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodes = [], pos = [];\n        for (var i = 0; i < nodeList.length; ++i) {\n          var parent = nodeList[i].parentNode || nodeList[i].ownerElement;\n          if (null == parent)\n            continue;\n          if (!matcher.matches(parent))\n            continue;\n          if (nodes.length > 0 && parent === nodes[nodes.length-1])\n            continue;\n          nodes.push(parent);\n          pos.push([1]);\n        }\n        return {nodes:nodes, pos:pos, lasts:pos};\n      },\n    'preceding':\n      function preceding(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return precedingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'preceding-sibling':\n      function precedingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.pop, function() {return this[this.length-1];},\n          function(node) {return node.previousSibling},\n          false, true);\n      },\n    'self':\n      function self(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var nodes = [], pos = [];\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        for (var i = 0; i < nodeList.length; ++i) {\n          if (matcher.matches(nodeList[i])) {\n            nodes.push(nodeList[i]);\n            pos.push([1]);\n          }\n        }\n        return {nodes: nodes, pos: pos, lasts: pos}\n      }\n  };\n\n  /***************************************************************************\n   *                         Evaluation: functions                           *\n   ***************************************************************************/\n  var fn = {\n    'number': function number(optObject) {\n      if ('number' === typeof optObject)\n        return optObject;\n      if ('string' === typeof optObject)\n        return parseFloat(optObject);  // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.\n      if ('boolean' === typeof optObject)\n        return +optObject;\n      return fn.number(fn.string.call(this, optObject));  // for node-sets\n    },\n    'string': function string(optObject) {\n      if (null == optObject)\n        return fn.string(this);\n      if ('string' === typeof optObject || 'boolean' === typeof optObject ||\n          'number' === typeof optObject)\n        return '' + optObject;\n      if (0 == optObject.nodes.length) return '';\n      if (null != optObject.nodes[0].textContent)\n        return optObject.nodes[0].textContent;\n      return optObject.nodes[0].nodeValue;\n    },\n    'boolean': function booleanVal(x) {\n      return 'object' === typeof x ? x.nodes.length > 0 : !!x;\n    },\n    'last': function last() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.lasts[0].length);\n      return this.lasts[0][0];\n    },\n    'position': function position() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.pos[0].length);\n      return this.pos[0][0];\n    },\n    'count': function count(nodeSet) {\n      if ('object' !== typeof nodeSet)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Function count(node-set) ' +\n                                 'got wrong argument type: ' + nodeSet);\n      return nodeSet.nodes.length;\n    },\n    'id': function id(object) {\n      var r = {nodes: []};\n      var doc = this.nodes[0].ownerDocument || this.nodes[0];\n      console.assert(doc);\n      var ids;\n      if ('object' === typeof object) {\n        // for node-sets, map id over each node value.\n        ids = [];\n        for (var i = 0; i < object.nodes.length; ++i) {\n          var idNode = object.nodes[i];\n          var idsString = fn.string({nodes:[idNode]});\n          var a = idsString.split(/[ \\t\\r\\n]+/g);\n          Array.prototype.push.apply(ids, a);\n        }\n      } else {\n        var idsString = fn.string(object);\n        var a = idsString.split(/[ \\t\\r\\n]+/g);\n        ids = a;\n      }\n      for (var i = 0; i < ids.length; ++i) {\n        var id = ids[i];\n        if (0 === id.length)\n          continue;\n        var node = doc.getElementById(id);\n        if (null != node)\n          r.nodes.push(node);\n      }\n      r.nodes = sortUniqDocumentOrder(r.nodes);\n      return r;\n    },\n    'local-name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      // TODO: namespaced version\n      return nodeSet.nodes[0].nodeName.toLowerCase();  // TODO: no toLowerCase for xml\n    },\n    'namespace-uri': function(nodeSet) {\n      // TODO\n      throw new Error('not implemented yet');\n    },\n    'name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      return nodeSet.nodes[0].nodeName.toLowerCase();  // TODO: no toLowerCase for xml\n    },\n    'concat': function concat(x) {\n      var l = [];\n      for (var i = 0; i < arguments.length; ++i) {\n        l.push(fn.string(arguments[i]));\n      }\n      return l.join('');\n    },\n    'starts-with': function startsWith(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      return as.substr(0, bs.length) === bs;\n    },\n    'contains': function contains(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return false;\n      return true;\n    },\n    'substring-before': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(0, i);\n    },\n    'substring-after': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(i + bs.length);\n    },\n    'substring': function substring(string, start, optEnd) {\n      if (null == string || null == start) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Must be at least 2 arguments to string()');\n      }\n      var sString = fn.string(string),\n          iStart = fn.round(start),\n          iEnd = optEnd == null ? null : fn.round(optEnd);\n      // Note that xpath string positions user 1-based index\n      if (iEnd == null)\n        return sString.substr(iStart - 1);\n      else\n        return sString.substr(iStart - 1, iEnd);\n    },\n    'string-length': function stringLength(optString) {\n      return fn.string.call(this, optString).length;\n    },\n    'normalize-space': function normalizeSpace(optString) {\n      var s = fn.string.call(this, optString);\n      return s.replace(/[ \\t\\r\\n]+/g, ' ').replace(/^ | $/g, '');\n    },\n    'translate': function translate(string, from, to) {\n      var sString = fn.string.call(this, string),\n          sFrom = fn.string(from),\n          sTo = fn.string(to);\n      var eachCharRe = [];\n      var map = {};\n      for (var i = 0; i < sFrom.length; ++i) {\n        var c = sFrom.charAt(i);\n        map[c] = sTo.charAt(i);  // returns '' if beyond length of sTo.\n        // copied from goog.string.regExpEscape in the Closure library.\n        eachCharRe.push(\n          c.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').\n            replace(/\\x08/g, '\\\\x08'));\n      }\n      var re = new RegExp(eachCharRe.join('|'), 'g');\n      return sString.replace(re, function(c) {return map[c];});\n    },\n    /// Boolean functions\n    'not': function not(x) {\n      var bx = fn['boolean'](x);\n      return !bx;\n    },\n    'true': function trueVal() { return true; },\n    'false': function falseVal() { return false; },\n    // TODO\n    'lang': function lang(string) { throw new Error('Not implemented');},\n    'sum': function sum(optNodeSet) {\n      if (null == optNodeSet) return fn.sum(this);\n      // for node-sets, map id over each node value.\n      var sum = 0;\n      for (var i = 0; i < optNodeSet.nodes.length; ++i) {\n        var node = optNodeSet.nodes[i];\n        var x = fn.number({nodes:[node]});\n        sum += x;\n      }\n      return sum;\n    },\n    'floor': function floor(number) {\n      return Math.floor(fn.number(number));\n    },\n    'ceiling': function ceiling(number) {\n      return Math.ceil(fn.number(number));\n    },\n    'round': function round(number) {\n      return Math.round(fn.number(number));\n    }\n  };\n  /***************************************************************************\n   *                         Evaluation: operators                           *\n   ***************************************************************************/\n  var more = {\n    UnaryMinus: function(x) { return -fn.number(x); },\n    '+': function(x, y) { return fn.number(x) + fn.number(y); },\n    '-': function(x, y) { return fn.number(x) - fn.number(y); },\n    '*': function(x, y) { return fn.number(x) * fn.number(y); },\n    'div': function(x, y) { return fn.number(x) / fn.number(y); },\n    'mod': function(x, y) { return fn.number(x) % fn.number(y); },\n    '<': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) < fn.number(y);}, x, y, true);\n    },\n    '<=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) <= fn.number(y);}, x, y, true);\n    },\n    '>':  function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) > fn.number(y);}, x, y, true);\n    },\n    '>=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) >= fn.number(y);}, x, y, true);\n    },\n    'and': function(x, y) { return fn['boolean'](x) && fn['boolean'](y); },\n    'or': function(x, y) { return fn['boolean'](x) || fn['boolean'](y); },\n    '|': function(x, y) { return {nodes: mergeNodeLists(x.nodes, y.nodes)}; },\n    '=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x === y;}, x, y);\n      }\n    },\n    '!=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        if (0 === x.nodes.length || 0 === y.nodes.length) return false;\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (!aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x !== y;}, x, y);\n      }\n    }\n  };\n  var nodeTypes = xpath.nodeTypes = {\n    'node': 0,\n    'attribute': 2,\n    'comment': 8, // this.doc.COMMENT_NODE,\n    'text': 3, // this.doc.TEXT_NODE,\n    'processing-instruction': 7, // this.doc.PROCESSING_INSTRUCTION_NODE,\n    'element': 1  //this.doc.ELEMENT_NODE\n  };\n  /** For debugging and unit tests: returnjs a stringified version of the\n   * argument. */\n  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {\n    var seenKey = 'seen' + Math.floor(Math.random()*1000000000);\n    return JSON.stringify(helper(ctx));\n\n    function helper(ctx) {\n      if (Array.isArray(ctx)) {\n        return ctx.map(function(x) {return helper(x);});\n      }\n      if ('object' !== typeof ctx) return ctx;\n      if (null == ctx) return ctx;\n    //  if (ctx.toString) return ctx.toString();\n      if (null != ctx.outerHTML) return ctx.outerHTML;\n      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;\n      if (ctx[seenKey]) return '[circular]';\n      ctx[seenKey] = true;\n      var nicer = {};\n      for (var key in ctx) {\n        if (seenKey === key)\n          continue;\n        try {\n          nicer[key] = helper(ctx[key]);\n        } catch (e) {\n          nicer[key] = '[exception: ' + e.message + ']';\n        }\n      }\n      delete ctx[seenKey];\n      return nicer;\n    }\n  }\n  var Evaluator = xpath.Evaluator = function Evaluator(doc) {\n    this.doc = doc;\n  }\n  Evaluator.prototype = {\n    val: function val(ast, ctx) {\n      console.assert(ctx.nodes);\n\n      if ('number' === typeof ast || 'string' === typeof ast) return ast;\n      if (more[ast[0]]) {\n        var evaluatedParams = [];\n        for (var i = 1; i < ast.length; ++i) {\n          evaluatedParams.push(this.val(ast[i], ctx));\n        }\n        var r = more[ast[0]].apply(ctx, evaluatedParams);\n        return r;\n      }\n      switch (ast[0]) {\n        case 'Root': return {nodes: [this.doc]};\n        case 'FunctionCall':\n          var functionName = ast[1], functionParams = ast[2];\n          if (null == fn[functionName])\n            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                     'Unknown function: ' + functionName);\n          var evaluatedParams = [];\n          for (var i = 0; i < functionParams.length; ++i) {\n            evaluatedParams.push(this.val(functionParams[i], ctx));\n          }\n          var r = fn[functionName].apply(ctx, evaluatedParams);\n          return r;\n        case 'Predicate':\n          var lhs = this.val(ast[1], ctx);\n          var ret = {nodes: []};\n          var contexts = eachContext(lhs);\n          for (var i = 0; i < contexts.length; ++i) {\n            var singleNodeSet = contexts[i];\n            var rhs = this.val(ast[2], singleNodeSet);\n            var success;\n            if ('number' === typeof rhs) {\n              success = rhs === singleNodeSet.pos[0][0];\n            } else {\n              success = fn['boolean'](rhs);\n            }\n            if (success) {\n              var node = singleNodeSet.nodes[0];\n              ret.nodes.push(node);\n              // skip over all the rest of the same node.\n              while (i+1 < contexts.length && node === contexts[i+1].nodes[0]) {\n                i++;\n              }\n            }\n          }\n          return ret;\n        case 'PathExpr':\n          // turn the path into an expressoin; i.e., remove the position\n          // information of the last axis.\n          var x = this.val(ast[1], ctx);\n          // Make the nodeset a forward-direction-only one.\n          if (x.finalize) {  // it is a NodeMultiSet\n            for (var i = 0; i < x.nodes.length; ++i) {\n              console.assert(null != x.nodes[i].nodeType);\n            }\n            return {nodes: x.nodes};\n          } else {\n            return x;\n          }\n        case '/':\n          // TODO: don't generate '/' nodes, just Axis nodes.\n          var lhs = this.val(ast[1], ctx);\n          console.assert(null != lhs);\n          var r = this.val(ast[2], lhs);\n          console.assert(null != r);\n          return r;\n        case 'Axis':\n          // All the axis tests from Step. We only get AxisSpecifier NodeTest,\n          // not the predicate (which is applied later)\n          var axis = ast[1],\n              nodeType = ast[2],\n              nodeTypeNum = nodeTypes[nodeType],\n              shouldLowerCase = true,  // TODO: give option\n              nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];\n          nodeName = nodeName === '*' ? null : nodeName;\n          if ('object' !== typeof ctx) return {nodes:[], pos:[]};\n          var nodeList = ctx.nodes.slice();  // TODO: is copy needed?\n          var r = axes[axis](nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n          return r;\n      }\n    }\n  };\n  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {\n    //var astFactory = new AstEvaluatorFactory(doc, context);\n    var stream = new Stream(expr);\n    var ast = parse(stream, astFactory);\n    var val = new Evaluator(doc).val(ast, {nodes: [context]});\n    return val;\n  }\n\n  /***************************************************************************\n   *                           DOM interface                                 *\n   ***************************************************************************/\n  var XPathException = xpath.XPathException = function XPathException(code, message) {\n    var e = new Error(message);\n    e.name = 'XPathException';\n    e.code = code;\n    return e;\n  }\n  XPathException.INVALID_EXPRESSION_ERR = 51;\n  XPathException.TYPE_ERR = 52;\n\n\n  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {}\n  XPathEvaluator.prototype = {\n    createExpression: function(expression, resolver) {\n      return new XPathExpression(expression, resolver);\n    },\n    createNSResolver: function(nodeResolver) {\n      // TODO\n    },\n    evaluate: function evaluate(expression, contextNode, resolver, type, result) {\n      var expr = new XPathExpression(expression, resolver);\n      return expr.evaluate(contextNode, type, result);\n    }\n  };\n\n\n  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {\n    var stream = new Stream(expression);\n    this._ast = parse(stream, astFactory);\n    this._doc = optDoc;\n  }\n  XPathExpression.prototype = {\n    evaluate: function evaluate(contextNode, type, result) {\n      if (null == contextNode.nodeType)\n        throw new Error('bad argument (expected context node): ' + contextNode);\n      var doc = contextNode.ownerDocument || contextNode;\n      if (null != this._doc && this._doc !== doc) {\n        throw new core.DOMException(\n            core.WRONG_DOCUMENT_ERR,\n            'The document must be the same as the context node\\'s document.');\n      }\n      var evaluator = new Evaluator(doc);\n      var value = evaluator.val(this._ast, {nodes: [contextNode]});\n      if (XPathResult.NUMBER_TYPE === type)\n        value = fn.number(value);\n      else if (XPathResult.STRING_TYPE === type)\n        value = fn.string(value);\n      else if (XPathResult.BOOLEAN_TYPE === type)\n        value = fn['boolean'](value);\n      else if (XPathResult.ANY_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ANY_UNORDERED_NODE_TYPE !== type &&\n               XPathResult.FIRST_ORDERED_NODE_TYPE !== type)\n        throw new core.DOMException(\n            core.NOT_SUPPORTED_ERR,\n            'You must provide an XPath result type (0=any).');\n      else if (XPathResult.ANY_TYPE !== type &&\n               'object' !== typeof value)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'Value should be a node-set: ' + value);\n      return new XPathResult(doc, value, type);\n    }\n  }\n\n  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {\n    this._value = value;\n    this._resultType = resultType;\n    this._i = 0;\n    this._invalidated = false;\n    if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||\n        this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n      doc.addEventListener('DOMSubtreeModified', invalidate, true);\n      var self = this;\n      function invalidate() {\n        self._invalidated = true;\n        doc.removeEventListener('DOMSubtreeModified', invalidate, true);\n      }\n    }\n  }\n  XPathResult.ANY_TYPE = 0;\n  XPathResult.NUMBER_TYPE = 1;\n  XPathResult.STRING_TYPE = 2;\n  XPathResult.BOOLEAN_TYPE = 3;\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\n  var proto = {\n    // XPathResultType\n    get resultType() {\n      if (this._resultType) return this._resultType;\n      switch (typeof this._value) {\n        case 'number': return XPathResult.NUMBER_TYPE;\n        case 'string': return XPathResult.STRING_TYPE;\n        case 'boolean': return XPathResult.BOOLEAN_TYPE;\n        default: return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n      }\n    },\n    get numberValue() {\n      if (XPathResult.NUMBER_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a NUMBER_TYPE.');\n      return this._value;\n    },\n    get stringValue() {\n      if (XPathResult.STRING_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a STRING_TYPE.');\n      return this._value;\n    },\n    get booleanValue() {\n      if (XPathResult.BOOLEAN_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a BOOLEAN_TYPE.');\n      return this._value;\n    },\n    get singleNodeValue() {\n      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType &&\n          XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a FIRST_ORDERED_NODE_TYPE.');\n      return this._value.nodes[0] || null;\n    },\n    get invalidIteratorState() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        return false;\n      return !!this._invalidated;\n    },\n    get snapshotLength() {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes.length;\n    },\n    iterateNext: function iterateNext() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');\n      if (this.invalidIteratorState)\n        throw new core.DOMException(\n            core.INVALID_STATE_ERR,\n            'The document has been mutated since the result was returned');\n      return this._value.nodes[this._i++] || null;\n    },\n    snapshotItem: function snapshotItem(index) {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes[index] || null;\n    }\n  };\n  // so you can access ANY_TYPE etc. from the instances:\n  XPathResult.prototype = Object.create(XPathResult,\n      Object.keys(proto).reduce(function (descriptors, name) {\n        descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\n        return descriptors;\n      }, {\n        constructor: {\n          value: XPathResult,\n          writable: true,\n          configurable: true\n        }\n      }));\n\n  core.XPathException = XPathException;\n  core.XPathExpression = XPathExpression;\n  core.XPathResult = XPathResult;\n  core.XPathEvaluator = XPathEvaluator;\n\n  core.Document.prototype.createExpression =\n    XPathEvaluator.prototype.createExpression;\n\n  core.Document.prototype.createNSResolver =\n      XPathEvaluator.prototype.createNSResolver;\n\n  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level3/events.js":"var events = require(\"../level2/events\").dom.level2.events;\n\n// modify cloned instance for more info check: https://github.com/tmpvar/jsdom/issues/325\nevents = Object.create(events);\n\n/*\n\n// File: events.idl\n\n#ifndef _EVENTS_IDL_\n#define _EVENTS_IDL_\n\n#include \"dom.idl\"\n#include \"views.idl\"\n\n#pragma prefix \"dom.w3c.org\"\nmodule events\n{\n\n  typedef dom::DOMString DOMString;\n  typedef dom::DOMTimeStamp DOMTimeStamp;\n  typedef dom::DOMObject DOMObject;\n  typedef dom::Node Node;\n\n  interface EventTarget;\n  interface EventListener;\n\n  // Introduced in DOM Level 2:\n  exception EventException {\n    unsigned short   code;\n  };\n  // EventExceptionCode\n  const unsigned short      UNSPECIFIED_EVENT_TYPE_ERR     = 0;\n  // Introduced in DOM Level 3:\n  const unsigned short      DISPATCH_REQUEST_ERR           = 1;\n\n\n  // Introduced in DOM Level 2:\n  interface Event {\n\n    // PhaseType\n    const unsigned short      CAPTURING_PHASE                = 1;\n    const unsigned short      AT_TARGET                      = 2;\n    const unsigned short      BUBBLING_PHASE                 = 3;\n\n    readonly attribute DOMString       type;\n    readonly attribute EventTarget     target;\n    readonly attribute EventTarget     currentTarget;\n    readonly attribute unsigned short  eventPhase;\n    readonly attribute boolean         bubbles;\n    readonly attribute boolean         cancelable;\n    readonly attribute DOMTimeStamp    timeStamp;\n    void               stopPropagation();\n    void               preventDefault();\n    void               initEvent(in DOMString eventTypeArg,\n                                 in boolean canBubbleArg,\n                                 in boolean cancelableArg);\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       namespaceURI;\n    // Introduced in DOM Level 3:\n    boolean            isCustom();\n    // Introduced in DOM Level 3:\n    void               stopImmediatePropagation();\n    // Introduced in DOM Level 3:\n    boolean            isDefaultPrevented();\n    // Introduced in DOM Level 3:\n    void               initEventNS(in DOMString namespaceURIArg,\n                                   in DOMString eventTypeArg,\n                                   in boolean canBubbleArg,\n                                   in boolean cancelableArg);\n  };\n\n  // Introduced in DOM Level 2:\n  interface EventTarget {\n    void               addEventListener(in DOMString type,\n                                        in EventListener listener,\n                                        in boolean useCapture);\n    void               removeEventListener(in DOMString type,\n                                           in EventListener listener,\n                                           in boolean useCapture);\n    // Modified in DOM Level 3:\n    boolean            dispatchEvent(in Event evt)\n                                        raises(EventException);\n    // Introduced in DOM Level 3:\n    void               addEventListenerNS(in DOMString namespaceURI,\n                                          in DOMString type,\n                                          in EventListener listener,\n                                          in boolean useCapture,\n                                          in DOMObject evtGroup);\n    // Introduced in DOM Level 3:\n    void               removeEventListenerNS(in DOMString namespaceURI,\n                                             in DOMString type,\n                                             in EventListener listener,\n                                             in boolean useCapture);\n    // Introduced in DOM Level 3:\n    boolean            willTriggerNS(in DOMString namespaceURI,\n                                     in DOMString type);\n    // Introduced in DOM Level 3:\n    boolean            hasEventListenerNS(in DOMString namespaceURI,\n                                          in DOMString type);\n  };\n\n  // Introduced in DOM Level 2:\n  interface EventListener {\n    void               handleEvent(in Event evt);\n  };\n\n  // Introduced in DOM Level 2:\n  interface DocumentEvent {\n    Event              createEvent(in DOMString eventType)\n                                        raises(dom::DOMException);\n    // Introduced in DOM Level 3:\n    boolean            canDispatch(in DOMString namespaceURI,\n                                   in DOMString type);\n  };\n\n  // Introduced in DOM Level 3:\n  interface CustomEvent : Event {\n    void               setDispatchState(in EventTarget target,\n                                        in unsigned short phase);\n    boolean            isPropagationStopped();\n    boolean            isImmediatePropagationStopped();\n  };\n\n  // Introduced in DOM Level 2:\n  interface UIEvent : Event {\n    readonly attribute views::AbstractView view;\n    readonly attribute long            detail;\n    void               initUIEvent(in DOMString typeArg,\n                                   in boolean canBubbleArg,\n                                   in boolean cancelableArg,\n                                   in views::AbstractView viewArg,\n                                   in long detailArg);\n    // Introduced in DOM Level 3:\n    void               initUIEventNS(in DOMString namespaceURI,\n                                     in DOMString typeArg,\n                                     in boolean canBubbleArg,\n                                     in boolean cancelableArg,\n                                     in views::AbstractView viewArg,\n                                     in long detailArg);\n  };\n\n  // Introduced in DOM Level 3:\n  interface TextEvent : UIEvent {\n    readonly attribute DOMString       data;\n    void               initTextEvent(in DOMString typeArg,\n                                     in boolean canBubbleArg,\n                                     in boolean cancelableArg,\n                                     in views::AbstractView viewArg,\n                                     in DOMString dataArg);\n    void               initTextEventNS(in DOMString namespaceURI,\n                                       in DOMString type,\n                                       in boolean canBubbleArg,\n                                       in boolean cancelableArg,\n                                       in views::AbstractView viewArg,\n                                       in DOMString dataArg);\n  };\n\n  // Introduced in DOM Level 2:\n  interface MouseEvent : UIEvent {\n    readonly attribute long            screenX;\n    readonly attribute long            screenY;\n    readonly attribute long            clientX;\n    readonly attribute long            clientY;\n    readonly attribute boolean         ctrlKey;\n    readonly attribute boolean         shiftKey;\n    readonly attribute boolean         altKey;\n    readonly attribute boolean         metaKey;\n    readonly attribute unsigned short  button;\n    readonly attribute EventTarget     relatedTarget;\n    void               initMouseEvent(in DOMString typeArg,\n                                      in boolean canBubbleArg,\n                                      in boolean cancelableArg,\n                                      in views::AbstractView viewArg,\n                                      in long detailArg,\n                                      in long screenXArg,\n                                      in long screenYArg,\n                                      in long clientXArg,\n                                      in long clientYArg,\n                                      in boolean ctrlKeyArg,\n                                      in boolean altKeyArg,\n                                      in boolean shiftKeyArg,\n                                      in boolean metaKeyArg,\n                                      in unsigned short buttonArg,\n                                      in EventTarget relatedTargetArg);\n    // Introduced in DOM Level 3:\n    boolean            getModifierState(in DOMString keyIdentifierArg);\n    // Introduced in DOM Level 3:\n    void               initMouseEventNS(in DOMString namespaceURI,\n                                        in DOMString typeArg,\n                                        in boolean canBubbleArg,\n                                        in boolean cancelableArg,\n                                        in views::AbstractView viewArg,\n                                        in long detailArg,\n                                        in long screenXArg,\n                                        in long screenYArg,\n                                        in long clientXArg,\n                                        in long clientYArg,\n                                        in unsigned short buttonArg,\n                                        in EventTarget relatedTargetArg,\n                                        in DOMString modifiersList);\n  };\n\n  // Introduced in DOM Level 3:\n  interface KeyboardEvent : UIEvent {\n\n    // KeyLocationCode\n    const unsigned long       DOM_KEY_LOCATION_STANDARD      = 0x00;\n    const unsigned long       DOM_KEY_LOCATION_LEFT          = 0x01;\n    const unsigned long       DOM_KEY_LOCATION_RIGHT         = 0x02;\n    const unsigned long       DOM_KEY_LOCATION_NUMPAD        = 0x03;\n\n    readonly attribute DOMString       keyIdentifier;\n    readonly attribute unsigned long   keyLocation;\n    readonly attribute boolean         ctrlKey;\n    readonly attribute boolean         shiftKey;\n    readonly attribute boolean         altKey;\n    readonly attribute boolean         metaKey;\n    boolean            getModifierState(in DOMString keyIdentifierArg);\n    void               initKeyboardEvent(in DOMString typeArg,\n                                         in boolean canBubbleArg,\n                                         in boolean cancelableArg,\n                                         in views::AbstractView viewArg,\n                                         in DOMString keyIdentifierArg,\n                                         in unsigned long keyLocationArg,\n                                         in DOMString modifiersList);\n    void               initKeyboardEventNS(in DOMString namespaceURI,\n                                           in DOMString typeArg,\n                                           in boolean canBubbleArg,\n                                           in boolean cancelableArg,\n                                           in views::AbstractView viewArg,\n                                           in DOMString keyIdentifierArg,\n                                           in unsigned long keyLocationArg,\n                                           in DOMString modifiersList);\n  };\n\n  // Introduced in DOM Level 2:\n  interface MutationEvent : Event {\n\n    // attrChangeType\n    const unsigned short      MODIFICATION                   = 1;\n    const unsigned short      ADDITION                       = 2;\n    const unsigned short      REMOVAL                        = 3;\n\n    readonly attribute Node            relatedNode;\n    readonly attribute DOMString       prevValue;\n    readonly attribute DOMString       newValue;\n    readonly attribute DOMString       attrName;\n    readonly attribute unsigned short  attrChange;\n    void               initMutationEvent(in DOMString typeArg,\n                                         in boolean canBubbleArg,\n                                         in boolean cancelableArg,\n                                         in Node relatedNodeArg,\n                                         in DOMString prevValueArg,\n                                         in DOMString newValueArg,\n                                         in DOMString attrNameArg,\n                                         in unsigned short attrChangeArg);\n    // Introduced in DOM Level 3:\n    void               initMutationEventNS(in DOMString namespaceURI,\n                                           in DOMString typeArg,\n                                           in boolean canBubbleArg,\n                                           in boolean cancelableArg,\n                                           in Node relatedNodeArg,\n                                           in DOMString prevValueArg,\n                                           in DOMString newValueArg,\n                                           in DOMString attrNameArg,\n                                           in unsigned short attrChangeArg);\n  };\n\n  // Introduced in DOM Level 3:\n  interface MutationNameEvent : MutationEvent {\n    readonly attribute DOMString       prevNamespaceURI;\n    readonly attribute DOMString       prevNodeName;\n    // Introduced in DOM Level 3:\n    void               initMutationNameEvent(in DOMString typeArg,\n                                             in boolean canBubbleArg,\n                                             in boolean cancelableArg,\n                                             in Node relatedNodeArg,\n                                             in DOMString prevNamespaceURIArg,\n                                             in DOMString prevNodeNameArg);\n    // Introduced in DOM Level 3:\n    void               initMutationNameEventNS(in DOMString namespaceURI,\n                                               in DOMString typeArg,\n                                               in boolean canBubbleArg,\n                                               in boolean cancelableArg,\n                                               in Node relatedNodeArg,\n                                               in DOMString prevNamespaceURIArg,\n                                               in DOMString prevNodeNameArg);\n  };\n};\n\n#endif // _EVENTS_IDL_\n*/\n\nexports.dom = {\n  level3 : {\n    events:  events\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level3/html.js":"var core = require(\"./core\").dom.level3.core,\n    html = require(\"../level2/html\").dom.level2.html\n\nexports.dom = {\n  level3 : {\n    html : html,\n    core : core\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/level3/ls.js":"// w3c Load/Save functionality: http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/\n\nvar core = require('./core').dom.level3.core;\nvar events = require('./events').dom.level3.events;\nvar createFrom = require('../utils').createFrom;\n\nvar ls = {};\n\n// TODO: what is this?\n//typedef dom::DOMConfiguration DOMConfiguration;\n\nls.LSException = function LSException(code) {\n  this.code = code;\n};\n\nls.LSException.prototype = {\n  // LSExceptionCode\n  PARSE_ERR                       : 81,\n  SERIALIZE_ERR                   : 82\n};\n\nls.DOMImplementationLS = function DOMImplementationLS() {\n\n};\n\nvar DOMImplementationExtension = {\n\n  // DOMImplementationLSMode\n  MODE_SYNCHRONOUS  : 1,\n  MODE_ASYNCHRONOUS : 2,\n\n  // raises(dom::DOMException);\n  createLSParser : function(/* int */ mode, /* string */ schemaType) {\n    return new ls.LSParser(mode, schemaType);\n  },\n\n  createLSSerializer : function() {\n    return new ls.LSSerializer();\n  },\n\n  createLSInput : function() {\n    return new ls.LSInput();\n  },\n\n  createLSOutput : function() {\n    return new ls.LSOutput();\n  }\n};\n\nObject.keys(DOMImplementationExtension).forEach(function(k, v) {\n  core.DOMImplementation.prototype[k] = DOMImplementationExtension[k];\n});\n\nls.DOMImplementationLS.prototype = DOMImplementationExtension; \n\ncore.Document.getFeature = function() {\n  return DOMImplementationExtension;\n};\n\nls.LSParser = function LSParser() {\n  this._domConfig = new core.DOMConfiguration();\n};\nls.LSParser.prototype = {\n  get domConfig() { return this._domConfig; },\n  get filter() { return this._filter || null; },\n  set filter(value) { this._filter = value; },\n  get async() { return this._async; },\n  get busy() { return this._busy; },\n\n  // raises(dom::DOMException, LSException);\n  parse : function (/* LSInput */ input) {\n    var doc = new core.Document();\n    doc._inputEncoding = 'UTF-16';\n    return doc;\n  },\n\n  // raises(dom::DOMException, LSException);\n  parseURI : function(/* string */ uri) {\n    return new core.Document();\n  },\n\n  // ACTION_TYPES\n  ACTION_APPEND_AS_CHILDREN       : 1,\n  ACTION_REPLACE_CHILDREN         : 2,\n  ACTION_INSERT_BEFORE            : 3,\n  ACTION_INSERT_AFTER             : 4,\n  ACTION_REPLACE                  : 5,\n\n  // @returns Node\n  // @raises DOMException, LSException\n  parseWithContext                : function(/* LSInput */ input, /* Node */ contextArg, /* int */ action) {\n    return new core.Node();\n  },\n\n  abort                           : function() {\n    // TODO: implement\n  }\n};\n\nls.LSInput = function LSInput() {};\nls.LSInput.prototype = {\n  get characterStream() { return this._characterStream || null; },\n  set characterStream(value) { this._characterStream = value; },\n  get byteStream() { return this._byteStream || null; },\n  set byteStream(value) { this._byteStream = value; },\n  get stringData() { return this._stringData || null; },\n  set stringData(value) { this._stringData = value; },\n  get systemId() { return this._systemId || null; },\n  set systemId(value) { this._systemId = value; },\n  get publicId() { return this._publicId || null; },\n  set publicId(value) { this._publicId = value; },\n  get baseURI() { return this._baseURI || null; },\n  set baseURI(value) { this._baseURI = value; },\n  get encoding() { return this._encoding || null; },\n  set encoding(value) { this._encoding = value; },\n  get certifiedText() { return this._certifiedText || null; },\n  set certifiedText(value) { this._certifiedText = value; },\n};\n\nls.LSResourceResolver = function LSResourceResolver() {};\n\n// @returns LSInput\nls.LSResourceResolver.prototype.resolveResource = function(type, namespaceURI, publicId, systemId, baseURI) {\n  return new ls.LSInput();\n};\n\nls.LSParserFilter = function LSParserFilter() {};\nls.LSParserFilter.prototype = {\n\n  // Constants returned by startElement and acceptNode\n  FILTER_ACCEPT                   : 1,\n  FILTER_REJECT                   : 2,\n  FILTER_SKIP                     : 3,\n  FILTER_INTERRUPT                : 4,\n\n  get whatToShow() { return this._whatToShow; },\n\n  // @returns int\n  startElement : function(/* Element */ elementArg) {\n    return 0;\n  },\n\n  // @returns int\n  acceptNode : function(/* Node */ nodeArg) {\n    return nodeArg;\n  }\n};\n\nls.LSSerializer = function LSSerializer() {\n  this._domConfig = new core.DOMConfiguration();\n};\nls.LSSerializer.prototype = {\n  get domConfig() { return this._domConfig; },\n  get newLine() { return this._newLine || null; },\n  set newLine(value) { this._newLine = value; },\n  get filter() { return this._filter || null; },\n  set filter(value) { this._filter = value; },\n\n  // @returns boolean\n  // @raises LSException\n  write : function(/* Node */ nodeArg, /* LSOutput */ destination) {\n   return true;\n  },\n\n  // @returns boolean\n  // @raises LSException\n  writeToURI : function(/* Node */ nodeArg, /* string */ uri) {\n   return true;\n  },\n\n  // @returns string\n  // @raises DOMException, LSException\n  writeToString : function(/* Node */ nodeArg) {\n    return \"\";\n  }\n};\n\nls.LSOutput = function LSOutput() {};\nls.LSOutput.prototype = {\n  get characterStream() { return this._characterStream || null; },\n  set characterStream(value) { this._characterStream = value; },\n  get byteStream() { return this._byteStream || null; },\n  set byteStream(value) { this._byteStream = value; },\n  get systemId() { return this._systemId || null; },\n  set systemId(value) { this._systemId = value; },\n  get encoding() { return this._encoding || null; },\n  set encoding(value) { this._encoding = value; },\n};\n\nls.LSProgressEvent = function LSProgressEvent() {};\nls.LSProgressEvent.prototype = createFrom(events.Event, {\n  constructor: ls.LSProgressEvent,\n  get input() { return this._input; },\n  get position() { return this._position; },\n  get totalSize() { return this._totalSize; },\n});\n\nls.LSLoadEvent = function LSLoadEvent() {};\nls.LSLoadEvent.prototype = createFrom(events.Event, {\n  get newDocument() { return this._newDocument; },\n  get input() { return this._input; },\n});\n\n\n// TODO: do traversal\nls.LSSerializerFilter = function LSSerializerFilter() {};\nls.LSSerializerFilter.prototype = {\n  get whatToShow() { return this._whatToShow; },\n};\n\n// ls.LSSerializerFilter.prototype.__proto__ = level2.traversal.NodeFiler;\n\n// Export\nmodule.exports.dom = {\n  level3 : {\n    ls : ls \n  }\n};\n\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/browser/index.js":"var http          = require('http'),\n    URL           = require('url'),\n    HtmlToDom     = require('./htmltodom').HtmlToDom,\n    domToHtml     = require('./domtohtml').domToHtml,\n    jsdom         = require('../../jsdom'),\n    Location      = require('./location'),\n    History       = require('./history'),\n    NOT_IMPLEMENTED = require('./utils').NOT_IMPLEMENTED,\n    CSSStyleDeclaration = require('cssstyle').CSSStyleDeclaration,\n    toFileUrl = require('../utils').toFileUrl,\n    defineGetter  = require('../utils').defineGetter,\n    defineSetter  = require('../utils').defineSetter,\n    createFrom    = require('../utils').createFrom,\n    Contextify    = require('contextify');\n\nfunction matchesDontThrow(el, selector) {\n  try {\n    return el.matchesSelector(selector);\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Creates a window having a document. The document can be passed as option,\n * if omitted, a new document will be created.\n */\nexports.windowAugmentation = function(dom, options) {\n  options = options || {};\n  var window = exports.createWindow(dom, options);\n\n  if (!options.document) {\n    var browser = browserAugmentation(dom, options);\n\n    options.document = (browser.HTMLDocument)             ?\n                        new browser.HTMLDocument(options) :\n                        new browser.Document(options);\n\n\n\n    options.document.write('<html><head></head><body></body></html>');\n  }\n\n  var doc = window.document = options.document;\n\n  if (doc.addEventListener) {\n    if (doc.readyState == 'complete') {\n      var ev = doc.createEvent('HTMLEvents');\n      ev.initEvent('load', false, false);\n      process.nextTick(function () {\n        window.dispatchEvent(ev);\n      });\n    }\n    else {\n      doc.addEventListener('load', function(ev) {\n        window.dispatchEvent(ev);\n      });\n    }\n  }\n\n  return window;\n};\n\n/**\n * Creates a document-less window.\n */\nexports.createWindow = function(dom, options) {\n  var timers = [];\n  var cssSelectorSplitRE = /((?:[^,\"']|\"[^\"]*\"|'[^']*')+)/;\n\n  function startTimer(startFn, stopFn, callback, ms) {\n    var res = startFn(callback, ms);\n    timers.push( [ res, stopFn ] );\n    return res;\n  }\n\n  function stopTimer(id) {\n    if (typeof id === 'undefined') {\n      return;\n    }\n    for (var i in timers) {\n      if (timers[i][0] === id) {\n        timers[i][1].call(this, id);\n        timers.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  function stopAllTimers() {\n    timers.forEach(function (t) {\n      t[1].call(this, t[0]);\n    });\n    timers = [];\n  }\n\n  function DOMWindow(options) {\n    var url = (options || {}).url || toFileUrl(__filename);\n    this.location = new Location(url, this);\n    this.history = new History(this);\n\n    this.console._window = this;\n\n    if (options && options.document) {\n      options.document.location = this.location;\n    }\n\n    this.addEventListener = function() {\n      dom.Node.prototype.addEventListener.apply(window, arguments);\n    };\n    this.removeEventListener = function() {\n      dom.Node.prototype.removeEventListener.apply(window, arguments);\n    };\n    this.dispatchEvent = function() {\n      dom.Node.prototype.dispatchEvent.apply(window, arguments);\n    };\n    this.raise = function(){\n      dom.Node.prototype.raise.apply(window.document, arguments);\n    };\n\n    this.setTimeout = function (fn, ms) { return startTimer(setTimeout, clearTimeout, fn, ms); };\n    this.setInterval = function (fn, ms) { return startTimer(setInterval, clearInterval, fn, ms); };\n    this.clearInterval = stopTimer;\n    this.clearTimeout = stopTimer;\n    this.__stopAllTimers = stopAllTimers;\n  }\n\n  DOMWindow.prototype = createFrom(dom || null, {\n    constructor: DOMWindow,\n    // This implements window.frames.length, since window.frames returns a\n    // self reference to the window object.  This value is incremented in the\n    // HTMLFrameElement init function (see: level2/html.js).\n    _length : 0,\n    get length () {\n      return this._length;\n    },\n    close : function() {\n      // Recursively close child frame windows, then ourselves.\n      var currentWindow = this;\n      (function windowCleaner (window) {\n        var i;\n        // We could call window.frames.length etc, but window.frames just points\n        // back to window.\n        if (window.length > 0) {\n          for (i = 0; i < window.length; i++) {\n            windowCleaner(window[i]);\n          }\n        }\n        // We're already in our own window.close().\n        if (window !== currentWindow) {\n          window.close();\n        }\n      })(this);\n\n      if (this.document) {\n        if (this.document.body) {\n          this.document.body.innerHTML = \"\";\n        }\n\n        if (this.document.close) {\n          // We need to empty out the event listener array because\n          // document.close() causes 'load' event to re-fire.\n          this.document._listeners = [];\n          this.document.close();\n        }\n        delete this.document;\n      }\n\n      stopAllTimers();\n      // Clean up the window's execution context.\n      // dispose() is added by Contextify.\n      this.dispose();\n    },\n    getComputedStyle: function(node) {\n      var s = node.style,\n          cs = new CSSStyleDeclaration(),\n          forEach = Array.prototype.forEach;\n\n      function setPropertiesFromRule(rule) {\n        if (!rule.selectorText) {\n          return;\n        }\n\n        var selectors = rule.selectorText.split(cssSelectorSplitRE);\n        var matched = false;\n        selectors.forEach(function (selectorText) {\n          if (selectorText !== '' && selectorText !== ',' && !matched && matchesDontThrow(node, selectorText)) {\n            matched = true;\n            forEach.call(rule.style, function (property) {\n              cs.setProperty(property, rule.style.getPropertyValue(property), rule.style.getPropertyPriority(property));\n            });\n          }\n        });\n      }\n\n      forEach.call(node.ownerDocument.styleSheets, function (sheet) {\n        forEach.call(sheet.cssRules, function (rule) {\n          if (rule.media) {\n            if (Array.prototype.indexOf.call(rule.media, 'screen') !== -1) {\n              forEach.call(rule.cssRules, setPropertiesFromRule);\n            }\n          } else {\n            setPropertiesFromRule(rule);\n          }\n        });\n      });\n\n      forEach.call(s, function (property) {\n        cs.setProperty(property, s.getPropertyValue(property), s.getPropertyPriority(property));\n      });\n\n      return cs;\n    },\n    console: {\n      log:   function(message) { this._window.raise('log',   message) },\n      info:  function(message) { this._window.raise('info',  message) },\n      warn:  function(message) { this._window.raise('warn',  message) },\n      error: function(message) { this._window.raise('error', message) }\n    },\n    navigator: {\n      get userAgent() { return 'Node.js (' + process.platform + '; U; rv:' + process.version + ')'; },\n      get appName() { return 'Node.js jsDom'; },\n      get platform() { return process.platform; },\n      get appVersion() { return process.version; },\n      noUI: true,\n      get cookieEnabled() { return true; }\n    },\n    XMLHttpRequest: function() {\n      var XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\n      var xhr = new XMLHttpRequest();\n      var lastUrl = '';\n      xhr._open = xhr.open;\n      xhr.open = function(method, url, async, user, password) {\n        url = URL.resolve(options.url, url);\n        lastUrl = url;\n        return xhr._open(method, url, async, user, password);\n      };\n      xhr._send = xhr.send;\n      xhr.send = function(data) {\n        if (window.document.cookie) {\n          var cookieDomain = window.document._cookieDomain;\n          var url = URL.parse(lastUrl);\n          var host = url.host.split(':')[0];\n          if (host.indexOf(cookieDomain, host.length - cookieDomain.length) !== -1) {\n            xhr.setDisableHeaderCheck(true);\n            xhr.setRequestHeader('cookie', window.document.cookie);\n            xhr.setDisableHeaderCheck(false);\n          }\n        }\n        return xhr._send(data);\n      };\n      return xhr;\n    },\n\n    name: 'nodejs',\n    innerWidth: 1024,\n    innerHeight: 768,\n    outerWidth: 1024,\n    outerHeight: 768,\n    pageXOffset: 0,\n    pageYOffset: 0,\n    screenX: 0,\n    screenY: 0,\n    screenLeft: 0,\n    screenTop: 0,\n    scrollX: 0,\n    scrollY: 0,\n    scrollTop: 0,\n    scrollLeft: 0,\n    alert: NOT_IMPLEMENTED(null, 'window.alert'),\n    blur: NOT_IMPLEMENTED(null, 'window.blur'),\n    confirm: NOT_IMPLEMENTED(null, 'window.confirm'),\n    createPopup: NOT_IMPLEMENTED(null, 'window.createPopup'),\n    focus: NOT_IMPLEMENTED(null, 'window.focus'),\n    moveBy: NOT_IMPLEMENTED(null, 'window.moveBy'),\n    moveTo: NOT_IMPLEMENTED(null, 'window.moveTo'),\n    open: NOT_IMPLEMENTED(null, 'window.open'),\n    print: NOT_IMPLEMENTED(null, 'window.print'),\n    prompt: NOT_IMPLEMENTED(null, 'window.prompt'),\n    resizeBy: NOT_IMPLEMENTED(null, 'window.resizeBy'),\n    resizeTo: NOT_IMPLEMENTED(null, 'window.resizeTo'),\n    scroll: NOT_IMPLEMENTED(null, 'window.scroll'),\n    scrollBy: NOT_IMPLEMENTED(null, 'window.scrollBy'),\n    scrollTo: NOT_IMPLEMENTED(null, 'window.scrollTo'),\n    screen : {\n      width : 0,\n      height : 0\n    },\n    Image : NOT_IMPLEMENTED(null, 'window.Image'),\n\n    // Note: these will not be necessary for newer Node.js versions, which have\n    // typed arrays in V8 and thus on every global object. (That is, in newer\n    // versions we'll get `ArrayBuffer` just as automatically as we get\n    // `Array`.) But to support older versions, we explicitly set them here.\n    Int8Array: global.Int8Array,\n    Int16Array: global.Int16Array,\n    Int32Array: global.Int32Array,\n    Float32Array: global.Float32Array,\n    Float64Array: global.Float64Array,\n    Uint8Array: global.Uint8Array,\n    Uint8ClampedArray: global.Uint8ClampedArray,\n    Uint16Array: global.Uint16Array,\n    Uint32Array: global.Uint32Array,\n    ArrayBuffer: global.ArrayBuffer\n  });\n\n  var window = new DOMWindow(options);\n\n  Contextify(window);\n\n  // We need to set up self references using Contextify's getGlobal() so that\n  // the global object identity is correct (window === this).\n  // See Contextify README for more info.\n  var windowGlobal = window.getGlobal();\n\n  // Set up the window as if it's a top level window.\n  // If it's not, then references will be corrected by frame/iframe code.\n  // Note: window.frames is maintained in the HTMLFrameElement init function.\n  window.window = window.frames\n                = window.self\n                = window.parent\n                = window.top = windowGlobal;\n\n  return window;\n};\n\n//Caching for HTMLParser require. HUGE performace boost.\n/**\n* 5000 iterations\n* Without cache: ~1800+ms\n* With cache: ~80ms\n*/\n// TODO: is this even needed in modern Node.js versions?\nvar defaultParser = null;\nvar getDefaultParser = exports.getDefaultParser = function () {\n  if (defaultParser === null) {\n    defaultParser = require('parse5');\n  }\n  return defaultParser;\n}\n\n/**\n * Export getter/setter of default parser to facilitate testing\n * with different HTML parsers.\n */\nexports.setDefaultParser = function (parser) {\n  if (typeof parser == 'object') {\n    defaultParser = parser;\n  } else if (typeof parser == 'string')\n    defaultParser = require(parser);\n}\n\n/**\n * Augments the given DOM by adding browser-specific properties and methods (BOM).\n * Returns the augmented DOM.\n */\nvar browserAugmentation = exports.browserAugmentation = function(dom, options) {\n\n  if(!options) {\n    options = {};\n  }\n\n  // set up html parser - use a provided one or try and load from library\n  var parser = options.parser || getDefaultParser();\n\n  if (dom._augmented && dom._parser === parser) {\n    return dom;\n  }\n\n  dom._parser = parser;\n  var htmltodom = new HtmlToDom(parser);\n\n  if (!dom.HTMLDocument) {\n    dom.HTMLDocument = dom.Document;\n  }\n  if (!dom.HTMLDocument.prototype.write) {\n    dom.HTMLDocument.prototype.write = function(html) {\n      this.innerHTML = html;\n    };\n  }\n\n  dom.Element.prototype.getElementsByClassName = function(className) {\n\n    function filterByClassName(child) {\n      if (!child) {\n        return false;\n      }\n\n      if (child.nodeType &&\n          child.nodeType === dom.Node.ENTITY_REFERENCE_NODE)\n      {\n        child = child._entity;\n      }\n\n      var classString = child.className;\n      if (classString) {\n        var s = classString.split(\" \");\n        for (var i=0; i<s.length; i++) {\n          if (s[i] === className) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    return new dom.NodeList(this.ownerDocument || this, dom.mapper(this, filterByClassName));\n  };\n\n  defineGetter(dom.Element.prototype, 'sourceIndex', function() {\n    /*\n    * According to QuirksMode:\n    * Get the sourceIndex of element x. This is also the index number for\n    * the element in the document.getElementsByTagName('*') array.\n    * http://www.quirksmode.org/dom/w3c_core.html#t77\n    */\n    var items = this.ownerDocument.getElementsByTagName('*'),\n        len = items.length;\n\n    for (var i = 0; i < len; i++) {\n      if (items[i] === this) {\n        return i;\n      }\n    }\n  });\n\n  defineGetter(dom.Document.prototype, 'outerHTML', function() {\n    return domToHtml(this, true);\n  });\n\n  defineGetter(dom.Element.prototype, 'outerHTML', function() {\n    return domToHtml(this, true);\n  });\n\n  defineGetter(dom.Element.prototype, 'innerHTML', function() {\n    if (/^(?:script|style)$/.test(this._tagName)) {\n      var type = this.getAttribute('type');\n      if (!type || /^text\\//i.test(type) || /\\/javascript$/i.test(type)) {\n        return domToHtml(this._childNodes, true, true);\n      }\n    }\n\n    return domToHtml(this._childNodes, true);\n  });\n\n  defineSetter(dom.Element.prototype, 'doctype', function() {\n    throw new dom.DOMException(dom.NO_MODIFICATION_ALLOWED_ERR);\n  });\n  defineGetter(dom.Element.prototype, 'doctype', function() {\n    var r = null;\n    if (this.nodeName == '#document') {\n        if (this._doctype) {\n         r = this._doctype;\n        }\n    }\n    return r;\n  });\n\n  defineSetter(dom.Element.prototype, 'innerHTML', function(html) {\n    //Clear the children first:\n    var child;\n    while ((child = this._childNodes[0])) {\n      this.removeChild(child);\n    }\n\n    if (this.nodeName === '#document') {\n      parseDocType(this, html);\n\n      if(this._doctype) {\n        this._childNodes[0] = this._doctype;\n      }\n    }\n    if (html !== \"\" && html != null) {\n      htmltodom.appendHtmlToElement(html, this);\n    }\n    return html;\n  });\n\n\n  defineGetter(dom.Document.prototype, 'innerHTML', function() {\n    return domToHtml(this._childNodes, true);\n  });\n\n  defineSetter(dom.Document.prototype, 'innerHTML', function(html) {\n    //Clear the children first:\n    var child;\n    while ((child = this._childNodes[0])) {\n      this.removeChild(child);\n    }\n\n    if (this.nodeName === '#document') {\n      parseDocType(this, html);\n\n      if(this._doctype) {\n        this._childNodes[0] = this._doctype;\n      }\n    }\n    if (html !== \"\" && html != null) {\n      htmltodom.appendHtmlToDocument(html, this);\n    }\n    return html;\n  });\n\n  var DOC_HTML5      = /<!doctype html>/i,\n      DOC_TYPE       = /<!DOCTYPE (\\w(.|\\n)*)\">/i,\n      DOC_TYPE_START = '<!DOCTYPE ',\n      DOC_TYPE_END   = '\">';\n\n  function parseDocType(doc, html) {\n    var publicID = '',\n        systemID = '',\n        fullDT = '',\n        name = 'html',\n        set = true,\n        doctype = html.match(DOC_HTML5);\n\n    //Default, No doctype === null\n    doc._doctype = null;\n\n    if (doctype && doctype[0]) { //Handle the HTML shorty doctype\n      fullDT = doctype[0];\n    } else { //Parse the doctype\n      // find the start\n      var start     = html.indexOf(DOC_TYPE_START),\n          end       = html.indexOf(DOC_TYPE_END),\n          docString;\n\n      if (start < 0 || end < 0) {\n        return;\n      }\n\n      docString = html.substr(start, (end-start)+DOC_TYPE_END.length);\n      doctype = docString.replace(/[\\n\\r]/g,'').match(DOC_TYPE);\n\n      if (!doctype) {\n        return;\n      }\n\n      fullDT = doctype[0];\n      doctype = doctype[1].split(' \"');\n      var _id1 = doctype.length ? doctype.pop().replace(/\"/g, '') : '',\n          _id2 = doctype.length ? doctype.pop().replace(/\"/g, '') : '';\n\n      if (_id1.indexOf('-//') !== -1) {\n        publicID = _id1;\n      }\n      if (_id2.indexOf('-//') !== -1) {\n        publicID = _id2;\n      }\n      if (_id1.indexOf('://') !== -1) {\n        systemID = _id1;\n      }\n      if (_id2.indexOf('://') !== -1) {\n        systemID = _id2;\n      }\n      if (doctype.length) {\n        doctype = doctype[0].split(' ');\n        name = doctype[0];\n      }\n    }\n    doc._doctype = new dom.DOMImplementation().createDocumentType(name, publicID, systemID);\n    doc._doctype._ownerDocument = doc;\n    doc._doctype._parentNode = doc;\n    doc._doctype._fullDT = fullDT;\n    doc._doctype.toString = function() {\n      return this._fullDT;\n    };\n  }\n\n  dom.Document.prototype.getElementsByClassName = function(className) {\n\n    function filterByClassName(child) {\n      if (!child) {\n        return false;\n      }\n\n      if (child.nodeType &&\n          child.nodeType === dom.Node.ENTITY_REFERENCE_NODE)\n      {\n        child = child._entity;\n      }\n\n      var classString = child.className;\n      if (classString) {\n        var s = classString.split(\" \");\n        for (var i=0; i<s.length; i++) {\n          if (s[i] === className) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    return new dom.NodeList(this.ownerDocument || this, dom.mapper(this, filterByClassName));\n  };\n\n  defineGetter(dom.Element.prototype, 'nodeName', function(val) {\n    return this._nodeName.toUpperCase();\n  });\n\n  defineGetter(dom.Element.prototype, 'tagName', function(val) {\n    var t = this._tagName.toUpperCase();\n    //Document should not return a tagName\n    if (this.nodeName === '#document') {\n      t = null;\n    }\n    return t;\n  });\n\n  dom.Element.prototype.scrollTop = 0;\n  dom.Element.prototype.scrollLeft = 0;\n\n  defineGetter(dom.Document.prototype, 'parentWindow', function() {\n    if (!this._parentWindow) {\n      this.parentWindow = exports.windowAugmentation(dom, {document: this, url: this.URL});\n    }\n    return this._parentWindow;\n  });\n\n  defineSetter(dom.Document.prototype, 'parentWindow', function(window) {\n    // Contextify does not support getters and setters, so we have to set them\n    // on the original object instead.\n    window._frame = function (name, frame) {\n      if (typeof frame === 'undefined') {\n        delete window[name];\n      } else {\n        defineGetter(window, name, function () { return frame.contentWindow; });\n      }\n    };\n    this._parentWindow = window.getGlobal();\n  });\n\n  defineGetter(dom.Document.prototype, 'defaultView', function() {\n    return this.parentWindow;\n  });\n\n  dom._augmented = true;\n  return dom;\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/browser/location.js":"\"use strict\";\n\nvar URL = require(\"url\");\nvar NOT_IMPLEMENTED = require(\"./utils\").NOT_IMPLEMENTED;\n\nmodule.exports = Location;\n\nfunction Location(urlString, window) {\n  this._url = URL.parse(urlString);\n  this._window = window;\n}\n\nLocation.prototype = {\n  constructor: Location,\n  reload: function () {\n    NOT_IMPLEMENTED(this._window, \"location.reload\")();\n  },\n  get protocol() { return this._url.protocol || \":\"; },\n  get host() { return this._url.host || \"\"; },\n  get auth() { return this._url.auth; },\n  get hostname() { return this._url.hostname || \"\"; },\n  get origin() { return ((this._url.protocol !== undefined && this._url.protocol !== null) ? this._url.protocol + \"//\" : this._url.protocol) + this._url.host || \"\"; },\n  get port() { return this._url.port || \"\"; },\n  get pathname() { return this._url.pathname || \"\"; },\n  get href() { return this._url.href; },\n  get hash() { return this._url.hash || \"\"; },\n  get search() { return this._url.search || \"\"; },\n\n  set href(val) {\n    var oldUrl = this._url.href;\n    var oldProtocol = this._url.protocol;\n    var oldHost = this._url.host;\n    var oldPathname = this._url.pathname;\n    var oldHash = this._url.hash || \"\";\n\n    this._url = URL.parse(URL.resolve(oldUrl, val));\n    var newUrl = this._url.href;\n    var newProtocol = this._url.protocol;\n    var newHost = this._url.host;\n    var newPathname = this._url.pathname;\n    var newHash = this._url.hash || \"\";\n\n    if (oldProtocol === newProtocol && oldHost === newHost && oldPathname === newPathname && oldHash !== newHash) {\n      this._signalHashChange(oldUrl, newUrl);\n    } else {\n      NOT_IMPLEMENTED(this._window, \"location.href (no reload)\")();\n    }\n  },\n\n  set hash(val) {\n    var oldUrl = this._url.href;\n    var oldHash = this._url.hash || \"\";\n\n    if (val.lastIndexOf(\"#\", 0) !== 0) {\n      val = \"#\" + val;\n    }\n\n    this._url = URL.parse(URL.resolve(oldUrl, val));\n    var newUrl = this._url.href;\n    var newHash = this._url.hash || \"\";\n\n    if (oldHash !== newHash) {\n      this._signalHashChange(oldUrl, newUrl);\n    }\n  },\n\n  set search(val) {\n    var oldUrl = this._url.href;\n    var oldHash = this._url.hash || \"\";\n    if (val.length) {\n      if (val.lastIndexOf(\"?\", 0) !== 0) {\n        val = \"?\" + val;\n      }\n      this._url = URL.parse(URL.resolve(oldUrl, val + oldHash));\n    } else {\n      this._url = URL.parse(oldUrl.replace(/\\?([^#]+)/, \"\"));\n    }\n  },\n\n  replace: function (val) {\n    this.href = val;\n  },\n\n  toString: function () {\n    return this._url.href;\n  },\n\n  _signalHashChange: function (oldUrl, newUrl) {\n    if (this._window.document) {\n      var ev = this._window.document.createEvent(\"HTMLEvents\");\n      ev.initEvent(\"hashchange\", false, false);\n      ev.oldUrl = oldUrl;\n      ev.newUrl = newUrl;\n      process.nextTick(function () {\n        this._window.dispatchEvent(ev);\n      }.bind(this));\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/browser/utils.js":"\"use strict\";\n\nvar jsdom = require(\"../../jsdom\");\n\nexports.NOT_IMPLEMENTED = function (target, nameForErrorMessage) {\n  return function () {\n    if (!jsdom.debugMode) {\n      var raise = target ? target.raise : this.raise;\n      raise.call(this, \"error\", \"NOT IMPLEMENTED\" + (nameForErrorMessage ? \": \" + nameForErrorMessage : \"\"));\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-js-dom/node_modules/js-dom/lib/jsdom/browser/history.js":"\"use strict\";\n\nvar URL = require('url');\n\nfunction StateEntry(data, title, url) {\n  this.data = data;\n  this.title = title;\n  this.url = url;\n}\n\nmodule.exports = History;\n\nfunction History(window) {\n  this._states = [];\n  this._index = -1;\n  this._window = window;\n  this._location = window.location;\n}\n\nHistory.prototype = {\n  constructor: History,\n\n  get length() {\n    return this._states.length;\n  },\n\n  get state() {\n    var state = this._states[this._index];\n    return state ? state.data : null;\n  },\n\n  back: function () {\n    this.go(-1);\n  },\n\n  forward: function () {\n    this.go(1);\n  },\n\n  go: function (delta) {\n    if (typeof delta === \"undefined\" || delta === 0) {\n      this._location.reload();\n      return;\n    }\n\n    var newIndex = this._index + delta;\n\n    if (newIndex < 0 || newIndex >= this.length) {\n      return;\n    }\n\n    this._index = newIndex;\n    this._applyState(this._states[this._index]);\n  },\n\n  pushState: function (data, title, url) {\n    var state = new StateEntry(data, title, url);\n    if (this._index + 1 !== this._states.length) {\n      this._states = this._states.slice(0, this._index + 1);\n    }\n    this._states.push(state);\n    this._applyState(state);\n    this._index++;\n  },\n\n  replaceState: function (data, title, url) {\n    var state = new StateEntry(data, title, url);\n    this._states[this._index] = state;\n    this._applyState(state);\n  },\n\n  _applyState: function(state) {\n    this._location._url = URL.parse(URL.resolve(this._location._url.href, state.url));\n\n    this._signalPopstate(state);\n  },\n\n  _signalPopstate: function(state) {\n    if (this._window.document) {\n      var ev = this._window.document.createEvent(\"HTMLEvents\");\n      ev.initEvent(\"popstate\", false, false);\n      ev.state = state.data;\n      process.nextTick(function () {\n        this._window.dispatchEvent(ev);\n      }.bind(this));\n    }\n  },\n\n  toString: function () {\n    return \"[object History]\";\n  }\n};\n"}